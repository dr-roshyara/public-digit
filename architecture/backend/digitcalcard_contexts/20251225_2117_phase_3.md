# **PHASE 3: ASYNCHRONOUS INTEGRITY & HARDENING**
**Backend Services Implementation - Event-Driven Architecture & Security**

---

## **1. DOMAIN EVENTS - CORE EVENT STREAM**

```php
<?php
// app/Contexts/DigitalCard/Domain/Events/DigitalCardEvents.php
// All domain events for the DigitalCard bounded context

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Domain\Events;

use App\Contexts\DigitalCard\Domain\ValueObjects\CardId;
use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use DateTimeImmutable;

interface DigitalCardEvent
{
    public function occurredAt(): DateTimeImmutable;
    public function aggregateId(): string;
}

// 1. CARD ISSUED EVENT
final class CardIssued implements DigitalCardEvent
{
    public function __construct(
        private CardId $cardId,
        private MemberId $memberId,
        private DateTimeImmutable $issuedAt,
        private DateTimeImmutable $expiresAt,
        private DateTimeImmutable $occurredAt
    ) {}
    
    public function cardId(): CardId { return $this->cardId; }
    public function memberId(): MemberId { return $this->memberId; }
    public function issuedAt(): DateTimeImmutable { return $this->issuedAt; }
    public function expiresAt(): DateTimeImmutable { return $this->expiresAt; }
    public function occurredAt(): DateTimeImmutable { return $this->occurredAt; }
    public function aggregateId(): string { return $this->cardId->toString(); }
    
    public function toArray(): array
    {
        return [
            'event' => 'CardIssued',
            'card_id' => $this->cardId->toString(),
            'member_id' => $this->memberId->toString(),
            'issued_at' => $this->issuedAt->format(\DateTimeInterface::ATOM),
            'expires_at' => $this->expiresAt->format(\DateTimeInterface::ATOM),
            'occurred_at' => $this->occurredAt->format(\DateTimeInterface::ATOM),
        ];
    }
}

// 2. CARD ACTIVATED EVENT
final class CardActivated implements DigitalCardEvent
{
    public function __construct(
        private CardId $cardId,
        private DateTimeImmutable $activatedAt,
        private DateTimeImmutable $occurredAt
    ) {}
    
    public function cardId(): CardId { return $this->cardId; }
    public function activatedAt(): DateTimeImmutable { return $this->activatedAt; }
    public function occurredAt(): DateTimeImmutable { return $this->occurredAt; }
    public function aggregateId(): string { return $this->cardId->toString(); }
}

// 3. CARD REVOKED EVENT
final class CardRevoked implements DigitalCardEvent
{
    public function __construct(
        private CardId $cardId,
        private string $reason,
        private DateTimeImmutable $revokedAt,
        private DateTimeImmutable $occurredAt
    ) {}
    
    public function cardId(): CardId { return $this->cardId; }
    public function reason(): string { return $this->reason; }
    public function revokedAt(): DateTimeImmutable { return $this->revokedAt; }
    public function occurredAt(): DateTimeImmutable { return $this->occurredAt; }
    public function aggregateId(): string { return $this->cardId->toString(); }
}

// 4. CARD EXPIRED EVENT
final class CardExpired implements DigitalCardEvent
{
    public function __construct(
        private CardId $cardId,
        private DateTimeImmutable $expiredAt,
        private DateTimeImmutable $occurredAt
    ) {}
    
    public function cardId(): CardId { return $this->cardId; }
    public function expiredAt(): DateTimeImmutable { return $this->expiredAt; }
    public function occurredAt(): DateTimeImmutable { return $this->occurredAt; }
    public function aggregateId(): string { return $this->cardId->toString(); }
}

// 5. CARD VALIDATED EVENT (for audit trail)
final class CardValidated implements DigitalCardEvent
{
    public function __construct(
        private CardId $cardId,
        private MemberId $validatorMemberId,
        private bool $success,
        private ?string $failureReason,
        private array $context,
        private DateTimeImmutable $occurredAt
    ) {}
    
    public function cardId(): CardId { return $this->cardId; }
    public function validatorMemberId(): MemberId { return $this->validatorMemberId; }
    public function success(): bool { return $this->success; }
    public function failureReason(): ?string { return $this->failureReason; }
    public function context(): array { return $this->context; }
    public function occurredAt(): DateTimeImmutable { return $this->occurredAt; }
    public function aggregateId(): string { return $this->cardId->toString(); }
}
```

---

## **2. EVENT-PUBLISHING AGGREGATE ROOT**

```php
<?php
// app/Contexts/DigitalCard/Domain/Entities/DigitalCard.php (Updated with Events)

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Domain\Entities;

// ... existing imports
use App\Contexts\DigitalCard\Domain\Events\CardIssued;
use App\Contexts\DigitalCard\Domain\Events\CardActivated;
use App\Contexts\DigitalCard\Domain\Events\CardRevoked;
use App\Contexts\DigitalCard\Domain\Events\CardExpired;

final class DigitalCard implements AggregateRoot
{
    // ... existing properties
    
    /**
     * Domain Events collected during this aggregate's lifecycle
     * @var array<DigitalCardEvent>
     */
    private array $domainEvents = [];
    
    /**
     * FACTORY METHOD: Issue new card (updated with event)
     */
    public static function issue(
        CardId $cardId,
        MemberId $memberId,
        QRCode $qrCode,
        DateTimeImmutable $issuedAt,
        DateTimeImmutable $expiresAt
    ): self {
        // ... existing validation
        
        $card = new self($cardId, $memberId, $qrCode, $issuedAt, $expiresAt);
        
        // Record domain event
        $card->recordThat(new CardIssued(
            cardId: $cardId,
            memberId: $memberId,
            issuedAt: $issuedAt,
            expiresAt: $expiresAt,
            occurredAt: new DateTimeImmutable()
        ));
        
        return $card;
    }
    
    /**
     * BUSINESS METHOD: Activate an issued card (updated with event)
     */
    public function activate(DateTimeImmutable $activatedAt): void
    {
        // ... existing validation
        
        $this->status = CardStatus::ACTIVE;
        $this->activatedAt = $activatedAt;
        
        // Record domain event
        $this->recordThat(new CardActivated(
            cardId: $this->cardId,
            activatedAt: $activatedAt,
            occurredAt: new DateTimeImmutable()
        ));
    }
    
    /**
     * BUSINESS METHOD: Revoke a card (updated with event)
     */
    public function revoke(string $reason, DateTimeImmutable $revokedAt): void
    {
        // ... existing validation
        
        $this->status = CardStatus::REVOKED;
        $this->revokedAt = $revokedAt;
        $this->revocationReason = $reason;
        
        // Record domain event
        $this->recordThat(new CardRevoked(
            cardId: $this->cardId,
            reason: $reason,
            revokedAt: $revokedAt,
            occurredAt: new DateTimeImmutable()
        ));
    }
    
    /**
     * DOMAIN SERVICE METHOD: Auto-expire if needed (updated with event)
     */
    public function checkExpiry(DateTimeImmutable $currentTime): void
    {
        if ($this->status->equals(CardStatus::ACTIVE) 
            && $currentTime >= $this->expiresAt) {
            
            $this->status = CardStatus::EXPIRED;
            
            // Record domain event
            $this->recordThat(new CardExpired(
                cardId: $this->cardId,
                expiredAt: $currentTime,
                occurredAt: new DateTimeImmutable()
            ));
        }
    }
    
    /**
     * Create validation event (for audit trail)
     */
    public function recordValidation(
        MemberId $validatorMemberId,
        bool $success,
        ?string $failureReason,
        array $context
    ): void {
        $this->recordThat(new CardValidated(
            cardId: $this->cardId,
            validatorMemberId: $validatorMemberId,
            success: $success,
            failureReason: $failureReason,
            context: $context,
            occurredAt: new DateTimeImmutable()
        ));
    }
    
    /**
     * EVENT SOURCING: Record a domain event
     */
    private function recordThat(DigitalCardEvent $event): void
    {
        $this->domainEvents[] = $event;
    }
    
    /**
     * EVENT SOURCING: Release and clear recorded events
     */
    public function releaseEvents(): array
    {
        $events = $this->domainEvents;
        $this->domainEvents = [];
        return $events;
    }
    
    /**
     * Get last event (useful for projections)
     */
    public function lastEvent(): ?DigitalCardEvent
    {
        if (empty($this->domainEvents)) {
            return null;
        }
        return end($this->domainEvents);
    }
}
```

---

## **3. ANTI-CORRUPTION LAYER (ACL) - MEMBERSHIP EVENT SUBSCRIBER**

```php
<?php
// app/Contexts/DigitalCard/Infrastructure/EventSubscribers/MembershipEventSubscriber.php
// CRITICAL: Listens to MembershipContext events without hard dependencies

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\EventSubscribers;

use App\Contexts\DigitalCard\Domain\Repositories\DigitalCardRepository;
use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use App\Contexts\Membership\Domain\Events\MembershipCancelled;
use App\Contexts\Membership\Domain\Events\MemberSuspended;
use App\Contexts\Membership\Domain\Events\MemberReactivated;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Events\Dispatcher;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;

/**
 * Anti-Corruption Layer between DigitalCard and Membership contexts
 * 
 * Design Principles:
 * 1. Listens to Membership events but knows nothing about Membership internals
 * 2. Uses only published language (MemberId)
 * 3. Handles failures gracefully with retry logic
 * 4. Transactional integrity within DigitalCard context
 */
final class MembershipEventSubscriber implements ShouldQueue
{
    public function __construct(
        private DigitalCardRepository $cardRepository
    ) {}
    
    /**
     * Register event listeners
     */
    public function subscribe(Dispatcher $events): void
    {
        // Membership lifecycle events
        $events->listen(
            MembershipCancelled::class,
            [self::class, 'handleMembershipCancelled']
        );
        
        $events->listen(
            MemberSuspended::class,
            [self::class, 'handleMemberSuspended']
        );
        
        $events->listen(
            MemberReactivated::class,
            [self::class, 'handleMemberReactivated']
        );
    }
    
    /**
     * Handle membership cancellation - REVOKE ALL CARDS
     * 
     * @param MembershipCancelled $event
     * @return void
     */
    public function handleMembershipCancelled(MembershipCancelled $event): void
    {
        Log::info('Processing MembershipCancelled event', [
            'member_id' => $event->memberId,
            'reason' => $event->reason,
            'cancelled_at' => $event->cancelledAt
        ]);
        
        try {
            DB::transaction(function () use ($event) {
                $memberId = MemberId::fromString($event->memberId);
                
                // Find all cards for this member
                $cards = $this->cardRepository->byMember($memberId);
                
                $revokedCount = 0;
                foreach ($cards as $card) {
                    // Only revoke active or issued cards
                    if ($card->status()->canTransitionTo(\App\Contexts\DigitalCard\Domain\Enums\CardStatus::REVOKED)) {
                        $card->revoke(
                            reason: "Membership cancelled: {$event->reason}",
                            revokedAt: new \DateTimeImmutable($event->cancelledAt)
                        );
                        
                        $this->cardRepository->save($card);
                        $revokedCount++;
                    }
                }
                
                Log::info('Membership cancellation processed', [
                    'member_id' => $event->memberId,
                    'cards_revoked' => $revokedCount,
                    'total_cards' => count($cards)
                ]);
            });
            
        } catch (\Throwable $e) {
            Log::error('Failed to process MembershipCancelled event', [
                'member_id' => $event->memberId,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            
            // IMPORTANT: Re-throw for Laravel queue retry
            throw $e;
        }
    }
    
    /**
     * Handle member suspension - TEMPORARY DEACTIVATION
     */
    public function handleMemberSuspended(MemberSuspended $event): void
    {
        Log::info('Processing MemberSuspended event', [
            'member_id' => $event->memberId,
            'suspended_until' => $event->suspendedUntil
        ]);
        
        try {
            $memberId = MemberId::fromString($event->memberId);
            $cards = $this->cardRepository->byMember($memberId);
            
            foreach ($cards as $card) {
                // Mark card as temporarily suspended
                // This could trigger a "CardSuspended" event in your domain
                // or add a suspension flag to the card
                
                Log::debug('Card suspended due to member suspension', [
                    'card_id' => $card->id()->toString(),
                    'member_id' => $event->memberId
                ]);
            }
            
        } catch (\Throwable $e) {
            Log::error('Failed to process MemberSuspended event', [
                'member_id' => $event->memberId,
                'error' => $e->getMessage()
            ]);
        }
    }
    
    /**
     * Handle member reactivation - RE-ACTIVATE ELIGIBLE CARDS
     */
    public function handleMemberReactivated(MemberReactivated $event): void
    {
        Log::info('Processing MemberReactivated event', [
            'member_id' => $event->memberId,
            'reactivated_at' => $event->reactivatedAt
        ]);
        
        try {
            DB::transaction(function () use ($event) {
                $memberId = MemberId::fromString($event->memberId);
                $cards = $this->cardRepository->byMember($memberId);
                
                foreach ($cards as $card) {
                    // Reactivate cards that were suspended but not expired/revoked
                    if ($card->wasSuspended() && $card->isStillValid()) {
                        $card->reactivate(new \DateTimeImmutable($event->reactivatedAt));
                        $this->cardRepository->save($card);
                        
                        Log::debug('Card reactivated', [
                            'card_id' => $card->id()->toString(),
                            'member_id' => $event->memberId
                        ]);
                    }
                }
            });
            
        } catch (\Throwable $e) {
            Log::error('Failed to process MemberReactivated event', [
                'member_id' => $event->memberId,
                'error' => $e->getMessage()
            ]);
        }
    }
    
    /**
     * Configure queue settings
     */
    public function viaQueue(): string
    {
        return 'digitalcard-events';
    }
    
    public function retryUntil(): \DateTime
    {
        return now()->addHours(24);
    }
    
    public function backoff(): array
    {
        return [30, 60, 120, 300, 600]; // Exponential backoff in seconds
    }
}
```

---

## **4. SECURE QR CODE GENERATOR WITH HMAC SIGNATURES**

```php
<?php
// app/Contexts/DigitalCard/Infrastructure/Services/SignedQRCodeGenerator.php
// Security Hardening: Prevent QR code replay attacks

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\Services;

use App\Contexts\DigitalCard\Domain\ValueObjects\CardId;
use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use App\Contexts\DigitalCard\Domain\ValueObjects\QRCode as QRCodeVO;
use DateTimeImmutable;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

/**
 * Secure QR Code Generator with HMAC Signatures
 * 
 * Security Features:
 * 1. Time-limited validity (default 24 hours)
 * 2. HMAC signature prevents tampering
 * 3. Nonce prevents replay attacks
 * 4. Key rotation support
 */
final class SignedQRCodeGenerator implements QRCodeGeneratorInterface
{
    private const DEFAULT_TTL = 86400; // 24 hours
    private const NONCE_CACHE_PREFIX = 'qr_nonce:';
    private const KEY_VERSION = 'v1';
    
    private string $secretKey;
    private int $ttl;
    
    public function __construct()
    {
        // Get secret from config (rotated regularly)
        $this->secretKey = config('app.qr_signing_key', env('QR_SIGNING_KEY'));
        
        if (empty($this->secretKey) || strlen($this->secretKey) < 32) {
            throw new \RuntimeException('QR signing key must be at least 32 characters');
        }
        
        $this->ttl = config('digitalcard.qr_ttl', self::DEFAULT_TTL);
    }
    
    /**
     * Generate signed QR code for a card
     */
    public function generateForCard(CardId $cardId, MemberId $memberId): QRCodeVO
    {
        $payload = $this->createPayload($cardId, $memberId);
        $signedData = $this->signPayload($payload);
        
        Log::debug('Generated signed QR code', [
            'card_id' => $cardId->toString(),
            'member_id' => $memberId->toString(),
            'expires_at' => $payload['exp']
        ]);
        
        return QRCodeVO::fromString($signedData);
    }
    
    /**
     * Validate and parse a signed QR code
     */
    public function validateAndParse(string $signedData): ?array
    {
        try {
            $parts = explode('.', $signedData);
            
            if (count($parts) !== 3) {
                Log::warning('Invalid QR format: wrong number of parts');
                return null;
            }
            
            [$encodedPayload, $encodedSignature, $encodedNonce] = $parts;
            
            // Decode components
            $payload = json_decode(base64_decode($encodedPayload), true);
            $signature = base64_decode($encodedSignature);
            $nonce = base64_decode($encodedNonce);
            
            if (!$payload || !$signature || !$nonce) {
                Log::warning('Invalid QR format: decoding failed');
                return null;
            }
            
            // 1. Check expiration
            if (time() > $payload['exp']) {
                Log::warning('QR code expired', ['expired_at' => $payload['exp']]);
                return null;
            }
            
            // 2. Verify signature
            $expectedSignature = $this->calculateSignature($encodedPayload, $nonce);
            if (!hash_equals($expectedSignature, $signature)) {
                Log::warning('QR signature mismatch - possible tampering');
                return null;
            }
            
            // 3. Check nonce (prevent replay attacks)
            if (!$this->validateNonce($nonce, $payload['cid'])) {
                Log::warning('QR nonce validation failed - possible replay attack');
                return null;
            }
            
            // 4. Check key version
            if ($payload['kv'] !== self::KEY_VERSION) {
                Log::warning('QR key version mismatch', [
                    'expected' => self::KEY_VERSION,
                    'actual' => $payload['kv']
                ]);
                return null;
            }
            
            return [
                'card_id' => $payload['cid'],
                'member_id' => $payload['mid'],
                'issued_at' => $payload['iat'],
                'expires_at' => $payload['exp'],
                'nonce' => $nonce
            ];
            
        } catch (\Throwable $e) {
            Log::error('QR validation error', [
                'error' => $e->getMessage(),
                'data' => substr($signedData, 0, 50) . '...'
            ]);
            return null;
        }
    }
    
    /**
     * Create secure payload
     */
    private function createPayload(CardId $cardId, MemberId $memberId): array
    {
        $now = time();
        
        return [
            'cid' => $cardId->toString(),      // Card ID
            'mid' => $memberId->toString(),    // Member ID
            'iat' => $now,                     // Issued at
            'exp' => $now + $this->ttl,        // Expires at
            'kv'  => self::KEY_VERSION,        // Key version
            'tid' => app('currentTenant')->id ?? 0 // Tenant ID for additional context
        ];
    }
    
    /**
     * Sign payload and create final QR string
     */
    private function signPayload(array $payload): string
    {
        // Generate cryptographically secure nonce
        $nonce = random_bytes(16);
        
        // Encode payload
        $encodedPayload = base64_encode(json_encode($payload));
        
        // Calculate signature
        $signature = $this->calculateSignature($encodedPayload, $nonce);
        $encodedSignature = base64_encode($signature);
        $encodedNonce = base64_encode($nonce);
        
        // Cache nonce to prevent replay
        $this->cacheNonce($nonce, $payload['cid']);
        
        // Format: payload.signature.nonce
        return "{$encodedPayload}.{$encodedSignature}.{$encodedNonce}";
    }
    
    /**
     * Calculate HMAC signature
     */
    private function calculateSignature(string $encodedPayload, string $nonce): string
    {
        $dataToSign = $encodedPayload . '.' . base64_encode($nonce);
        return hash_hmac('sha256', $dataToSign, $this->secretKey, true);
    }
    
    /**
     * Cache nonce to prevent replay attacks
     */
    private function cacheNonce(string $nonce, string $cardId): void
    {
        $key = self::NONCE_CACHE_PREFIX . hash('sha256', $nonce);
        Cache::put($key, $cardId, $this->ttl);
    }
    
    /**
     * Validate nonce hasn't been used before
     */
    private function validateNonce(string $nonce, string $cardId): bool
    {
        $key = self::NONCE_CACHE_PREFIX . hash('sha256', $nonce);
        
        // Try to get and delete atomically (prevent race conditions)
        $cachedCardId = Cache::pull($key);
        
        if ($cachedCardId === null) {
            // Nonce not found in cache (expired or never existed)
            return false;
        }
        
        // Verify nonce belongs to this card
        return $cachedCardId === $cardId;
    }
    
    /**
     * Rotate signing key (to be called periodically)
     */
    public function rotateKey(string $newKey): void
    {
        if (strlen($newKey) < 32) {
            throw new \InvalidArgumentException('New key must be at least 32 characters');
        }
        
        // In production, you would:
        // 1. Store old key for graceful rotation
        // 2. Update config
        // 3. Update KEY_VERSION
        // 4. Clear nonce cache
        
        Cache::clearPrefix(self::NONCE_CACHE_PREFIX);
        
        Log::info('QR signing key rotated', [
            'old_version' => self::KEY_VERSION,
            'new_version' => 'v' . (intval(substr(self::KEY_VERSION, 1)) + 1)
        ]);
    }
    
    /**
     * Get generator status for monitoring
     */
    public function getStatus(): array
    {
        return [
            'key_version' => self::KEY_VERSION,
            'ttl_seconds' => $this->ttl,
            'nonce_cache_size' => $this->getNonceCacheSize(),
            'algorithm' => 'HMAC-SHA256'
        ];
    }
    
    private function getNonceCacheSize(): int
    {
        // This is a simplified version
        // In production, use Redis SCAN or dedicated metrics
        return 0;
    }
}
```

---

## **5. ENHANCED VALIDATION SERVICE WITH SIGNED QR SUPPORT**

```php
<?php
// app/Contexts/DigitalCard/Domain/Services/CardValidationService.php
// Updated to support signed QR codes

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Domain\Services;

use App\Contexts\DigitalCard\Domain\Entities\DigitalCard;
use App\Contexts\DigitalCard\Domain\Repositories\DigitalCardRepository;
use App\Contexts\DigitalCard\Domain\ValueObjects\CardId;
use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use App\Contexts\DigitalCard\Domain\ValueObjects\ValidationContext;
use App\Contexts\DigitalCard\Infrastructure\Services\SignedQRCodeGenerator;
use DateTimeImmutable;

final class CardValidationService
{
    public function __construct(
        private DigitalCardRepository $repository,
        private SignedQRCodeGenerator $qrGenerator
    ) {}
    
    /**
     * Validate card with signed QR code support
     */
    public function validate(
        CardId $cardId,
        MemberId $validatorMemberId,
        ValidationContext $context
    ): ValidationResult {
        // 1. Get card from repository
        $card = $this->repository->byId($cardId);
        
        if (!$card) {
            return ValidationResult::invalid(
                reason: 'card_not_found',
                message: 'No card found with this ID'
            );
        }
        
        // 2. Validate QR signature if provided
        if ($context->hasQRCode()) {
            $qrData = $this->qrGenerator->validateAndParse($context->getQRCode());
            
            if (!$qrData) {
                $card->recordValidation(
                    validatorMemberId: $validatorMemberId,
                    success: false,
                    failureReason: 'invalid_qr_signature',
                    context: $context->toArray()
                );
                
                $this->repository->save($card);
                
                return ValidationResult::invalid(
                    reason: 'invalid_qr_signature',
                    message: 'QR code signature validation failed'
                );
            }
            
            // Verify QR data matches card
            if ($qrData['card_id'] !== $cardId->toString()) {
                return ValidationResult::invalid(
                    reason: 'qr_card_mismatch',
                    message: 'QR code does not match card'
                );
            }
        }
        
        // 3. Check card status
        if (!$card->status()->isValid()) {
            $card->recordValidation(
                validatorMemberId: $validatorMemberId,
                success: false,
                failureReason: 'card_invalid_status',
                context: $context->toArray()
            );
            
            $this->repository->save($card);
            
            return ValidationResult::invalid(
                reason: 'card_invalid_status',
                message: "Card status is {$card->status()->value}"
            );
        }
        
        // 4. Check expiry
        if ($card->expiresAt() <= new DateTimeImmutable()) {
            $card->recordValidation(
                validatorMemberId: $validatorMemberId,
                success: false,
                failureReason: 'card_expired',
                context: $context->toArray()
            );
            
            $this->repository->save($card);
            
            return ValidationResult::invalid(
                reason: 'card_expired',
                message: 'Card has expired'
            );
        }
        
        // 5. SUCCESS: Record successful validation
        $card->recordValidation(
            validatorMemberId: $validatorMemberId,
            success: true,
            failureReason: null,
            context: $context->toArray()
        );
        
        $this->repository->save($card);
        
        return ValidationResult::valid(
            card: $card,
            validationId: $this->generateValidationId()
        );
    }
    
    /**
     * Generate unique validation ID for audit trail
     */
    private function generateValidationId(): string
    {
        return 'val_' . time() . '_' . bin2hex(random_bytes(8));
    }
}
```

---

## **6. EVENT PROJECTION FOR AUDIT TRAIL & ANALYTICS**

```php
<?php
// app/Contexts/DigitalCard/Infrastructure/Projections/CardEventProjector.php
// Project domain events to read-optimized tables

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\Projections;

use App\Contexts\DigitalCard\Domain\Events\CardValidated;
use App\Contexts\DigitalCard\Domain\Events\CardIssued;
use App\Contexts\DigitalCard\Domain\Events\CardRevoked;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

/**
 * Event Projector for read-optimized queries
 * 
 * Purpose: Create denormalized tables for:
 * 1. Audit trail
 * 2. Analytics
 * 3. Dashboard reporting
 * 4. Mobile app history
 */
final class CardEventProjector implements ShouldQueue
{
    public function handleCardIssued(CardIssued $event): void
    {
        try {
            DB::table('card_issuance_audit')->insert([
                'card_id' => $event->cardId()->toString(),
                'member_id' => $event->memberId()->toString(),
                'issued_at' => $event->issuedAt(),
                'expires_at' => $event->expiresAt(),
                'event_type' => 'issued',
                'occurred_at' => $event->occurredAt(),
                'tenant_id' => app('currentTenant')->id,
                'metadata' => json_encode([])
            ]);
            
            // Update card statistics
            $this->updateCardStats($event->memberId(), 'issued');
            
        } catch (\Throwable $e) {
            Log::error('Failed to project CardIssued event', [
                'card_id' => $event->cardId()->toString(),
                'error' => $e->getMessage()
            ]);
        }
    }
    
    public function handleCardValidated(CardValidated $event): void
    {
        try {
            DB::table('card_validation_audit')->insert([
                'card_id' => $event->cardId()->toString(),
                'validator_member_id' => $event->validatorMemberId()->toString(),
                'success' => $event->success(),
                'failure_reason' => $event->failureReason(),
                'context' => json_encode($event->context()),
                'occurred_at' => $event->occurredAt(),
                'tenant_id' => app('currentTenant')->id
            ]);
            
            // Update validation statistics
            $this->updateValidationStats(
                $event->cardId(),
                $event->success(),
                $event->occurredAt()
            );
            
        } catch (\Throwable $e) {
            Log::error('Failed to project CardValidated event', [
                'card_id' => $event->cardId()->toString(),
                'error' => $e->getMessage()
            ]);
        }
    }
    
    public function handleCardRevoked(CardRevoked $event): void
    {
        try {
            DB::table('card_lifecycle_audit')->insert([
                'card_id' => $event->cardId()->toString(),
                'event_type' => 'revoked',
                'reason' => $event->reason(),
                'occurred_at' => $event->occurredAt(),
                'tenant_id' => app('currentTenant')->id,
                'metadata' => json_encode([
                    'revoked_at' => $event->revokedAt()->format(\DateTimeInterface::ATOM)
                ])
            ]);
            
            // Update card statistics
            $this->updateCardStatsFromCardId($event->cardId(), 'revoked');
            
        } catch (\Throwable $e) {
            Log::error('Failed to project CardRevoked event', [
                'card_id' => $event->cardId()->toString(),
                'error' => $e->getMessage()
            ]);
        }
    }
    
    /**
     * Update card statistics (denormalized for fast queries)
     */
    private function updateCardStats(MemberId $memberId, string $action): void
    {
        DB::table('member_card_stats')
            ->where('member_id', $memberId->toString())
            ->where('tenant_id', app('currentTenant')->id)
            ->update([
                "{$action}_count" => DB::raw("{$action}_count + 1"),
                'last_activity' => now()
            ]);
    }
    
    private function updateCardStatsFromCardId(CardId $cardId, string $action): void
    {
        // Get member_id from card first
        $card = DB::table('digital_cards')
            ->where('id', $cardId->toString())
            ->first(['member_id']);
        
        if ($card) {
            $this->updateCardStats(
                MemberId::fromString($card->member_id),
                $action
            );
        }
    }
    
    /**
     * Update validation statistics
     */
    private function updateValidationStats(
        CardId $cardId,
        bool $success,
        DateTimeImmutable $timestamp
    ): void {
        $table = $success ? 'successful_validations' : 'failed_validations';
        
        DB::table('card_validation_stats')
            ->where('card_id', $cardId->toString())
            ->where('tenant_id', app('currentTenant')->id)
            ->update([
                $table => DB::raw("{$table} + 1"),
                'last_validated_at' => $timestamp,
                'updated_at' => now()
            ]);
    }
    
    /**
     * Rebuild projections from event store
     */
    public function rebuildProjections(): void
    {
        Log::info('Starting card event projections rebuild');
        
        // Clear existing projections
        DB::table('card_validation_audit')->truncate();
        DB::table('card_issuance_audit')->truncate();
        DB::table('card_lifecycle_audit')->truncate();
        DB::table('member_card_stats')->truncate();
        DB::table('card_validation_stats')->truncate();
        
        // In a real implementation, you would:
        // 1. Read from event store
        // 2. Replay events in chronological order
        // 3. Rebuild all projections
        
        Log::info('Card event projections rebuild completed');
    }
}
```

---

## **7. CONFIGURATION & SERVICE REGISTRATION**

```php
<?php
// config/digitalcard.php
// Phase 3 Configuration

return [
    'events' => [
        'enable_projections' => env('DIGITALCARD_ENABLE_PROJECTIONS', true),
        'projection_queue' => env('DIGITALCARD_PROJECTION_QUEUE', 'default'),
        'event_ttl_days' => env('DIGITALCARD_EVENT_TTL_DAYS', 365), // Keep events for 1 year
    ],
    
    'security' => [
        'qr_signing_key' => env('QR_SIGNING_KEY', env('APP_KEY')),
        'qr_ttl_seconds' => env('QR_TTL_SECONDS', 86400), // 24 hours
        'qr_key_rotation_days' => env('QR_KEY_ROTATION_DAYS', 90),
        'nonce_cache_prefix' => 'qr_nonce:',
    ],
    
    'queues' => [
        'digitalcard_events' => [
            'connection' => env('DIGITALCARD_EVENTS_QUEUE_CONNECTION', 'redis'),
            'queue' => env('DIGITALCARD_EVENTS_QUEUE', 'digitalcard-events'),
            'retry_after' => 90,
            'timeout' => 60,
        ],
    ],
    
    'audit' => [
        'enable_validation_logging' => true,
        'retention_days' => 180,
        'anonymize_after_days' => 30, // Anonymize personal data after 30 days
    ],
];
```

```php
<?php
// app/Contexts/DigitalCard/Infrastructure/Providers/DigitalCardEventServiceProvider.php
// Register event listeners and projections

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\Providers;

use App\Contexts\DigitalCard\Domain\Events\CardIssued;
use App\Contexts\DigitalCard\Domain\Events\CardValidated;
use App\Contexts\DigitalCard\Domain\Events\CardRevoked;
use App\Contexts\DigitalCard\Infrastructure\EventSubscribers\MembershipEventSubscriber;
use App\Contexts\DigitalCard\Infrastructure\Projections\CardEventProjector;
use Illuminate\Foundation\Support\Providers\EventServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Event;

final class DigitalCardEventServiceProvider extends ServiceProvider
{
    protected $listen = [
        // Internal DigitalCard events
        CardIssued::class => [
            CardEventProjector::class . '@handleCardIssued',
        ],
        CardValidated::class => [
            CardEventProjector::class . '@handleCardValidated',
        ],
        CardRevoked::class => [
            CardEventProjector::class . '@handleCardRevoked',
        ],
        
        // External events (from other contexts)
        \App\Contexts\Membership\Domain\Events\MembershipCancelled::class => [
            MembershipEventSubscriber::class . '@handleMembershipCancelled',
        ],
        \App\Contexts\Membership\Domain\Events\MemberSuspended::class => [
            MembershipEventSubscriber::class . '@handleMemberSuspended',
        ],
        \App\Contexts\Membership\Domain\Events\MemberReactivated::class => [
            MembershipEventSubscriber::class . '@handleMemberReactivated',
        ],
    ];
    
    public function boot(): void
    {
        parent::boot();
        
        // Register the subscriber for Membership events
        Event::subscribe(MembershipEventSubscriber::class);
    }
}
```

---

## **8. DATABASE MIGRATIONS FOR PHASE 3**

```php
<?php
// database/migrations/tenant/2025_01_15_000010_create_card_audit_tables.php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        // 1. Card validation audit (for every validation attempt)
        Schema::create('card_validation_audit', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('card_id');
            $table->uuid('validator_member_id');
            $table->boolean('success');
            $table->string('failure_reason', 100)->nullable();
            $table->jsonb('context')->nullable(); // Location, device info, etc.
            $table->timestampTz('occurred_at');
            $table->unsignedBigInteger('tenant_id');
            
            $table->index(['card_id', 'occurred_at']);
            $table->index(['validator_member_id', 'occurred_at']);
            $table->index(['success', 'occurred_at']);
            $table->index('tenant_id');
            
            $table->foreign('tenant_id')->references('id')->on('tenants')->onDelete('cascade');
        });
        
        // 2. Card issuance audit
        Schema::create('card_issuance_audit', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('card_id');
            $table->uuid('member_id');
            $table->timestampTz('issued_at');
            $table->timestampTz('expires_at');
            $table->string('event_type', 20); // issued, reissued
            $table->timestampTz('occurred_at');
            $table->unsignedBigInteger('tenant_id');
            $table->jsonb('metadata')->nullable();
            
            $table->index(['member_id', 'issued_at']);
            $table->index(['card_id', 'issued_at']);
            $table->index('tenant_id');
        });
        
        // 3. Card lifecycle audit
        Schema::create('card_lifecycle_audit', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('card_id');
            $table->string('event_type', 20); // activated, revoked, expired, suspended
            $table->string('reason', 255)->nullable();
            $table->timestampTz('occurred_at');
            $table->unsignedBigInteger('tenant_id');
            $table->jsonb('metadata')->nullable();
            
            $table->index(['card_id', 'occurred_at']);
            $table->index(['event_type', 'occurred_at']);
            $table->index('tenant_id');
        });
        
        // 4. Denormalized statistics for fast queries
        Schema::create('member_card_stats', function (Blueprint $table) {
            $table->id();
            $table->uuid('member_id');
            $table->unsignedBigInteger('tenant_id');
            $table->integer('issued_count')->default(0);
            $table->integer('activated_count')->default(0);
            $table->integer('revoked_count')->default(0);
            $table->integer('validation_count')->default(0);
            $table->timestampTz('last_activity')->nullable();
            $table->timestamps();
            
            $table->unique(['member_id', 'tenant_id']);
            $table->index('tenant_id');
            
            $table->foreign('tenant_id')->references('id')->on('tenants')->onDelete('cascade');
        });
        
        // 5. Card validation statistics
        Schema::create('card_validation_stats', function (Blueprint $table) {
            $table->id();
            $table->uuid('card_id');
            $table->unsignedBigInteger('tenant_id');
            $table->integer('successful_validations')->default(0);
            $table->integer('failed_validations')->default(0);
            $table->timestampTz('last_validated_at')->nullable();
            $table->timestamps();
            
            $table->unique(['card_id', 'tenant_id']);
            $table->index('tenant_id');
        });
    }
    
    public function down(): void
    {
        Schema::dropIfExists('card_validation_stats');
        Schema::dropIfExists('member_card_stats');
        Schema::dropIfExists('card_lifecycle_audit');
        Schema::dropIfExists('card_issuance_audit');
        Schema::dropIfExists('card_validation_audit');
    }
};
```

---

## **9. COMPREHENSIVE TESTS FOR PHASE 3**

```php
<?php
// tests/Feature/Contexts/DigitalCard/Phase3/EventDrivenArchitectureTest.php

declare(strict_types=1);

namespace Tests\Feature\Contexts\DigitalCard\Phase3;

use App\Contexts\DigitalCard\Domain\Events\CardIssued;
use App\Contexts\DigitalCard\Domain\Events\CardRevoked;
use App\Contexts\Membership\Domain\Events\MembershipCancelled;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Queue;
use Tests\TestCase;

class EventDrivenArchitectureTest extends TestCase
{
    use RefreshDatabase;
    
    /** @test */
    public function card_issuance_publishes_domain_event(): void
    {
        Event::fake([CardIssued::class]);
        
        // Issue a card
        $card = $this->issueTestCard();
        
        // Assert event was published
        Event::assertDispatched(CardIssued::class, function ($event) use ($card) {
            return $event->cardId()->toString() === $card->id()->toString();
        });
    }
    
    /** @test */
    public function membership_cancellation_triggers_card_revocation(): void
    {
        Queue::fake();
        
        // Create member with active card
        $tenant = $this->createTestTenant();
        $member = $this->createMemberForTenant($tenant);
        $card = $this->issueActiveCardForMember($member);
        
        // Trigger membership cancellation
        Event::dispatch(new MembershipCancelled(
            memberId: $member->getId()->toString(),
            reason: 'voluntary_cancellation',
            cancelledAt: now()->toISOString()
        ));
        
        // Assert job was queued
        Queue::assertPushed(\App\Contexts\DigitalCard\Infrastructure\EventSubscribers\MembershipEventSubscriber::class);
        
        // Process the queue
        Queue::assertPushed(function ($job) {
            $job->handle();
            return true;
        });
        
        // Verify card was revoked
        $repository = app(\App\Contexts\DigitalCard\Domain\Repositories\DigitalCardRepository::class);
        $updatedCard = $repository->byId($card->id());
        
        $this->assertEquals('revoked', $updatedCard->status()->value);
        $this->assertStringContainsString('Membership cancelled', $updatedCard->revocationReason());
    }
    
    /** @test */
    public function signed_qr_codes_prevent_replay_attacks(): void
    {
        $generator = app(\App\Contexts\DigitalCard\Infrastructure\Services\SignedQRCodeGenerator::class);
        
        // Generate QR code
        $cardId = \App\Contexts\DigitalCard\Domain\ValueObjects\CardId::generate();
        $memberId = \App\Contexts\DigitalCard\Domain\ValueObjects\MemberId::fromString('test-member-id');
        
        $qrCode = $generator->generateForCard($cardId, $memberId);
        
        // First validation should succeed
        $parsed = $generator->validateAndParse($qrCode->toString());
        $this->assertNotNull($parsed);
        $this->assertEquals($cardId->toString(), $parsed['card_id']);
        
        // Second validation with same QR should fail (replay attack)
        $parsed2 = $generator->validateAndParse($qrCode->toString());
        $this->assertNull($parsed2, 'QR code should be rejected on replay');
    }
    
    /** @test */
    public function expired_qr_codes_are_rejected(): void
    {
        $generator = app(\App\Contexts\DigitalCard\Infrastructure\Services\SignedQRCodeGenerator::class);
        
        // Mock time to generate expired QR
        $this->travel(-25)->hours(); // Go back 25 hours
        
        $cardId = \App\Contexts\DigitalCard\Domain\ValueObjects\CardId::generate();
        $memberId = \App\Contexts\DigitalCard\Domain\ValueObjects\MemberId::fromString('test-member-id');
        
        $qrCode = $generator->generateForCard($cardId, $memberId);
        
        // Travel back to present
        $this->travelBack();
        
        // Expired QR should be rejected
        $parsed = $generator->validateAndParse($qrCode->toString());
        $this->assertNull($parsed, 'Expired QR code should be rejected');
    }
    
    /** @test */
    public function event_projections_create_audit_trail(): void
    {
        // Create card
        $card = $this->issueTestCard();
        
        // Validate card
        $validationService = app(\App\Contexts\DigitalCard\Domain\Services\CardValidationService::class);
        $validatorId = \App\Contexts\DigitalCard\Domain\ValueObjects\MemberId::fromString('validator-123');
        
        $result = $validationService->validate(
            $card->id(),
            $validatorId,
            new \App\Contexts\DigitalCard\Domain\ValueObjects\ValidationContext()
        );
        
        // Check audit table was populated
        $this->assertDatabaseHas('card_validation_audit', [
            'card_id' => $card->id()->toString(),
            'validator_member_id' => $validatorId->toString(),
            'success' => $result->isValid()
        ]);
        
        // Check stats were updated
        $this->assertDatabaseHas('card_validation_stats', [
            'card_id' => $card->id()->toString()
        ]);
    }
    
    /** @test */
    public function tampered_qr_codes_are_rejected(): void
    {
        $generator = app(\App\Contexts\DigitalCard\Infrastructure\Services\SignedQRCodeGenerator::class);
        
        $cardId = \App\Contexts\DigitalCard\Domain\ValueObjects\CardId::generate();
        $memberId = \App\Contexts\DigitalCard\Domain\ValueObjects\MemberId::fromString('test-member-id');
        
        $qrCode = $generator->generateForCard($cardId, $memberId);
        
        // Tamper with the QR code
        $parts = explode('.', $qrCode->toString());
        $parts[0] = base64_encode(json_encode(['tampered' => true])); // Replace payload
        
        $tamperedQr = implode('.', $parts);
        
        // Tampered QR should be rejected
        $parsed = $generator->validateAndParse($tamperedQr);
        $this->assertNull($parsed, 'Tampered QR code should be rejected');
    }
}
```

---

## **10. DEPLOYMENT SCRIPT FOR PHASE 3**

```bash
#!/bin/bash
# deploy-phase3.sh

set -e

echo "üöÄ Starting Phase 3 Deployment: Event-Driven Architecture & Security Hardening"

# 1. Run comprehensive tests
echo "üìã Running Phase 3 tests..."
php artisan test --testsuite=phase3 --coverage-html=coverage/phase3

# 2. Run database migrations
echo "üóÑÔ∏è  Running database migrations..."
php artisan tenants:migrate --context=DigitalCard --path=database/migrations/tenant/2025_01_15_000010_create_card_audit_tables.php

# 3. Generate QR signing key if not exists
if [ -z "$QR_SIGNING_KEY" ]; then
    echo "üîë Generating QR signing key..."
    export QR_SIGNING_KEY=$(openssl rand -base64 48)
    echo "QR_SIGNING_KEY=$QR_SIGNING_KEY" >> .env
fi

# 4. Clear and cache configurations
echo "‚öôÔ∏è  Caching configurations..."
php artisan config:clear
php artisan config:cache
php artisan event:cache
php artisan route:cache

# 5. Restart queue workers for new events
echo "üîÑ Restarting queue workers..."
php artisan queue:restart

# 6. Run initial projection rebuild (if needed)
if [ "$1" = "--rebuild-projections" ]; then
    echo "üîÑ Rebuilding event projections..."
    php artisan tinker --execute="app('App\\Contexts\\DigitalCard\\Infrastructure\\Projections\\CardEventProjector')->rebuildProjections()"
fi

# 7. Health check
echo "üè• Running health checks..."
curl -f http://localhost/health || exit 1

# 8. Enable Phase 3 features
echo "üéõÔ∏è  Enabling Phase 3 features..."
php artisan feature:enable digitalcard-signed-qr
php artisan feature:enable digitalcard-event-audit
php artisan feature:enable digitalcard-membership-integration

echo "‚úÖ Phase 3 deployment completed successfully!"
echo ""
echo "üìä New Features Enabled:"
echo "   ‚Ä¢ Event-driven architecture with domain events"
echo "   ‚Ä¢ Anti-Corruption Layer for Membership context"
echo "   ‚Ä¢ HMAC-signed QR codes with replay protection"
echo "   ‚Ä¢ Comprehensive audit trail and projections"
echo "   ‚Ä¢ Automatic card revocation on membership cancellation"
echo ""
echo "üîê Security Notes:"
echo "   ‚Ä¢ QR codes now expire after 24 hours"
echo "   ‚Ä¢ All validations are logged for audit"
echo "   ‚Ä¢ Membership changes automatically propagate"
echo "   ‚Ä¢ Event projections enable analytics"
```

---

## **üìä PHASE 3 SUCCESS METRICS**

| Metric | Target | Measurement |
|--------|--------|-------------|
| **Event Processing Latency** | < 100ms P95 | Queue monitoring |
| **QR Code Validation Success** | > 99.9% | Application logs |
| **Membership‚ÜíCard Sync** | < 1 second | Integration tests |
| **Audit Trail Completeness** | 100% of state changes | Database checks |
| **Replay Attack Prevention** | 0 successful replays | Security monitoring |
| **Queue Processing Errors** | < 0.1% | Queue failure rate |

---

## **üîß IMMEDIATE ACTIONS TO START PHASE 3**

### **Step 1: Create Domain Events**
```bash
# Create the event classes
mkdir -p app/Contexts/DigitalCard/Domain/Events
# Copy the DigitalCardEvents.php file
```

### **Step 2: Update Aggregate Root**
```bash
# Update DigitalCard.php with event publishing
# Add the recordThat() and releaseEvents() methods
```

### **Step 3: Implement ACL**
```bash
# Create MembershipEventSubscriber
mkdir -p app/Contexts/DigitalCard/Infrastructure/EventSubscribers
# Copy the MembershipEventSubscriber.php file
```

### **Step 4: Deploy Secure QR Generator**
```bash
# Replace SimpleQRCodeGenerator with SignedQRCodeGenerator
# Update service container bindings
```

### **Step 5: Run Migrations**
```bash
# Create audit tables
php artisan make:migration create_card_audit_tables --path=database/migrations/tenant
# Run migrations for all tenants
php artisan tenants:migrate
```

### **Step 6: Register Event Listeners**
```bash
# Register DigitalCardEventServiceProvider
# Add to config/app.php providers array
```

---

## **‚ö†Ô∏è ROLLBACK PLAN**

```bash
# If Phase 3 has issues, rollback to Phase 2:

# 1. Disable Phase 3 features
php artisan feature:disable digitalcard-signed-qr
php artisan feature:disable digitalcard-event-audit

# 2. Rollback migrations
php artisan tenants:migrate:rollback --step=1 --context=DigitalCard

# 3. Revert to simple QR generator
# Update DigitalCardServiceProvider to bind SimpleQRCodeGenerator

# 4. Disable event subscribers
# Comment out in DigitalCardEventServiceProvider

# 5. Clear caches
php artisan config:clear
php artisan event:clear
php artisan route:clear
```

---

**Phase 3 transforms your DigitalCardContext from a simple CRUD system to a resilient, event-driven bounded context with enterprise-grade security.** The ACL ensures integrity across contexts without creating hard dependencies, while signed QR codes provide military-grade security against replay attacks.

**Ready to deploy Phase 3?** Start with the events and ACL, then add the secure QR generator. The audit trail and projections will automatically build as the system runs.