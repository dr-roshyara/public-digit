# **DIGITALCARD CONTEXT - PHASE 2: MOBILE MEMBER EXPERIENCE**
**Detailed Implementation Plan for Senior Fullstack Developer & Solution Architect**

## **üìã PHASE 2 OVERVIEW: MOBILE-FIRST MEMBER EXPERIENCE**

**Duration**: Weeks 5-6 (Post Phase 1 Completion)
**Primary User**: Member via **Angular Mobile App** (`/mapi/*`)
**Secondary User**: Committee Members (Desktop backup)
**Goal**: Enable members to access and use their digital cards through the Angular mobile app with secure, tenant-scoped authentication and validation.

---

## **üõ†Ô∏è TECHNICAL STACK CONFIRMATION**

| Layer | Technology | Justification |
|-------|------------|---------------|
| **Backend API** | Laravel 12 + Sanctum | Stateless token auth for mobile |
| **Frontend (Mobile)** | Angular 17+ | Mobile app requirement |
| **Authentication** | Laravel Sanctum (API tokens) | Mobile stateless auth |
| **Routing** | Case 2: `/{tenant}/mapi/v1/*` | Mobile-specific API path |
| **State Management** | NgRx (Optional) or Services | Complex card state |
| **UI Framework** | Ionic/Angular Material | Mobile-optimized components |
| **Testing** | PestPHP (Backend) + Jasmine/Karma (Frontend) | Full-stack TDD |

---

## **üìä PHASE 2 DELIVERABLES MATRIX**

| Component | Backend (Laravel) | Frontend (Angular) | Tests | Priority |
|-----------|-------------------|--------------------|-------|----------|
| **Mobile Auth Integration** | Sanctum token issuance | Auth interceptor/service | Pest + Jasmine | P0 |
| **My Card Endpoint** | `GET /{tenant}/mapi/v1/my-card` | Card service + resolver | Pest Feature | P0 |
| **Card Validation** | `POST /{tenant}/mapi/v1/cards/validate` | Validation component | Pest Unit | P0 |
| **QR Scanner** | N/A | Camera integration | Jasmine E2E | P1 |
| **Offline Mode** | Bundle generation | Local storage + sync | Pest + Jasmine | P2 |
| **Push Notifications** | Event listeners | Firebase/Push API | Pest Integration | P2 |
| **Biometric Auth** | N/A | Local device auth | Jasmine | P3 |

---

## **üîß BACKEND IMPLEMENTATION DETAILS**

### **Week 5, Days 1-2: Mobile API Foundation & Sanctum Integration**

```php
<?php
// 1. MOBILE-SPECIFIC ROUTES (CASE 2)
// routes/tenant/mapi.digitalcard.php

declare(strict_types=1);

use App\Contexts\DigitalCard\Infrastructure\Http\Controllers\Mobile\MobileCardController;
use Illuminate\Support\Facades\Route;

Route::prefix('{tenant}/mapi/v1')
    ->middleware([
        'tenant.resolve',        // Tenant identification
        'auth:sanctum',          // Mobile token authentication
        'throttle:mobile-api',   // Mobile-specific rate limiting
        'active-member',         // Member must be active
    ])
    ->group(function () {
        
        // Member's own card (auto-resolved from token)
        Route::prefix('my-card')->group(function () {
            Route::get('/', [MobileCardController::class, 'getMyCard']);     // Get member's active card
            Route::post('/validate', [MobileCardController::class, 'validateMyCard']); // Self-validation
            Route::post('/refresh-qr', [MobileCardController::class, 'refreshQR']); // QR rotation
            Route::get('/history', [MobileCardController::class, 'getCardHistory']); // Previous cards
        });
        
        // Card operations (with explicit card ID)
        Route::prefix('cards')->group(function () {
            Route::post('/{card}/validate', [MobileCardController::class, 'validateCard']);
            Route::post('/{card}/check-in', [MobileCardController::class, 'checkIn']);
            Route::post('/batch-validate', [MobileCardController::class, 'batchValidate']);
        });
        
        // Offline support
        Route::prefix('offline')->group(function () {
            Route::get('/validation-bundle', [MobileCardController::class, 'getValidationBundle']);
            Route::post('/sync-events', [MobileCardController::class, 'syncOfflineEvents']);
        });
        
        // Notifications
        Route::get('/notifications', [MobileCardController::class, 'getNotifications']);
        Route::post('/notifications/{id}/read', [MobileCardController::class, 'markNotificationRead']);
    });

// 2. MOBILE-SPECIFIC CONTROLLER
<?php
// app/Contexts/DigitalCard/Infrastructure/Http/Controllers/Mobile/MobileCardController.php

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\Http\Controllers\Mobile;

use App\Contexts\DigitalCard\Application\Queries\GetMemberCardQuery;
use App\Contexts\DigitalCard\Application\Commands\ValidateCardCommand;
use App\Contexts\DigitalCard\Infrastructure\Http\Requests\Mobile\ValidateCardRequest;
use App\Contexts\DigitalCard\Infrastructure\Http\Resources\Mobile\MobileCardResource;
use App\Contexts\Membership\Domain\ValueObjects\MemberId;
use Illuminate\Http\JsonResponse;
use Illuminate\Routing\Controller;
use Illuminate\Support\Facades\Log;

final class MobileCardController extends Controller
{
    public function __construct(
        private GetMemberCardQuery $getMemberCardQuery,
        private ValidateCardCommand $validateCardCommand,
        private MemberResolver $memberResolver
    ) {
        // Mobile-specific middleware
        $this->middleware('member-context');
        $this->middleware('log-mobile-activity');
    }
    
    /**
     * Get the authenticated member's active card
     * Auto-resolves member from Sanctum token
     */
    public function getMyCard(): JsonResponse
    {
        try {
            // CRITICAL: Resolve member from token WITHOUT exposing user ID
            $memberId = $this->memberResolver->resolveFromAuth();
            
            $card = $this->getMemberCardQuery->execute($memberId);
            
            if (!$card) {
                return response()->json([
                    'message' => 'No active digital card found',
                    'action_required' => 'contact_committee'
                ], 404);
            }
            
            return response()->json([
                'data' => new MobileCardResource($card),
                'meta' => [
                    'last_updated' => now()->toISOString(),
                    'cache_ttl' => 300, // 5 minutes for mobile cache
                    'offline_supported' => true
                ]
            ]);
            
        } catch (\Exception $e) {
            Log::error('Mobile card fetch failed', [
                'member_id' => $memberId?->toString(),
                'error' => $e->getMessage()
            ]);
            
            return response()->json([
                'error' => 'Unable to retrieve card',
                'code' => 'CARD_FETCH_FAILED'
            ], 503);
        }
    }
    
    /**
     * Validate a card (for check-in scenarios)
     */
    public function validateCard(ValidateCardRequest $request, string $cardId): JsonResponse
    {
        try {
            $memberId = $this->memberResolver->resolveFromAuth();
            $validationContext = $request->toValidationContext();
            
            $result = $this->validateCardCommand->execute(
                cardId: $cardId,
                validatorMemberId: $memberId,
                context: $validationContext
            );
            
            // Log validation for audit trail
            Log::info('Card validated via mobile', [
                'card_id' => $cardId,
                'validator' => $memberId->toString(),
                'context' => $validationContext->toArray(),
                'success' => $result->isValid()
            ]);
            
            return response()->json([
                'valid' => $result->isValid(),
                'card' => $result->isValid() ? new MobileCardResource($result->getCard()) : null,
                'reason' => $result->getReason(),
                'timestamp' => now()->toISOString(),
                'validation_id' => $result->getValidationId()
            ]);
            
        } catch (\Exception $e) {
            return response()->json([
                'valid' => false,
                'reason' => 'validation_error',
                'error' => $e->getMessage()
            ], 400);
        }
    }
    
    /**
     * Generate offline validation bundle
     * Signed, time-limited package for offline validation
     */
    public function getValidationBundle(): JsonResponse
    {
        $memberId = $this->memberResolver->resolveFromAuth();
        
        $bundle = $this->offlineService->generateBundle(
            memberId: $memberId,
            ttl: now()->addHours(24) // 24-hour offline validity
        );
        
        return response()->json([
            'bundle' => $bundle->toArray(),
            'signature' => $bundle->getSignature(),
            'expires_at' => $bundle->getExpiry()->toISOString(),
            'instructions' => 'Store locally for offline validation'
        ]);
    }
}
```

### **Week 5, Days 3-4: Mobile-Specific Domain Logic & Security**

```php
<?php
// 3. MEMBER RESOLVER SERVICE (CRITICAL FOR TENANT ISOLATION)
// app/Contexts/DigitalCard/Infrastructure/Services/MemberResolver.php

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\Services;

use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use App\Contexts\Membership\Domain\Repositories\MemberRepository;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Cache;

/**
 * Resolves MemberId from Sanctum token with tenant isolation
 * This service is CRITICAL for mobile API security
 */
final class MemberResolver
{
    private const CACHE_TTL = 300; // 5 minutes
    private const CACHE_PREFIX = 'member_token:';
    
    public function __construct(
        private MemberRepository $memberRepository
    ) {}
    
    /**
     * Resolve MemberId from authenticated Sanctum token
     * Uses caching to reduce database calls
     */
    public function resolveFromAuth(): MemberId
    {
        $sanctumToken = Auth::guard('sanctum')->user();
        
        if (!$sanctumToken) {
            throw new \RuntimeException('No authenticated mobile user');
        }
        
        $cacheKey = self::CACHE_PREFIX . $sanctumToken->getKey();
        
        // Cache to prevent constant DB queries
        return Cache::remember($cacheKey, self::CACHE_TTL, function () use ($sanctumToken) {
            // Get user ID from token
            $userId = $sanctumToken->tokenable_id;
            
            // Convert to member - THIS IS TENANT-SCOPED
            $member = $this->memberRepository->findByUserId($userId);
            
            if (!$member) {
                throw new \DomainException('User is not associated with a member');
            }
            
            // Verify member belongs to current tenant
            $this->verifyTenantMembership($member);
            
            return $member->getId();
        });
    }
    
    /**
     * Security: Ensure member belongs to current tenant
     */
    private function verifyTenantMembership($member): void
    {
        $currentTenant = app('currentTenant');
        
        if ($member->getTenantId() !== $currentTenant->id) {
            Log::critical('Tenant mismatch in member resolution', [
                'member_tenant' => $member->getTenantId(),
                'current_tenant' => $currentTenant->id,
                'user_id' => Auth::id()
            ]);
            
            throw new \DomainException('Member does not belong to current tenant');
        }
    }
    
    /**
     * Clear cached member resolution (on logout/token refresh)
     */
    public function clearCache(string $tokenId): void
    {
        Cache::forget(self::CACHE_PREFIX . $tokenId);
    }
}

// 4. MOBILE-SPECIFIC VALIDATION SERVICE
<?php
// app/Contexts/DigitalCard/Domain/Services/MobileValidationService.php

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Domain\Services;

use App\Contexts\DigitalCard\Domain\Entities\DigitalCard;
use App\Contexts\DigitalCard\Domain\ValueObjects\CardId;
use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use App\Contexts\DigitalCard\Domain\ValueObjects\ValidationContext;

/**
 * Mobile-specific validation with additional checks:
 * - Rate limiting
 * - Geographic validation
 * - Time-based restrictions
 */
final class MobileValidationService
{
    public function __construct(
        private CardValidationService $baseValidator,
        private ValidationRateLimiter $rateLimiter,
        private GeoValidationService $geoValidator
    ) {}
    
    public function validateForMobile(
        CardId $cardId,
        MemberId $validatorMemberId,
        ValidationContext $context
    ): ValidationResult {
        // 1. Rate limit validation attempts
        $this->rateLimiter->attempt($validatorMemberId);
        
        // 2. Perform geographic validation if location provided
        if ($context->hasLocation()) {
            $this->geoValidator->validateLocation(
                $context->getLocation(),
                $validatorMemberId
            );
        }
        
        // 3. Base validation
        $result = $this->baseValidator->validate($cardId);
        
        // 4. Mobile-specific success criteria
        if ($result->isValid()) {
            $card = $result->getCard();
            
            // Additional mobile checks
            if (!$this->isValidForMobileUse($card)) {
                return ValidationResult::invalid(
                    'card_not_valid_for_mobile_use',
                    'This card cannot be used via mobile app'
                );
            }
            
            // Check time restrictions
            if (!$this->isWithinAllowedHours($card, $context->getTimestamp())) {
                return ValidationResult::invalid(
                    'outside_allowed_hours',
                    'Card use not permitted at this time'
                );
            }
        }
        
        return $result;
    }
    
    private function isValidForMobileUse(DigitalCard $card): bool
    {
        // Business rule: Some cards may be physical-only
        return $card->allowsMobileUse();
    }
    
    private function isWithinAllowedHours(DigitalCard $card, \DateTimeImmutable $time): bool
    {
        // Check against card's usage restrictions
        $restrictions = $card->getUsageRestrictions();
        
        if (!$restrictions->hasTimeRestrictions()) {
            return true;
        }
        
        return $restrictions->isTimeAllowed($time);
    }
}
```

---

## **üé® FRONTEND IMPLEMENTATION (ANGULAR 17+)**

### **Week 6, Days 1-2: Mobile App Architecture & Core Services**

```typescript
// 1. CARD SERVICE WITH TENANT CONTEXT
// src/app/core/services/digital-card.service.ts

import { Injectable, Inject, PLATFORM_ID } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { Observable, BehaviorSubject, from, throwError } from 'rxjs';
import { map, tap, catchError, switchMap } from 'rxjs/operators';
import { isPlatformBrowser } from '@angular/common';
import { AuthService } from './auth.service';
import { TenantService } from './tenant.service';

export interface MobileCard {
  id: string;
  member_id: string;
  status: 'issued' | 'active' | 'revoked' | 'expired';
  qr_code: string;
  issued_at: string;
  expires_at: string;
  activated_at?: string;
  revoked_at?: string;
  revocation_reason?: string;
  meta?: {
    can_refresh_qr: boolean;
    offline_supported: boolean;
    last_validation?: string;
  };
}

export interface ValidationResult {
  valid: boolean;
  card?: MobileCard;
  reason?: string;
  timestamp: string;
  validation_id: string;
}

@Injectable({
  providedIn: 'root'
})
export class DigitalCardService {
  private readonly API_PREFIX = '/mapi/v1';
  private currentCard = new BehaviorSubject<MobileCard | null>(null);
  private offlineCacheKey = 'digital_card_offline_cache';
  
  constructor(
    private http: HttpClient,
    private authService: AuthService,
    private tenantService: TenantService,
    @Inject(PLATFORM_ID) private platformId: Object
  ) {
    this.initializeOfflineSupport();
  }
  
  /**
   * Get current member's card with automatic tenant context
   */
  getMyCard(refresh: boolean = false): Observable<MobileCard> {
    // Get current tenant from service
    const tenantSlug = this.tenantService.getCurrentTenant();
    
    if (!tenantSlug) {
      return throwError(() => new Error('No tenant selected'));
    }
    
    // Check cache first (unless forced refresh)
    if (!refresh && this.currentCard.value) {
      return this.currentCard.asObservable() as Observable<MobileCard>;
    }
    
    const url = `/${tenantSlug}${this.API_PREFIX}/my-card`;
    const headers = this.getAuthHeaders();
    
    return this.http.get<{ data: MobileCard }>(url, { headers }).pipe(
      map(response => response.data),
      tap(card => {
        this.currentCard.next(card);
        this.cacheForOffline(card);
      }),
      catchError(error => {
        // Fallback to offline cache
        const cached = this.getOfflineCache();
        if (cached) {
          this.currentCard.next(cached);
          return from([cached]);
        }
        return throwError(() => error);
      })
    );
  }
  
  /**
   * Validate a card (for check-in)
   */
  validateCard(cardId: string, context?: any): Observable<ValidationResult> {
    const tenantSlug = this.tenantService.getCurrentTenant();
    const url = `/${tenantSlug}${this.API_PREFIX}/cards/${cardId}/validate`;
    const headers = this.getAuthHeaders();
    
    const payload = {
      timestamp: new Date().toISOString(),
      location: context?.location,
      device_id: this.getDeviceId(),
      scan_method: context?.method || 'manual'
    };
    
    return this.http.post<ValidationResult>(url, payload, { headers }).pipe(
      tap(result => {
        if (result.valid && result.card) {
          // Update local cache if validation succeeded
          this.currentCard.next(result.card);
        }
        this.logValidation(result);
      })
    );
  }
  
  /**
   * Refresh QR code (rotation for security)
   */
  refreshQRCode(): Observable<MobileCard> {
    const tenantSlug = this.tenantService.getCurrentTenant();
    const url = `/${tenantSlug}${this.API_PREFIX}/my-card/refresh-qr`;
    const headers = this.getAuthHeaders();
    
    return this.http.post<{ data: MobileCard }>(url, {}, { headers }).pipe(
      map(response => response.data),
      tap(card => this.currentCard.next(card))
    );
  }
  
  /**
   * Get offline validation bundle
   */
  getOfflineBundle(): Observable<any> {
    const tenantSlug = this.tenantService.getCurrentTenant();
    const url = `/${tenantSlug}${this.API_PREFIX}/offline/validation-bundle`;
    const headers = this.getAuthHeaders();
    
    return this.http.get(url, { headers }).pipe(
      tap(bundle => {
        if (isPlatformBrowser(this.platformId)) {
          localStorage.setItem(
            `${this.offlineCacheKey}_${tenantSlug}`,
            JSON.stringify(bundle)
          );
        }
      })
    );
  }
  
  /**
   * Get card history
   */
  getCardHistory(): Observable<MobileCard[]> {
    const tenantSlug = this.tenantService.getCurrentTenant();
    const url = `/${tenantSlug}${this.API_PREFIX}/my-card/history`;
    const headers = this.getAuthHeaders();
    
    return this.http.get<{ data: MobileCard[] }>(url, { headers }).pipe(
      map(response => response.data)
    );
  }
  
  /**
   * Watch card updates
   */
  watchCard(): Observable<MobileCard | null> {
    return this.currentCard.asObservable();
  }
  
  /**
   * Force clear cache
   */
  clearCache(): void {
    this.currentCard.next(null);
    if (isPlatformBrowser(this.platformId)) {
      localStorage.removeItem(this.offlineCacheKey);
    }
  }
  
  // Private helpers
  private getAuthHeaders(): HttpHeaders {
    const token = this.authService.getToken();
    return new HttpHeaders({
      'Authorization': `Bearer ${token}`,
      'X-Device-ID': this.getDeviceId(),
      'X-App-Version': this.getAppVersion(),
      'Accept': 'application/json'
    });
  }
  
  private getDeviceId(): string {
    // Generate or retrieve device identifier
    if (isPlatformBrowser(this.platformId)) {
      let deviceId = localStorage.getItem('device_id');
      if (!deviceId) {
        deviceId = 'web_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('device_id', deviceId);
      }
      return deviceId;
    }
    return 'server';
  }
  
  private getAppVersion(): string {
    return '1.0.0'; // Should come from environment
  }
  
  private cacheForOffline(card: MobileCard): void {
    if (isPlatformBrowser(this.platformId)) {
      const cache = {
        card,
        cached_at: new Date().toISOString(),
        ttl: 300000 // 5 minutes
      };
      localStorage.setItem(this.offlineCacheKey, JSON.stringify(cache));
    }
  }
  
  private getOfflineCache(): MobileCard | null {
    if (isPlatformBrowser(this.platformId)) {
      const cached = localStorage.getItem(this.offlineCacheKey);
      if (cached) {
        const { card, cached_at, ttl } = JSON.parse(cached);
        const expiry = new Date(cached_at).getTime() + ttl;
        if (Date.now() < expiry) {
          return card;
        }
      }
    }
    return null;
  }
  
  private initializeOfflineSupport(): void {
    if (isPlatformBrowser(this.platformId)) {
      // Listen for online/offline events
      window.addEventListener('online', () => this.syncOfflineEvents());
      window.addEventListener('offline', () => {
        console.log('App offline, using cached card data');
      });
    }
  }
  
  private syncOfflineEvents(): void {
    // Sync any offline validation events when coming online
    const events = this.getPendingOfflineEvents();
    if (events.length > 0) {
      this.syncEventsToServer(events);
    }
  }
  
  private logValidation(result: ValidationResult): void {
    // Analytics/logging
    console.log('Card validation:', result);
  }
}
```

```typescript
// 2. AUTH INTERCEPTOR WITH TENANT HANDLING
// src/app/core/interceptors/auth.interceptor.ts

import { Injectable } from '@angular/core';
import {
  HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpErrorResponse
} from '@angular/common/http';
import { Observable, throwError, BehaviorSubject } from 'rxjs';
import { catchError, switchMap, filter, take } from 'rxjs/operators';
import { Router } from '@angular/router';
import { AuthService } from '../services/auth.service';
import { TenantService } from '../services/tenant.service';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  private isRefreshing = false;
  private refreshTokenSubject = new BehaviorSubject<string | null>(null);
  
  constructor(
    private authService: AuthService,
    private tenantService: TenantService,
    private router: Router
  ) {}
  
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Clone request and add auth header
    const authReq = this.addAuthHeader(req);
    
    return next.handle(authReq).pipe(
      catchError((error: HttpErrorResponse) => {
        // Handle 401 Unauthorized (token expired)
        if (error.status === 401 && !req.url.includes('/auth/')) {
          return this.handle401Error(authReq, next);
        }
        
        // Handle 403 Forbidden (tenant access issue)
        if (error.status === 403) {
          this.handle403Error(error);
          return throwError(() => error);
        }
        
        // Handle 404 Not Found (tenant-specific resource not found)
        if (error.status === 404 && this.isTenantResource(req.url)) {
          this.handle404Error(error, req.url);
          return throwError(() => error);
        }
        
        return throwError(() => error);
      })
    );
  }
  
  private addAuthHeader(req: HttpRequest<any>): HttpRequest<any> {
    // Don't add auth header to login/tenant selection
    if (req.url.includes('/auth/login') || req.url.includes('/tenants')) {
      return req;
    }
    
    const token = this.authService.getToken();
    const tenantSlug = this.tenantService.getCurrentTenant();
    
    let headers = req.headers;
    
    if (token) {
      headers = headers.set('Authorization', `Bearer ${token}`);
    }
    
    // Add tenant context for API calls (except platform endpoints)
    if (tenantSlug && !req.url.startsWith('/mapi/')) {
      // Already has tenant in URL for Case 2
    }
    
    // Add device info for mobile tracking
    headers = headers.set('X-Device-ID', this.getDeviceId());
    headers = headers.set('X-App-Version', '1.0.0');
    
    return req.clone({ headers });
  }
  
  private handle401Error(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    if (!this.isRefreshing) {
      this.isRefreshing = true;
      this.refreshTokenSubject.next(null);
      
      return this.authService.refreshToken().pipe(
        switchMap((newToken: string) => {
          this.isRefreshing = false;
          this.refreshTokenSubject.next(newToken);
          return next.handle(this.addAuthHeader(req));
        }),
        catchError((error) => {
          this.isRefreshing = false;
          this.authService.logout();
          this.router.navigate(['/login']);
          return throwError(() => error);
        })
      );
    } else {
      return this.refreshTokenSubject.pipe(
        filter(token => token !== null),
        take(1),
        switchMap(() => next.handle(this.addAuthHeader(req)))
      );
    }
  }
  
  private handle403Error(error: HttpErrorResponse): void {
    console.error('Access forbidden:', error);
    
    // Check if it's a tenant access issue
    if (error.error?.code === 'TENANT_ACCESS_DENIED') {
      this.tenantService.clearTenant();
      this.router.navigate(['/tenant-select']);
    }
  }
  
  private handle404Error(error: HttpErrorResponse, url: string): void {
    // If card not found in tenant, might need to refresh
    if (url.includes('/my-card')) {
      console.log('Card not found, might need to issue new card');
    }
  }
  
  private isTenantResource(url: string): boolean {
    return url.includes('/mapi/v1/') || url.includes('/api/v1/');
  }
  
  private getDeviceId(): string {
    // Get or create device ID
    if (typeof window !== 'undefined' && window.localStorage) {
      let deviceId = localStorage.getItem('device_id');
      if (!deviceId) {
        deviceId = 'mobile_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('device_id', deviceId);
      }
      return deviceId;
    }
    return 'unknown';
  }
}
```

### **Week 6, Days 3-4: Mobile UI Components & QR Integration**

```typescript
// 3. CARD DISPLAY COMPONENT WITH QR
// src/app/features/digital-card/components/card-display/card-display.component.ts

import { Component, OnInit, OnDestroy, ViewChild, ElementRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { IonicModule } from '@ionic/angular';
import { Subscription } from 'rxjs';
import { DigitalCardService, MobileCard } from '../../../core/services/digital-card.service';
import { QRCodeModule } from 'angularx-qrcode';
import { AuthService } from '../../../core/services/auth.service';

@Component({
  selector: 'app-card-display',
  templateUrl: './card-display.component.html',
  styleUrls: ['./card-display.component.scss'],
  standalone: true,
  imports: [CommonModule, IonicModule, QRCodeModule]
})
export class CardDisplayComponent implements OnInit, OnDestroy {
  @ViewChild('qrCanvas', { static: false }) qrCanvas!: ElementRef<HTMLCanvasElement>;
  
  card: MobileCard | null = null;
  isLoading = true;
  error: string | null = null;
  isRefreshing = false;
  lastUpdated: Date | null = null;
  
  private cardSubscription!: Subscription;
  private refreshInterval: any;
  
  // QR Code configuration
  qrConfig = {
    width: 256,
    margin: 2,
    colorDark: '#000000',
    colorLight: '#FFFFFF',
    level: 'M' as 'L' | 'M' | 'Q' | 'H'
  };
  
  constructor(
    private cardService: DigitalCardService,
    private authService: AuthService
  ) {}
  
  ngOnInit(): void {
    this.loadCard();
    
    // Set up auto-refresh every 5 minutes
    this.refreshInterval = setInterval(() => {
      if (this.card?.status === 'active') {
        this.refreshCardData();
      }
    }, 300000);
    
    // Subscribe to card updates
    this.cardSubscription = this.cardService.watchCard()
      .subscribe(card => {
        this.card = card;
        this.lastUpdated = new Date();
      });
  }
  
  ngOnDestroy(): void {
    if (this.cardSubscription) {
      this.cardSubscription.unsubscribe();
    }
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
  }
  
  loadCard(forceRefresh = false): void {
    this.isLoading = true;
    this.error = null;
    
    this.cardService.getMyCard(forceRefresh).subscribe({
      next: (card) => {
        this.card = card;
        this.isLoading = false;
        this.lastUpdated = new Date();
      },
      error: (err) => {
        this.error = this.getErrorMessage(err);
        this.isLoading = false;
        console.error('Failed to load card:', err);
      }
    });
  }
  
  refreshCardData(): void {
    if (this.isRefreshing) return;
    
    this.isRefreshing = true;
    this.cardService.getMyCard(true).subscribe({
      next: (card) => {
        this.card = card;
        this.isRefreshing = false;
        this.lastUpdated = new Date();
      },
      error: () => {
        this.isRefreshing = false;
      }
    });
  }
  
  refreshQRCode(): void {
    this.cardService.refreshQRCode().subscribe({
      next: (card) => {
        this.card = card;
        // Show success message
      },
      error: (err) => {
        console.error('Failed to refresh QR:', err);
      }
    });
  }
  
  shareCard(): void {
    if (!this.card) return;
    
    // Implement sharing logic
    if (navigator.share) {
      navigator.share({
        title: 'My Digital Membership Card',
        text: `Digital card for ${this.authService.getMemberName()}`,
        url: this.generateCardShareUrl()
      });
    } else {
      // Fallback: copy to clipboard
      this.copyToClipboard(this.card.id);
    }
  }
  
  downloadQRCode(): void {
    if (!this.card) return;
    
    const canvas = this.qrCanvas.nativeElement;
    const link = document.createElement('a');
    link.download = `card-${this.card.id.slice(0, 8)}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  }
  
  getStatusColor(): string {
    if (!this.card) return 'medium';
    
    switch (this.card.status) {
      case 'active': return 'success';
      case 'issued': return 'warning';
      case 'revoked': return 'danger';
      case 'expired': return 'medium';
      default: return 'medium';
    }
  }
  
  getStatusText(): string {
    if (!this.card) return '';
    
    const statusMap: Record<string, string> = {
      'active': 'Active',
      'issued': 'Issued (Not Active)',
      'revoked': 'Revoked',
      'expired': 'Expired'
    };
    
    return statusMap[this.card.status] || this.card.status;
  }
  
  isCardValid(): boolean {
    return this.card?.status === 'active';
  }
  
  canRefreshQR(): boolean {
    return this.card?.meta?.can_refresh_qr || false;
  }
  
  formatDate(dateString: string): string {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  }
  
  private getErrorMessage(error: any): string {
    if (error.status === 404) {
      return 'No digital card found. Please contact your committee administrator.';
    }
    if (error.status === 403) {
      return 'Access denied. Please log in again.';
    }
    if (error.status === 0) {
      return 'Network error. Please check your connection.';
    }
    return 'Failed to load card. Please try again.';
  }
  
  private generateCardShareUrl(): string {
    // Generate a secure, time-limited share URL
    const token = this.authService.getToken();
    return `${window.location.origin}/share/card/${this.card?.id}?token=${token}`;
  }
  
  private copyToClipboard(text: string): void {
    navigator.clipboard.writeText(text).then(() => {
      // Show success toast
    });
  }
}
```

```html
<!-- 4. CARD DISPLAY TEMPLATE -->
<!-- src/app/features/digital-card/components/card-display/card-display.component.html -->

<ion-content>
  <!-- Loading State -->
  <div *ngIf="isLoading" class="ion-padding ion-text-center">
    <ion-spinner></ion-spinner>
    <p>Loading your digital card...</p>
  </div>
  
  <!-- Error State -->
  <div *ngIf="error && !isLoading" class="ion-padding ion-text-center">
    <ion-icon name="warning-outline" size="large" color="danger"></ion-icon>
    <h2>Unable to Load Card</h2>
    <p>{{ error }}</p>
    <ion-button (click)="loadCard(true)" expand="block">
      <ion-icon name="refresh" slot="start"></ion-icon>
      Try Again
    </ion-button>
  </div>
  
  <!-- Card Display -->
  <div *ngIf="card && !isLoading" class="card-container">
    
    <!-- Card Header -->
    <div class="card-header ion-padding">
      <div class="header-content">
        <div>
          <h1>Digital Membership Card</h1>
          <p class="card-subtitle">
            <ion-badge [color]="getStatusColor()">
              {{ getStatusText() }}
            </ion-badge>
            <span *ngIf="lastUpdated" class="last-updated">
              Updated: {{ lastUpdated | date:'shortTime' }}
            </span>
          </p>
        </div>
        <div class="header-actions">
          <ion-button fill="clear" (click)="refreshCardData()" [disabled]="isRefreshing">
            <ion-icon name="refresh" slot="icon-only"></ion-icon>
          </ion-button>
        </div>
      </div>
    </div>
    
    <!-- QR Code Display -->
    <div class="qr-section ion-padding">
      <div class="qr-container" *ngIf="isCardValid()">
        <qrcode [qrdata]="card.qr_code" 
                [width]="qrConfig.width"
                [margin]="qrConfig.margin"
                [colorDark]="qrConfig.colorDark"
                [colorLight]="qrConfig.colorLight"
                [level]="qrConfig.level">
        </qrcode>
        
        <div class="qr-actions ion-margin-top">
          <ion-button size="small" (click)="downloadQRCode()">
            <ion-icon name="download" slot="start"></ion-icon>
            Save
          </ion-button>
          
          <ion-button size="small" (click)="refreshQRCode()" *ngIf="canRefreshQR()">
            <ion-icon name="refresh-circle" slot="start"></ion-icon>
            Refresh QR
          </ion-button>
          
          <ion-button size="small" (click)="shareCard()">
            <ion-icon name="share" slot="start"></ion-icon>
            Share
          </ion-button>
        </div>
      </div>
      
      <div *ngIf="!isCardValid()" class="card-invalid ion-text-center">
        <ion-icon name="close-circle" size="large" color="warning"></ion-icon>
        <h3>Card Not Active</h3>
        <p>This card cannot be used for validation.</p>
        <p *ngIf="card.revoked_at" class="revocation-reason">
          Reason: {{ card.revocation_reason || 'Not specified' }}
        </p>
      </div>
    </div>
    
    <!-- Card Details -->
    <ion-list lines="full" class="card-details">
      <ion-item>
        <ion-label position="stacked">Card ID</ion-label>
        <p class="card-id">{{ card.id }}</p>
        <ion-button slot="end" fill="clear" size="small" (click)="copyToClipboard(card.id)">
          <ion-icon name="copy" slot="icon-only"></ion-icon>
        </ion-button>
      </ion-item>
      
      <ion-item>
        <ion-label position="stacked">Issued On</ion-label>
        <p>{{ formatDate(card.issued_at) }}</p>
      </ion-item>
      
      <ion-item>
        <ion-label position="stacked">Expires On</ion-label>
        <p>{{ formatDate(card.expires_at) }}</p>
      </ion-item>
      
      <ion-item *ngIf="card.activated_at">
        <ion-label position="stacked">Activated On</ion-label>
        <p>{{ formatDate(card.activated_at) }}</p>
      </ion-item>
      
      <ion-item *ngIf="card.revoked_at">
        <ion-label position="stacked">Revoked On</ion-label>
        <p>{{ formatDate(card.revoked_at) }}</p>
      </ion-item>
    </ion-list>
    
    <!-- Validation Section -->
    <div class="validation-section ion-padding" *ngIf="isCardValid()">
      <h3>Validate This Card</h3>
      <p class="ion-text-center">Show this QR code to a committee member for validation</p>
      
      <div class="validation-actions">
        <ion-button expand="block" color="primary" routerLink="/validate">
          <ion-icon name="scan" slot="start"></ion-icon>
          Scan for Validation
        </ion-button>
        
        <ion-button expand="block" fill="outline" routerLink="/validation-history">
          <ion-icon name="time" slot="start"></ion-icon>
          View Validation History
        </ion-button>
      </div>
    </div>
    
    <!-- Offline Support -->
    <div class="offline-section ion-padding" *ngIf="card.meta?.offline_supported">
      <ion-item lines="none">
        <ion-icon name="cloud-offline" slot="start" color="medium"></ion-icon>
        <ion-label>
          <h3>Offline Mode Available</h3>
          <p>Download validation bundle for offline use</p>
        </ion-label>
        <ion-button slot="end" size="small" (click)="downloadOfflineBundle()">
          Download
        </ion-button>
      </ion-item>
    </div>
  </div>
</ion-content>
```

### **Week 6, Days 5: QR Scanner & Validation Component**

```typescript
// 5. QR SCANNER COMPONENT
// src/app/features/validation/components/qr-scanner/qr-scanner.component.ts

import { Component, OnInit, OnDestroy, ViewChild, ElementRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { IonicModule, Platform } from '@ionic/angular';
import { BarcodeScanner } from '@capacitor-community/barcode-scanner';
import { DigitalCardService, ValidationResult } from '../../../core/services/digital-card.service';
import { Router } from '@angular/router';

@Component({
  selector: 'app-qr-scanner',
  templateUrl: './qr-scanner.component.html',
  styleUrls: ['./qr-scanner.component.scss'],
  standalone: true,
  imports: [CommonModule, IonicModule]
})
export class QrScannerComponent implements OnInit, OnDestroy {
  @ViewChild('scannerContainer', { static: false }) scannerContainer!: ElementRef;
  
  isScanning = false;
  scanResult: string | null = null;
  validationResult: ValidationResult | null = null;
  isValidating = false;
  showManualEntry = false;
  manualCode = '';
  
  // Camera permissions
  hasPermission: boolean | null = null;
  isCapacitor = false;
  
  constructor(
    private platform: Platform,
    private cardService: DigitalCardService,
    private router: Router
  ) {
    this.isCapacitor = this.platform.is('capacitor');
  }
  
  async ngOnInit(): Promise<void> {
    await this.checkPermissions();
  }
  
  ngOnDestroy(): void {
    this.stopScan();
  }
  
  async checkPermissions(): Promise<void> {
    if (this.isCapacitor) {
      const status = await BarcodeScanner.checkPermission({ force: true });
      this.hasPermission = status.granted;
    } else {
      // Web permissions
      this.hasPermission = true;
    }
  }
  
  async startScan(): Promise<void> {
    if (!this.hasPermission) {
      await this.checkPermissions();
      return;
    }
    
    this.isScanning = true;
    this.scanResult = null;
    this.validationResult = null;
    
    if (this.isCapacitor) {
      // Native scanning
      await this.startNativeScan();
    } else {
      // Web scanning (using HTML5 QR scanner)
      this.startWebScan();
    }
  }
  
  async startNativeScan(): Promise<void> {
    try {
      // Hide background for better scanning
      document.querySelector('body')?.classList.add('scanner-active');
      
      await BarcodeScanner.hideBackground();
      
      const result = await BarcodeScanner.startScan();
      
      if (result.hasContent) {
        this.handleScanResult(result.content);
      }
      
    } catch (error) {
      console.error('Scan error:', error);
      this.stopScan();
    }
  }
  
  startWebScan(): void {
    // For web, you'd use a library like jsQR or Instascan
    // This is a simplified version
    const video = document.createElement('video');
    const canvasElement = document.createElement('canvas');
    const canvas = canvasElement.getContext('2d');
    
    // Set up video stream
    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
      .then(stream => {
        video.srcObject = stream;
        video.setAttribute('playsinline', 'true');
        video.play();
        
        // Add to container
        this.scannerContainer.nativeElement.appendChild(video);
        
        // Start scanning loop
        requestAnimationFrame(() => this.scanWebFrame(video, canvas));
      })
      .catch(err => {
        console.error('Camera error:', err);
        this.stopScan();
      });
  }
  
  scanWebFrame(video: HTMLVideoElement, canvas: CanvasRenderingContext2D | null): void {
    if (!this.isScanning || !canvas) return;
    
    // Draw video frame to canvas
    canvas.drawImage(video, 0, 0, 300, 300);
    
    // Get image data and scan for QR
    const imageData = canvas.getImageData(0, 0, 300, 300);
    // Use jsQR library here in real implementation
    
    // Continue scanning
    requestAnimationFrame(() => this.scanWebFrame(video, canvas));
  }
  
  handleScanResult(content: string): void {
    this.scanResult = content;
    this.stopScan();
    this.validateScannedCode(content);
  }
  
  validateScannedCode(code: string): void {
    this.isValidating = true;
    
    // Extract card ID from QR code
    const cardId = this.extractCardId(code);
    
    if (!cardId) {
      this.validationResult = {
        valid: false,
        reason: 'invalid_qr_format',
        timestamp: new Date().toISOString(),
        validation_id: 'invalid'
      };
      this.isValidating = false;
      return;
    }
    
    this.cardService.validateCard(cardId, {
      location: this.getCurrentLocation(),
      method: 'qr_scan'
    }).subscribe({
      next: (result) => {
        this.validationResult = result;
        this.isValidating = false;
        
        // Navigate to result page
        if (result.valid) {
          setTimeout(() => {
            this.router.navigate(['/validation-result', result.validation_id]);
          }, 1500);
        }
      },
      error: (error) => {
        this.validationResult = {
          valid: false,
          reason: 'validation_error',
          timestamp: new Date().toISOString(),
          validation_id: 'error'
        };
        this.isValidating = false;
        console.error('Validation error:', error);
      }
    });
  }
  
  stopScan(): void {
    this.isScanning = false;
    
    if (this.isCapacitor) {
      BarcodeScanner.stopScan();
      document.querySelector('body')?.classList.remove('scanner-active');
    } else {
      // Stop web camera
      const video = this.scannerContainer.nativeElement.querySelector('video');
      if (video) {
        const stream = video.srcObject as MediaStream;
        stream.getTracks().forEach(track => track.stop());
        video.remove();
      }
    }
  }
  
  toggleManualEntry(): void {
    this.showManualEntry = !this.showManualEntry;
    if (this.showManualEntry) {
      this.stopScan();
    }
  }
  
  validateManualCode(): void {
    if (!this.manualCode.trim()) return;
    this.handleScanResult(this.manualCode.trim());
  }
  
  private extractCardId(qrContent: string): string | null {
    // Parse QR content based on your format
    // Example format: "card:550e8400-e29b-41d4-a716-446655440000"
    const match = qrContent.match(/card:([a-f0-9-]{36})/i);
    return match ? match[1] : null;
  }
  
  private getCurrentLocation(): { lat: number, lng: number } | null {
    // Get current geolocation if available
    if (navigator.geolocation) {
      // In real app, you'd get actual location
      return { lat: 0, lng: 0 };
    }
    return null;
  }
}
```

---

## **üß™ TESTING STRATEGY FOR PHASE 2**

### **Backend Tests (PestPHP)**

```php
<?php
// tests/Feature/Contexts/DigitalCard/Mobile/MobileCardAccessTest.php

declare(strict_types=1);

namespace Tests\Feature\Contexts\DigitalCard\Mobile;

use App\Contexts\DigitalCard\Domain\ValueObjects\CardId;
use App\Contexts\Membership\Domain\ValueObjects\MemberId;
use Illuminate\Support\Facades\Notification;
use Tests\TestCase;

class MobileCardAccessTest extends TestCase
{
    /** @test */
    public function member_can_access_own_card_via_mobile_api(): void
    {
        // Given: A member with an active digital card
        $tenant = $this->createTestTenant();
        $member = $this->createMemberForTenant($tenant);
        $card = $this->issueDigitalCardForMember($member);
        
        // And: Mobile Sanctum token for the member
        $token = $this->createMobileTokenForMember($member);
        
        // When: Accessing the mobile API with correct tenant
        $response = $this->withToken($token)
            ->getJson("/{$tenant->slug}/mapi/v1/my-card");
        
        // Then: Should receive the card data
        $response->assertOk();
        $response->assertJsonStructure([
            'data' => [
                'id', 'status', 'qr_code', 'issued_at', 'expires_at'
            ]
        ]);
        
        // And: Should NOT expose sensitive admin fields
        $response->assertJsonMissing(['revocation_reason']);
    }
    
    /** @test */
    public function member_cannot_access_other_members_card(): void
    {
        $tenant = $this->createTestTenant();
        
        // Two different members
        $memberA = $this->createMemberForTenant($tenant);
        $memberB = $this->createMemberForTenant($tenant);
        
        $cardA = $this->issueDigitalCardForMember($memberA);
        $tokenB = $this->createMobileTokenForMember($memberB);
        
        // Member B tries to access Member A's card by ID
        $response = $this->withToken($tokenB)
            ->getJson("/{$tenant->slug}/mapi/v1/cards/{$cardA->id}");
        
        $response->assertForbidden();
    }
    
    /** @test */
    public function mobile_validation_logs_are_created(): void
    {
        $tenant = $this->createTestTenant();
        $member = $this->createMemberForTenant($tenant);
        $card = $this->issueDigitalCardForMember($member);
        $token = $this->createMobileTokenForMember($member);
        
        $response = $this->withToken($token)
            ->postJson("/{$tenant->slug}/mapi/v1/cards/{$card->id}/validate", [
                'location' => ['lat' => 51.5074, 'lng' => -0.1278],
                'device_id' => 'test-device-123'
            ]);
        
        $response->assertOk();
        
        // Check validation was logged
        $this->assertDatabaseHas('card_validations', [
            'card_id' => $card->id,
            'validator_member_id' => $member->id,
            'success' => true
        ]);
    }
    
    /** @test */
    public function offline_bundle_is_signed_and_time_limited(): void
    {
        $tenant = $this->createTestTenant();
        $member = $this->createMemberForTenant($tenant);
        $token = $this->createMobileTokenForMember($member);
        
        $response = $this->withToken($token)
            ->getJson("/{$tenant->slug}/mapi/v1/offline/validation-bundle");
        
        $response->assertOk();
        
        $bundle = $response->json();
        
        // Bundle should have signature
        $this->assertArrayHasKey('signature', $bundle);
        
        // Bundle should have expiry
        $this->assertArrayHasKey('expires_at', $bundle);
        
        // Signature should be valid
        $isValid = $this->verifyBundleSignature(
            $bundle['bundle'],
            $bundle['signature']
        );
        
        $this->assertTrue($isValid, 'Bundle signature should be valid');
    }
}
```

### **Frontend Tests (Jasmine/Karma)**

```typescript
// src/app/core/services/digital-card.service.spec.ts

import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
import { DigitalCardService } from './digital-card.service';
import { AuthService } from './auth.service';
import { TenantService } from './tenant.service';

describe('DigitalCardService', () => {
  let service: DigitalCardService;
  let httpMock: HttpTestingController;
  let authServiceMock: jasmine.SpyObj<AuthService>;
  let tenantServiceMock: jasmine.SpyObj<TenantService>;
  
  beforeEach(() => {
    authServiceMock = jasmine.createSpyObj('AuthService', ['getToken']);
    tenantServiceMock = jasmine.createSpyObj('TenantService', ['getCurrentTenant']);
    
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [
        DigitalCardService,
        { provide: AuthService, useValue: authServiceMock },
        { provide: TenantService, useValue: tenantServiceMock }
      ]
    });
    
    service = TestBed.inject(DigitalCardService);
    httpMock = TestBed.inject(HttpTestingController);
  });
  
  afterEach(() => {
    httpMock.verify();
  });
  
  it('should be created', () => {
    expect(service).toBeTruthy();
  });
  
  it('should get my card with correct tenant context', () => {
    const mockToken = 'test-token-123';
    const mockTenant = 'test-tenant';
    const mockCard = {
      id: '550e8400-e29b-41d4-a716-446655440000',
      status: 'active',
      qr_code: 'qr:test:data'
    };
    
    authServiceMock.getToken.and.returnValue(mockToken);
    tenantServiceMock.getCurrentTenant.and.returnValue(mockTenant);
    
    service.getMyCard().subscribe(card => {
      expect(card).toEqual(mockCard);
    });
    
    const req = httpMock.expectOne(`/${mockTenant}/mapi/v1/my-card`);
    expect(req.request.method).toBe('GET');
    expect(req.request.headers.get('Authorization')).toBe(`Bearer ${mockToken}`);
    
    req.flush({ data: mockCard });
  });
  
  it('should handle 404 when no card exists', () => {
    authServiceMock.getToken.and.returnValue('token');
    tenantServiceMock.getCurrentTenant.and.returnValue('tenant');
    
    service.getMyCard().subscribe({
      next: () => fail('Should have failed'),
      error: (error) => {
        expect(error.status).toBe(404);
      }
    });
    
    const req = httpMock.expectOne('/tenant/mapi/v1/my-card');
    req.flush('Not found', { status: 404, statusText: 'Not Found' });
  });
  
  it('should validate card with context', () => {
    const mockResult = {
      valid: true,
      timestamp: new Date().toISOString(),
      validation_id: 'val-123'
    };
    
    authServiceMock.getToken.and.returnValue('token');
    tenantServiceMock.getCurrentTenant.and.returnValue('tenant');
    
    const cardId = 'test-card-id';
    const context = { location: { lat: 51.5, lng: -0.1 } };
    
    service.validateCard(cardId, context).subscribe(result => {
      expect(result).toEqual(mockResult);
    });
    
    const req = httpMock.expectOne(`/tenant/mapi/v1/cards/${cardId}/validate`);
    expect(req.request.method).toBe('POST');
    expect(req.request.body).toEqual(jasmine.objectContaining({
      location: context.location,
      device_id: jasmine.any(String)
    }));
    
    req.flush(mockResult);
  });
});
```

---

## **üîê SECURITY CONSIDERATIONS FOR PHASE 2**

### **Mobile-Specific Security Measures**

1. **Token Security**:
   - Sanctum tokens with limited lifespan (2-4 hours)
   - Refresh token rotation
   - Device fingerprinting for token binding

2. **QR Code Security**:
   - Phase 2: UUID-based QR (Phase 3 will add signatures)
   - QR rotation capability via API
   - Rate limiting on validation attempts

3. **Tenant Isolation**:
   - All mobile API routes scoped to `/{tenant}/mapi/v1/`
   - Member resolution includes tenant verification
   - Database queries automatically tenant-scoped

4. **Offline Security**:
   - Signed validation bundles
   - Time-limited offline access (24 hours max)
   - Local storage encryption (via Capacitor Secure Storage)

5. **API Security**:
   - Rate limiting per device/account
   - Request signing for critical operations
   - Audit logging for all validations

---

## **üì± MOBILE APP DEPLOYMENT CHECKLIST**

### **Angular Mobile App Build Configuration**

```json
// angular.json (relevant parts)
{
  "projects": {
    "digital-card-mobile": {
      "architect": {
        "build": {
          "configurations": {
            "production": {
              "fileReplacements": [
                {
                  "replace": "src/environments/environment.ts",
                  "with": "src/environments/environment.prod.ts"
                }
              ],
              "optimization": true,
              "outputHashing": "all",
              "sourceMap": false,
              "namedChunks": false,
              "aot": true,
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "2mb",
                  "maximumError": "5mb"
                }
              ]
            }
          }
        },
        "serve": {
          "options": {
            "proxyConfig": "src/proxy.conf.json"
          }
        }
      }
    }
  }
}
```

```typescript
// src/environments/environment.prod.ts
export const environment = {
  production: true,
  apiBaseUrl: 'https://api.yourplatform.com',
  tenantSlug: null, // Will be set dynamically
  appVersion: '1.0.0',
  features: {
    offlineMode: true,
    qrScanner: true,
    pushNotifications: true,
    biometricAuth: false // Phase 3
  },
  security: {
    tokenRefreshInterval: 3600, // 1 hour
    qrRefreshInterval: 86400, // 24 hours
    offlineBundleTtl: 86400 // 24 hours
  }
};
```

### **Capacitor Configuration for Native Features**

```json
// capacitor.config.json
{
  "appId": "com.yourplatform.digitalcard",
  "appName": "Digital Membership Card",
  "webDir": "dist/digital-card-mobile",
  "server": {
    "androidScheme": "https"
  },
  "plugins": {
    "SplashScreen": {
      "launchShowDuration": 3000,
      "launchAutoHide": true
    },
    "PushNotifications": {
      "presentationOptions": ["badge", "sound", "alert"]
    },
    "Camera": {
      "cameraPermissionExplanation": "We need camera access to scan QR codes"
    },
    "LocalNotifications": {
      "smallIcon": "ic_stat_icon_config_sample",
      "iconColor": "#488AFF"
    }
  }
}
```

---

## **üìà SUCCESS METRICS FOR PHASE 2**

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| **Mobile API Response Time** | P95 < 500ms | Application Insights |
| **Mobile App Performance** | Lighthouse Score > 85 | Automated testing |
| **QR Scan Success Rate** | > 95% | Analytics tracking |
| **Offline Mode Usage** | > 30% of validations | Event logging |
| **Member Satisfaction** | 4.5/5 stars | App store reviews |
| **Token Refresh Success** | > 99.9% | Auth service logs |
| **Cross-tenant Leaks** | 0 incidents | Security monitoring |

---

## **üîÑ PHASE 2 ‚Üí PHASE 3 TRANSITION PLAN**

**Upon Phase 2 completion** (Week 6 end):

1. **User Acceptance Testing**: Real members test mobile app
2. **Performance Review**: Analyze mobile API metrics
3. **Security Audit**: Review mobile-specific security
4. **Bug Bash**: Identify and fix mobile-specific issues
5. **Documentation**: Update mobile API docs and user guides

**Ready for Phase 3**: Event-driven architecture, signed QR codes, and advanced features.

---

## **üö® RISK MITIGATION FOR PHASE 2**

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Mobile camera permissions** | High | Graceful fallback to manual entry |
| **Offline data security** | Critical | Signed bundles, time limits, encryption |
| **Token hijacking** | Critical | Device binding, short TTL, refresh rotation |
| **QR code spoofing** | Medium | Phase 3 signatures, rate limiting |
| **Tenant context loss** | High | Clear tenant selection, deep link support |
| **Network connectivity** | Medium | Offline mode, request queuing |

---

**Phase 2 delivers the core mobile experience** while maintaining all architectural constraints. The Angular implementation respects your 6-case routing law with `/mapi/*` endpoints and provides a native-feeling mobile experience with proper tenant isolation.

**Ready to implement Phase 2?** I can generate the specific Angular components or Laravel services you'd like to start with. Which area would you like to tackle first?