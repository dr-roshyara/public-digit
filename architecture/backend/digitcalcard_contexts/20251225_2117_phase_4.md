# **PHASE 4: ADVANCED CAPABILITIES & ENTERPRISE SCALE**

## **üèóÔ∏è ARCHITECTURAL VISION**

Phase 4 transforms the DigitalCardContext from a **production-ready system** to an **enterprise-scale digital identity platform**. We'll implement advanced capabilities that justify the bounded context separation while preparing for massive scale, regulatory compliance, and cross-platform integration.

---

## **üìã PHASE 4 ROADMAP**

| Capability | Business Value | Technical Complexity | Time Estimate |
|------------|----------------|----------------------|---------------|
| **Temporary Guest Cards** | New revenue stream, partner integrations | High (new domain model) | 2-3 weeks |
| **Offline Validation System** | Operational resilience, low-connectivity areas | High (cryptography, sync) | 3-4 weeks |
| **Advanced Projections & CQRS** | Real-time dashboards, analytics | Medium (infrastructure) | 1-2 weeks |
| **Compliance & Audit Framework** | Regulatory requirements, security audits | Medium (governance) | 2 weeks |
| **Multi-Platform Integration** | Apple/Google Wallet, physical access | High (external APIs) | 3-4 weeks |

---

## **1. TEMPORARY GUEST CARDS - ENTERPRISE FEATURE**

### **Domain Model Extension**

```php
<?php
// app/Contexts/DigitalCard/Domain/Entities/GuestCard.php
// Separate Aggregate Root for guest cards with different lifecycle

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Domain\Entities;

use App\Contexts\DigitalCard\Domain\Enums\GuestCardType;
use App\Contexts\DigitalCard\Domain\ValueObjects\GuestCardId;
use App\Contexts\DigitalCard\Domain\ValueObjects\SponsorMemberId;
use App\Contexts\DigitalCard\Domain\ValueObjects\AccessRestrictions;
use DateTimeImmutable;

/**
 * GuestCard Aggregate Root
 * 
 * Key Design Decisions:
 * 1. SEPARATE from DigitalCard aggregate (different lifecycle, rules)
 * 2. Sponsor-based issuance (sponsoring member takes responsibility)
 * 3. Time-bound with configurable access restrictions
 * 4. Usage quotas and audit trails
 */
final class GuestCard implements AggregateRoot
{
    private array $domainEvents = [];
    
    private function __construct(
        private GuestCardId $guestCardId,
        private SponsorMemberId $sponsorMemberId,
        private GuestCardType $type,
        private string $guestName,
        private ?string $guestEmail,
        private AccessRestrictions $accessRestrictions,
        private DateTimeImmutable $issuedAt,
        private DateTimeImmutable $expiresAt,
        private ?DateTimeImmutable $revokedAt = null,
        private string $status = 'active',
        private int $usageCount = 0,
        private ?int $maxUsages = null,
        private array $usageLog = []
    ) {
        $this->assertInvariants();
    }
    
    /**
     * Factory: Issue new guest card
     */
    public static function issue(
        SponsorMemberId $sponsorMemberId,
        GuestCardType $type,
        string $guestName,
        ?string $guestEmail,
        AccessRestrictions $accessRestrictions,
        DateTimeImmutable $validFrom,
        DateTimeImmutable $validTo,
        ?int $maxUsages = null
    ): self {
        $card = new self(
            guestCardId: GuestCardId::generate(),
            sponsorMemberId: $sponsorMemberId,
            type: $type,
            guestName: $guestName,
            guestEmail: $guestEmail,
            accessRestrictions: $accessRestrictions,
            issuedAt: new DateTimeImmutable(),
            expiresAt: $validTo,
            maxUsages: $maxUsages
        );
        
        $card->recordThat(new GuestCardIssued(
            guestCardId: $card->guestCardId,
            sponsorMemberId: $sponsorMemberId,
            guestName: $guestName,
            validFrom: $validFrom,
            validTo: $validTo,
            accessRestrictions: $accessRestrictions->toArray()
        ));
        
        return $card;
    }
    
    /**
     * Validate guest card usage
     * 
     * @throws GuestCardExpiredException
     * @throws GuestCardRevokedException
     * @throws GuestCardUsageLimitExceededException
     * @throws AccessRestrictionViolationException
     */
    public function validateUsage(
        DateTimeImmutable $validationTime,
        array $context = []
    ): ValidationResult {
        // 1. Check card status
        if ($this->status === 'revoked') {
            throw new GuestCardRevokedException(
                "Guest card revoked at {$this->revokedAt->format('Y-m-d H:i:s')}"
            );
        }
        
        // 2. Check expiration
        if ($validationTime > $this->expiresAt) {
            $this->expire();
            throw new GuestCardExpiredException(
                "Guest card expired at {$this->expiresAt->format('Y-m-d H:i:s')}"
            );
        }
        
        // 3. Check usage limits
        if ($this->maxUsages !== null && $this->usageCount >= $this->maxUsages) {
            throw new GuestCardUsageLimitExceededException(
                "Maximum usages ({$this->maxUsages}) exceeded"
            );
        }
        
        // 4. Check time restrictions
        if (!$this->accessRestrictions->isTimeAllowed($validationTime)) {
            throw new AccessRestrictionViolationException(
                "Access not allowed at this time"
            );
        }
        
        // 5. Check location restrictions (if provided in context)
        if (isset($context['location']) && 
            !$this->accessRestrictions->isLocationAllowed($context['location'])) {
            throw new AccessRestrictionViolationException(
                "Access not allowed at this location"
            );
        }
        
        // 6. Record usage
        $this->usageCount++;
        $this->usageLog[] = [
            'timestamp' => $validationTime->format(\DateTimeInterface::ATOM),
            'context' => $context,
            'usage_number' => $this->usageCount
        ];
        
        $this->recordThat(new GuestCardUsed(
            guestCardId: $this->guestCardId,
            usageNumber: $this->usageCount,
            context: $context,
            timestamp: $validationTime
        ));
        
        // 7. Auto-revoke if usage limit reached
        if ($this->maxUsages !== null && $this->usageCount >= $this->maxUsages) {
            $this->revoke('usage_limit_reached', $validationTime);
        }
        
        return ValidationResult::valid(
            validationId: $this->generateValidationId(),
            metadata: [
                'guest_name' => $this->guestName,
                'sponsor_member_id' => $this->sponsorMemberId->toString(),
                'remaining_usages' => $this->maxUsages !== null 
                    ? $this->maxUsages - $this->usageCount 
                    : null,
                'expires_at' => $this->expiresAt->format(\DateTimeInterface::ATOM)
            ]
        );
    }
    
    /**
     * Sponsor revokes guest card
     */
    public function revokeBySponsor(
        SponsorMemberId $sponsorMemberId,
        string $reason,
        DateTimeImmutable $revokedAt
    ): void {
        if (!$this->sponsorMemberId->equals($sponsorMemberId)) {
            throw new UnauthorizedSponsorException(
                'Only the sponsoring member can revoke this guest card'
            );
        }
        
        $this->revoke($reason, $revokedAt);
    }
    
    /**
     * Admin revokes guest card
     */
    public function revokeByAdmin(
        string $reason,
        DateTimeImmutable $revokedAt
    ): void {
        $this->revoke($reason, $revokedAt);
    }
    
    private function revoke(string $reason, DateTimeImmutable $revokedAt): void
    {
        if ($this->status === 'revoked') {
            return;
        }
        
        $this->status = 'revoked';
        $this->revokedAt = $revokedAt;
        
        $this->recordThat(new GuestCardRevoked(
            guestCardId: $this->guestCardId,
            reason: $reason,
            revokedAt: $revokedAt,
            sponsorNotified: $this->shouldNotifySponsor()
        ));
    }
    
    private function expire(): void
    {
        $this->status = 'expired';
        
        $this->recordThat(new GuestCardExpired(
            guestCardId: $this->guestCardId,
            expiredAt: $this->expiresAt
        ));
    }
    
    private function assertInvariants(): void
    {
        // 1. Valid from must be before valid to
        if ($this->expiresAt <= $this->issuedAt) {
            throw new \DomainException(
                'Guest card expiry must be after issue date'
            );
        }
        
        // 2. Max usages must be positive if set
        if ($this->maxUsages !== null && $this->maxUsages <= 0) {
            throw new \DomainException(
                'Maximum usages must be positive'
            );
        }
        
        // 3. Guest name required
        if (empty(trim($this->guestName))) {
            throw new \DomainException(
                'Guest name is required'
            );
        }
    }
    
    private function generateValidationId(): string
    {
        return 'guest_val_' . time() . '_' . bin2hex(random_bytes(4));
    }
    
    private function shouldNotifySponsor(): bool
    {
        return $this->type->requiresSponsorNotification();
    }
    
    // ... getters and event methods
}
```

### **Guest Card Policy Engine**

```php
<?php
// app/Contexts/DigitalCard/Domain/Services/GuestCardPolicyEngine.php
// Business rules for guest card issuance

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Domain\Services;

use App\Contexts\DigitalCard\Domain\ValueObjects\SponsorMemberId;
use App\Contexts\DigitalCard\Domain\Enums\GuestCardType;
use App\Contexts\DigitalCard\Domain\ValueObjects\AccessRestrictions;
use DateTimeImmutable;

final class GuestCardPolicyEngine
{
    private array $policies;
    
    public function __construct()
    {
        $this->policies = config('digitalcard.guest_card_policies', []);
    }
    
    /**
     * Determine if member can issue guest cards
     */
    public function canIssueGuestCards(SponsorMemberId $sponsorId): PolicyResult
    {
        $sponsorTier = $this->getSponsorTier($sponsorId);
        $policy = $this->policies[$sponsorTier] ?? $this->policies['default'];
        
        return new PolicyResult(
            allowed: $policy['can_issue'] ?? false,
            limits: [
                'max_active_guest_cards' => $policy['max_active'] ?? 0,
                'max_issuances_per_month' => $policy['max_per_month'] ?? 0,
                'allowed_types' => $policy['allowed_types'] ?? []
            ],
            restrictions: $policy['restrictions'] ?? []
        );
    }
    
    /**
     * Calculate default validity period based on sponsor tier and card type
     */
    public function calculateDefaultValidity(
        SponsorMemberId $sponsorId,
        GuestCardType $cardType
    ): ValidityPeriod {
        $sponsorTier = $this->getSponsorTier($sponsorId);
        $policy = $this->policies[$sponsorTier]['types'][$cardType->value] 
                ?? $this->policies['default']['types'][$cardType->value];
        
        $now = new DateTimeImmutable();
        
        return new ValidityPeriod(
            validFrom: $now,
            validTo: $now->modify($policy['max_duration'] ?? '+24 hours'),
            canExtend: $policy['can_extend'] ?? false,
            maxExtensions: $policy['max_extensions'] ?? 0
        );
    }
    
    /**
     * Determine access restrictions based on card type
     */
    public function determineAccessRestrictions(
        GuestCardType $cardType,
        array $sponsorOverrides = []
    ): AccessRestrictions {
        $template = $this->policies['access_templates'][$cardType->value] 
                  ?? $this->policies['access_templates']['standard'];
        
        // Apply sponsor overrides if permitted
        if (!empty($sponsorOverrides) && 
            $this->allowsCustomRestrictions($cardType)) {
            $template = array_merge($template, $sponsorOverrides);
        }
        
        return AccessRestrictions::fromArray($template);
    }
    
    /**
     * Check if guest card usage should trigger sponsor notification
     */
    public function requiresUsageNotification(
        GuestCardType $cardType,
        array $usageContext
    ): bool {
        $policy = $this->policies['notification_rules'][$cardType->value] 
                ?? $this->policies['notification_rules']['default'];
        
        // Check time-based rules
        if ($policy['notify_on_first_usage'] ?? false) {
            return $usageContext['usage_number'] === 1;
        }
        
        // Check location-based rules
        if (($policy['notify_on_unusual_location'] ?? false) && 
            isset($usageContext['location'])) {
            return $this->isUnusualLocation(
                $usageContext['location'],
                $policy['usual_locations'] ?? []
            );
        }
        
        // Check time-of-day rules
        if (($policy['notify_outside_hours'] ?? false) && 
            isset($usageContext['timestamp'])) {
            $hour = (int) $usageContext['timestamp']->format('H');
            return $hour < 6 || $hour > 22; // Notify for usage 10PM-6AM
        }
        
        return false;
    }
    
    /**
     * Dynamic pricing based on card type and duration
     */
    public function calculateFee(
        GuestCardType $cardType,
        ValidityPeriod $validity,
        SponsorMemberId $sponsorId
    ): FeeCalculation {
        $sponsorTier = $this->getSponsorTier($sponsorId);
        $baseRate = $this->policies['pricing'][$sponsorTier][$cardType->value] 
                  ?? $this->policies['pricing']['default'][$cardType->value];
        
        $durationDays = $validity->validTo->diff($validity->validFrom)->days;
        
        $fee = $baseRate['base'] ?? 0;
        
        // Add duration-based charges
        if ($durationDays > 1 && isset($baseRate['daily_rate'])) {
            $fee += ($durationDays - 1) * $baseRate['daily_rate'];
        }
        
        // Apply sponsor discounts
        $discount = $this->calculateSponsorDiscount($sponsorId, $cardType);
        $fee = max(0, $fee - $discount);
        
        return new FeeCalculation(
            baseFee: $fee,
            currency: $baseRate['currency'] ?? 'USD',
            breakdown: [
                'base_rate' => $baseRate['base'] ?? 0,
                'duration_charge' => $durationDays > 1 ? ($durationDays - 1) * ($baseRate['daily_rate'] ?? 0) : 0,
                'discount_applied' => $discount,
                'final_fee' => $fee
            ]
        );
    }
    
    private function getSponsorTier(SponsorMemberId $sponsorId): string
    {
        // In reality, this would query MembershipContext via ACL
        // For now, return default
        return 'standard';
    }
    
    // ... helper methods
}
```

---

## **2. OFFLINE VALIDATION SYSTEM - ENTERPRISE RESILIENCE**

### **Secure Offline Bundle Architecture**

```php
<?php
// app/Contexts/DigitalCard/Domain/Services/OfflineValidationSystem.php

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Domain\Services;

use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use App\Contexts\DigitalCard\Domain\ValueObjects\ValidationBundle;
use App\Contexts\DigitalCard\Domain\Entities\DigitalCard;
use DateTimeImmutable;
use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Facades\Cache;

/**
 * Enterprise Offline Validation System
 * 
 * Architecture:
 * 1. Time-bound bundles (1-24 hours)
 * 2. Asymmetric cryptography for mobile verification
 * 3. Bloom filters for privacy-preserving lookups
 * 4. Delta updates to minimize bandwidth
 * 5. Graceful degradation when online
 */
final class OfflineValidationSystem
{
    private const BUNDLE_TTL = 3600; // 1 hour default
    private const MAX_BUNDLE_SIZE = 1000; // cards per bundle
    private const ENCRYPTION_METHOD = 'aes-256-gcm';
    
    public function __construct(
        private OfflineBundleEncryptor $encryptor,
        private BloomFilterService $bloomFilter,
        private BundleCompressionService $compression,
        private DigitalCardRepository $cardRepository
    ) {}
    
    /**
     * Generate offline validation bundle for a validator
     * 
     * @param MemberId $validatorId Who will validate offline
     * @param int $ttlSeconds How long bundle is valid
     * @param array $filters Which cards to include
     */
    public function generateBundle(
        MemberId $validatorId,
        int $ttlSeconds = self::BUNDLE_TTL,
        array $filters = []
    ): ValidationBundle {
        $validFrom = new DateTimeImmutable();
        $validTo = $validFrom->modify("+{$ttlSeconds} seconds");
        
        // 1. Get cards this validator needs access to
        $cards = $this->getRelevantCards($validatorId, $filters);
        
        // 2. Create privacy-preserving index (Bloom filter)
        $cardIndex = $this->bloomFilter->createIndex(
            array_map(fn($card) => $card->id()->toString(), $cards),
            $ttlSeconds
        );
        
        // 3. Create minimal card data for offline validation
        $cardData = $this->createMinimalCardData($cards, $validatorId);
        
        // 4. Create manifest with metadata
        $manifest = [
            'version' => '2.0',
            'generated_at' => $validFrom->format(\DateTimeInterface::ATOM),
            'valid_until' => $validTo->format(\DateTimeInterface::ATOM),
            'validator_id' => $validatorId->toString(),
            'total_cards' => count($cards),
            'card_index_type' => 'bloom_filter',
            'compression' => 'gzip',
            'encryption' => self::ENCRYPTION_METHOD,
        ];
        
        // 5. Compress payload
        $payload = [
            'manifest' => $manifest,
            'card_index' => $cardIndex,
            'cards' => $cardData
        ];
        
        $compressedPayload = $this->compression->compress($payload);
        
        // 6. Encrypt for this specific validator
        $encryptedPayload = $this->encryptor->encryptForValidator(
            $compressedPayload,
            $validatorId
        );
        
        // 7. Create bundle with digital signature
        $bundle = new ValidationBundle(
            id: ValidationBundleId::generate(),
            validatorId: $validatorId,
            encryptedPayload: $encryptedPayload,
            signature: $this->signBundle($encryptedPayload, $validatorId),
            validFrom: $validFrom,
            validTo: $validTo,
            metadata: $manifest
        );
        
        // 8. Cache bundle ID for revocation tracking
        $this->cacheBundleReference($bundle);
        
        return $bundle;
    }
    
    /**
     * Validate card offline using bundle
     */
    public function validateOffline(
        string $cardId,
        ValidationBundle $bundle,
        array $validationContext = []
    ): OfflineValidationResult {
        // 1. Check bundle validity
        if (!$this->isBundleValid($bundle)) {
            return OfflineValidationResult::invalid('bundle_expired');
        }
        
        // 2. Verify bundle signature
        if (!$this->verifyBundleSignature($bundle)) {
            return OfflineValidationResult::invalid('bundle_tampered');
        }
        
        // 3. Decrypt bundle (requires validator's key)
        try {
            $payload = $this->decryptBundle($bundle);
        } catch (\Exception $e) {
            return OfflineValidationResult::invalid('decryption_failed');
        }
        
        // 4. Check if card exists in bundle (privacy-preserving)
        if (!$this->bloomFilter->mightContain($payload['card_index'], $cardId)) {
            return OfflineValidationResult::invalid('card_not_in_bundle');
        }
        
        // 5. If bloom filter says "maybe", check actual card data
        $cardData = $this->findCardInBundle($cardId, $payload['cards']);
        
        if (!$cardData) {
            // False positive from bloom filter - valid response for privacy
            return OfflineValidationResult::invalid('card_not_found');
        }
        
        // 6. Validate card against offline rules
        return $this->validateCardOffline($cardData, $validationContext);
    }
    
    /**
     * Generate delta update for existing bundle
     */
    public function generateDeltaUpdate(
        ValidationBundleId $existingBundleId,
        MemberId $validatorId
    ): ?DeltaUpdate {
        $existingBundle = $this->getBundle($existingBundleId);
        
        if (!$existingBundle || !$existingBundle->isOwnedBy($validatorId)) {
            return null;
        }
        
        // Get changes since bundle was generated
        $changes = $this->getCardChangesSince(
            $existingBundle->generatedAt(),
            $validatorId
        );
        
        if (empty($changes)) {
            return null; // No changes needed
        }
        
        return new DeltaUpdate(
            baseBundleId: $existingBundleId,
            changes: $changes,
            appliedAt: new DateTimeImmutable(),
            sequenceNumber: $this->getNextSequenceNumber($existingBundleId)
        );
    }
    
    /**
     * Revoke a bundle (e.g., validator device lost)
     */
    public function revokeBundle(ValidationBundleId $bundleId): void
    {
        $bundle = $this->getBundle($bundleId);
        
        if ($bundle) {
            $bundle->revoke();
            $this->saveBundle($bundle);
            
            // Broadcast revocation to other services
            event(new BundleRevoked(
                bundleId: $bundleId,
                revokedAt: new DateTimeImmutable(),
                reason: 'manual_revocation'
            ));
        }
    }
    
    /**
     * Emergency revocation of all bundles for a validator
     */
    public function emergencyRevokeAllForValidator(MemberId $validatorId): void
    {
        $bundles = $this->findBundlesForValidator($validatorId);
        
        foreach ($bundles as $bundle) {
            $bundle->revoke();
            $this->saveBundle($bundle);
        }
        
        // Invalidate validator's encryption key
        $this->encryptor->rotateValidatorKey($validatorId);
        
        event(new ValidatorBundlesRevoked(
            validatorId: $validatorId,
            bundlesRevoked: count($bundles),
            revokedAt: new DateTimeImmutable()
        ));
    }
    
    private function getRelevantCards(MemberId $validatorId, array $filters): array
    {
        // Business logic: Which cards can this validator see?
        // Example: Committee members can validate all active cards in their committee
        //          Regular members can only validate their own cards
        
        if ($this->isCommitteeMember($validatorId)) {
            $committeeId = $this->getCommitteeId($validatorId);
            return $this->cardRepository->findActiveCardsInCommittee($committeeId);
        }
        
        // Regular member - only their own cards
        return $this->cardRepository->findByMember($validatorId);
    }
    
    private function createMinimalCardData(array $cards, MemberId $validatorId): array
    {
        $minimalData = [];
        
        foreach ($cards as $card) {
            // Include only data needed for offline validation
            $minimalData[] = [
                'id' => $card->id()->toString(),
                'member_id' => $card->memberId()->toString(),
                'status' => $card->status()->value,
                'expires_at' => $card->expiresAt()->format(\DateTimeInterface::ATOM),
                'hashed_qr' => $this->hashQRForOffline($card->qrCode(), $validatorId),
                'access_flags' => $this->determineAccessFlags($card, $validatorId),
                
                // Privacy: Don't include member names or emails
                // Security: Don't include full QR codes
            ];
        }
        
        return $minimalData;
    }
    
    private function hashQRForOffline(QRCode $qrCode, MemberId $validatorId): string
    {
        // Create validator-specific hash of QR code
        // Allows validation without exposing full QR
        $data = $qrCode->toString() . '|' . $validatorId->toString();
        return hash('sha256', $data);
    }
    
    private function validateCardOffline(array $cardData, array $context): OfflineValidationResult
    {
        // Check expiration
        $expiresAt = new DateTimeImmutable($cardData['expires_at']);
        $now = new DateTimeImmutable();
        
        if ($now > $expiresAt) {
            return OfflineValidationResult::invalid('card_expired');
        }
        
        // Check status
        if ($cardData['status'] !== 'active') {
            return OfflineValidationResult::invalid('card_not_active');
        }
        
        // Check time restrictions (if any)
        if (isset($cardData['access_flags']['time_restricted'])) {
            $currentHour = (int) $now->format('H');
            $allowedStart = $cardData['access_flags']['allowed_hours_start'];
            $allowedEnd = $cardData['access_flags']['allowed_hours_end'];
            
            if ($currentHour < $allowedStart || $currentHour > $allowedEnd) {
                return OfflineValidationResult::invalid('outside_allowed_hours');
            }
        }
        
        // Check location restrictions (if provided)
        if (isset($context['location']) && 
            isset($cardData['access_flags']['location_restricted'])) {
            $allowedLocations = $cardData['access_flags']['allowed_locations'];
            
            if (!$this->isLocationAllowed($context['location'], $allowedLocations)) {
                return OfflineValidationResult::invalid('location_not_allowed');
            }
        }
        
        return OfflineValidationResult::valid(
            cardId: $cardData['id'],
            memberId: $cardData['member_id'],
            metadata: [
                'offline_validation' => true,
                'validated_at' => $now->format(\DateTimeInterface::ATOM),
                'remaining_validity' => $expiresAt->diff($now)->format('%hh %im')
            ]
        );
    }
}
```

### **Mobile Offline Validation Service (Angular)**

```typescript
// src/app/core/services/offline-validation.service.ts

import { Injectable, Inject, PLATFORM_ID } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, from, of, throwError } from 'rxjs';
import { map, tap, catchError, switchMap } from 'rxjs/operators';
import { isPlatformBrowser } from '@angular/common';
import CryptoJS from 'crypto-js';
import * as zlib from 'pako';

export interface ValidationBundle {
  id: string;
  encrypted_payload: string;
  signature: string;
  valid_from: string;
  valid_until: string;
  metadata: {
    version: string;
    total_cards: number;
    compression: string;
    encryption: string;
  };
}

export interface OfflineValidationResult {
  valid: boolean;
  card_id?: string;
  member_id?: string;
  reason?: string;
  metadata?: any;
  offline: boolean;
}

@Injectable({
  providedIn: 'root'
})
export class OfflineValidationService {
  private storageKey = 'digitalcard_offline_bundles';
  private currentBundle: ValidationBundle | null = null;
  private decryptionKey: string | null = null;
  private isInitialized = false;
  
  constructor(
    private http: HttpClient,
    @Inject(PLATFORM_ID) private platformId: Object,
    private authService: AuthService,
    private deviceService: DeviceService
  ) {
    this.initialize();
  }
  
  /**
   * Download latest validation bundle
   */
  downloadBundle(forceRefresh = false): Observable<ValidationBundle> {
    const tenantSlug = this.authService.getCurrentTenant();
    const url = `/${tenantSlug}/mapi/v1/offline/bundle`;
    const headers = this.getAuthHeaders();
    
    return this.http.get<ValidationBundle>(url, { headers }).pipe(
      tap(bundle => {
        this.validateBundle(bundle);
        this.storeBundle(bundle);
        this.currentBundle = bundle;
      }),
      catchError(error => {
        // If online download fails, try to use cached bundle
        const cached = this.getCachedBundle();
        if (cached) {
          return from([cached]);
        }
        return throwError(() => error);
      })
    );
  }
  
  /**
   * Validate card offline
   */
  validateCardOffline(cardId: string, context?: any): Observable<OfflineValidationResult> {
    return from(this.validateCardOfflineAsync(cardId, context));
  }
  
  private async validateCardOfflineAsync(
    cardId: string, 
    context?: any
  ): Promise<OfflineValidationResult> {
    // 1. Check if we have a valid bundle
    const bundle = this.currentBundle || this.getCachedBundle();
    
    if (!bundle) {
      return {
        valid: false,
        reason: 'no_offline_bundle',
        offline: true
      };
    }
    
    // 2. Check bundle validity
    if (!this.isBundleValid(bundle)) {
      return {
        valid: false,
        reason: 'bundle_expired',
        offline: true
      };
    }
    
    try {
      // 3. Decrypt and decompress bundle
      const payload = await this.decryptBundle(bundle);
      
      // 4. Check card in bloom filter (privacy-preserving)
      const mightContain = this.bloomFilterCheck(
        payload.card_index, 
        cardId
      );
      
      if (!mightContain) {
        return {
          valid: false,
          reason: 'card_not_found',
          offline: true
        };
      }
      
      // 5. Find card in bundle
      const cardData = this.findCardInBundle(cardId, payload.cards);
      
      if (!cardData) {
        // Bloom filter false positive
        return {
          valid: false,
          reason: 'card_not_found',
          offline: true
        };
      }
      
      // 6. Validate against offline rules
      return this.validateOfflineRules(cardData, context);
      
    } catch (error) {
      console.error('Offline validation failed:', error);
      return {
        valid: false,
        reason: 'validation_error',
        offline: true
      };
    }
  }
  
  /**
   * Check if device is offline and we can validate
   */
  canValidateOffline(): boolean {
    if (!isPlatformBrowser(this.platformId)) {
      return false;
    }
    
    // Check network status
    if (navigator.onLine === false) {
      const bundle = this.currentBundle || this.getCachedBundle();
      return !!bundle && this.isBundleValid(bundle);
    }
    
    // Online but want to test offline capability
    return this.hasValidBundle();
  }
  
  /**
   * Sync offline validation events when back online
   */
  syncOfflineEvents(): Observable<any> {
    if (!isPlatformBrowser(this.platformId)) {
      return of({ success: false, reason: 'not_browser' });
    }
    
    const events = this.getPendingOfflineEvents();
    
    if (events.length === 0) {
      return of({ success: true, synced: 0 });
    }
    
    const tenantSlug = this.authService.getCurrentTenant();
    const url = `/${tenantSlug}/mapi/v1/offline/sync`;
    const headers = this.getAuthHeaders();
    
    return this.http.post(url, { events }, { headers }).pipe(
      tap(response => {
        if (response.success) {
          this.clearPendingEvents();
        }
      }),
      catchError(error => {
        console.error('Failed to sync offline events:', error);
        return of({ success: false, error: error.message });
      })
    );
  }
  
  /**
   * Get bundle status for UI
   */
  getBundleStatus(): {
    hasBundle: boolean;
    isValid: boolean;
    expiresIn: string;
    totalCards: number;
    lastUpdated: string;
  } {
    const bundle = this.currentBundle || this.getCachedBundle();
    
    if (!bundle) {
      return {
        hasBundle: false,
        isValid: false,
        expiresIn: 'N/A',
        totalCards: 0,
        lastUpdated: 'N/A'
      };
    }
    
    const validUntil = new Date(bundle.valid_until);
    const now = new Date();
    const hoursLeft = Math.max(0, (validUntil.getTime() - now.getTime()) / (1000 * 3600));
    
    return {
      hasBundle: true,
      isValid: this.isBundleValid(bundle),
      expiresIn: hoursLeft < 1 
        ? `${Math.round(hoursLeft * 60)} minutes` 
        : `${Math.round(hoursLeft)} hours`,
      totalCards: bundle.metadata.total_cards,
      lastUpdated: new Date(bundle.valid_from).toLocaleString()
    };
  }
  
  // Private methods
  private async initialize(): Promise<void> {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    
    // Load decryption key from secure storage
    this.decryptionKey = await this.loadDecryptionKey();
    
    // Load cached bundle
    this.currentBundle = this.getCachedBundle();
    
    // Set up network change detection
    window.addEventListener('online', () => this.handleOnline());
    window.addEventListener('offline', () => this.handleOffline());
    
    this.isInitialized = true;
  }
  
  private async loadDecryptionKey(): Promise<string | null> {
    // In production, use Capacitor Secure Storage or similar
    if (isPlatformBrowser(this.platformId)) {
      const key = localStorage.getItem('offline_decryption_key');
      
      if (key) {
        // Decrypt the key with device biometrics
        return await this.decryptWithBiometrics(key);
      }
    }
    
    return null;
  }
  
  private async decryptBundle(bundle: ValidationBundle): Promise<any> {
    if (!this.decryptionKey) {
      throw new Error('No decryption key available');
    }
    
    // 1. Verify signature
    if (!this.verifySignature(bundle)) {
      throw new Error('Bundle signature invalid');
    }
    
    // 2. Decrypt payload
    const decrypted = CryptoJS.AES.decrypt(
      bundle.encrypted_payload,
      this.decryptionKey
    ).toString(CryptoJS.enc.Utf8);
    
    // 3. Decompress if needed
    if (bundle.metadata.compression === 'gzip') {
      const compressed = Uint8Array.from(atob(decrypted), c => c.charCodeAt(0));
      const decompressed = zlib.inflate(compressed, { to: 'string' });
      return JSON.parse(decompressed);
    }
    
    return JSON.parse(decrypted);
  }
  
  private bloomFilterCheck(bloomFilter: any, cardId: string): boolean {
    // Simplified bloom filter check
    // In reality, this would use a proper bloom filter implementation
    const hash1 = this.hashString(cardId + '_1') % bloomFilter.size;
    const hash2 = this.hashString(cardId + '_2') % bloomFilter.size;
    const hash3 = this.hashString(cardId + '_3') % bloomFilter.size;
    
    return bloomFilter.bitArray[hash1] && 
           bloomFilter.bitArray[hash2] && 
           bloomFilter.bitArray[hash3];
  }
  
  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return Math.abs(hash);
  }
  
  private isBundleValid(bundle: ValidationBundle): boolean {
    const validUntil = new Date(bundle.valid_until);
    return new Date() <= validUntil;
  }
  
  private storeBundle(bundle: ValidationBundle): void {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    
    const bundles = this.getStoredBundles();
    bundles[bundle.id] = {
      bundle,
      storedAt: new Date().toISOString()
    };
    
    // Keep only last 3 bundles
    const bundleIds = Object.keys(bundles);
    if (bundleIds.length > 3) {
      const oldestId = bundleIds.sort((a, b) => 
        new Date(bundles[a].storedAt).getTime() - 
        new Date(bundles[b].storedAt).getTime()
      ).pop()!;
      
      delete bundles[oldestId];
    }
    
    localStorage.setItem(this.storageKey, JSON.stringify(bundles));
  }
  
  private getCachedBundle(): ValidationBundle | null {
    const bundles = this.getStoredBundles();
    const bundleEntries = Object.values(bundles);
    
    if (bundleEntries.length === 0) {
      return null;
    }
    
    // Return most recent valid bundle
    const validBundles = bundleEntries
      .filter(entry => this.isBundleValid(entry.bundle))
      .sort((a, b) => 
        new Date(b.storedAt).getTime() - new Date(a.storedAt).getTime()
      );
    
    return validBundles.length > 0 ? validBundles[0].bundle : null;
  }
  
  private getStoredBundles(): Record<string, any> {
    if (!isPlatformBrowser(this.platformId)) {
      return {};
    }
    
    const stored = localStorage.getItem(this.storageKey);
    return stored ? JSON.parse(stored) : {};
  }
  
  // ... other private methods
}
```

---

## **3. ADVANCED PROJECTIONS & CQRS OPTIMIZATION**

### **Real-time Projection System**

```php
<?php
// app/Contexts/DigitalCard/Infrastructure/Projections/RealTimeCardProjector.php

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\Projections;

use App\Contexts\DigitalCard\Domain\Events\CardValidated;
use App\Contexts\DigitalCard\Domain\Events\CardIssued;
use App\Contexts\DigitalCard\Domain\Events\GuestCardUsed;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Redis;
use React\EventLoop\Factory;
use React\Socket\ConnectionInterface;

/**
 * Real-time Projection System with WebSocket Support
 * 
 * Features:
 * 1. Materialized views for dashboard queries
 * 2. Real-time WebSocket updates for admin dashboards
 * 3. Time-series data for analytics
 * 4. Denormalized aggregates for complex queries
 */
final class RealTimeCardProjector
{
    private $loop;
    private $websocketServer;
    private $connectedClients = [];
    
    public function __construct()
    {
        $this->initializeWebSocketServer();
    }
    
    /**
     * Project card validation in real-time
     */
    public function projectCardValidation(CardValidated $event): void
    {
        // 1. Update materialized view for fast queries
        DB::table('real_time_validations')->insert([
            'card_id' => $event->cardId()->toString(),
            'validator_id' => $event->validatorMemberId()->toString(),
            'success' => $event->success(),
            'timestamp' => $event->occurredAt()->format('Y-m-d H:i:s.u'),
            'location' => $event->context()['location'] ?? null,
            'tenant_id' => app('currentTenant')->id,
            'created_at' => now()
        ]);
        
        // 2. Update time-series aggregation
        $this->updateTimeSeriesAggregate($event);
        
        // 3. Update real-time counters
        $this->updateRealtimeCounters($event);
        
        // 4. Broadcast to WebSocket clients
        $this->broadcastValidationEvent($event);
        
        // 5. Check for anomalies
        $this->checkForAnomalies($event);
    }
    
    /**
     * Create materialized view for dashboard queries
     */
    public function refreshMaterializedViews(): void
    {
        // Card summary by hour
        DB::statement('
            REFRESH MATERIALIZED VIEW CONCURRENTLY card_validations_by_hour
        ');
        
        // Member activity heatmap
        DB::statement('
            REFRESH MATERIALIZED VIEW CONCURRENTLY member_validation_heatmap
        ');
        
        // Location-based analytics
        DB::statement('
            REFRESH MATERIALIZED VIEW CONCURRENTLY validation_location_analytics
        ');
    }
    
    /**
     * Generate time-series data for charts
     */
    public function generateTimeSeriesData(string $period = 'hour'): array
    {
        $query = match($period) {
            'minute' => 'DATE_FORMAT(timestamp, "%Y-%m-%d %H:%i:00")',
            'hour' => 'DATE_FORMAT(timestamp, "%Y-%m-%d %H:00:00")',
            'day' => 'DATE(timestamp)',
            'week' => 'YEARWEEK(timestamp, 3)',
            default => 'DATE(timestamp)'
        };
        
        return DB::table('real_time_validations')
            ->selectRaw("
                {$query} as time_bucket,
                COUNT(*) as total_validations,
                SUM(success) as successful_validations,
                AVG(CASE WHEN context->>'$.latency_ms' IS NOT NULL 
                    THEN CAST(context->>'$.latency_ms' AS DECIMAL(10,2)) 
                    END) as avg_latency_ms,
                COUNT(DISTINCT card_id) as unique_cards,
                COUNT(DISTINCT validator_id) as unique_validators
            ")
            ->where('timestamp', '>=', now()->subDays(30))
            ->groupBy('time_bucket')
            ->orderBy('time_bucket')
            ->get()
            ->toArray();
    }
    
    /**
     * Get real-time dashboard metrics
     */
    public function getRealtimeDashboardMetrics(): array
    {
        $now = now();
        $lastHour = $now->copy()->subHour();
        
        return [
            'current_hour' => [
                'validations' => DB::table('real_time_validations')
                    ->whereBetween('timestamp', [$lastHour, $now])
                    ->count(),
                'success_rate' => DB::table('real_time_validations')
                    ->whereBetween('timestamp', [$lastHour, $now])
                    ->avg('success') * 100,
                'unique_cards' => DB::table('real_time_validations')
                    ->whereBetween('timestamp', [$lastHour, $now])
                    ->distinct('card_id')
                    ->count('card_id'),
            ],
            'today' => [
                'validations' => DB::table('real_time_validations')
                    ->whereDate('timestamp', $now->toDateString())
                    ->count(),
                'peak_hour' => $this->identifyPeakHour($now->toDateString()),
            ],
            'system' => [
                'websocket_clients' => count($this->connectedClients),
                'projection_lag_ms' => $this->calculateProjectionLag(),
                'memory_usage_mb' => memory_get_usage(true) / 1024 / 1024,
            ]
        ];
    }
    
    private function updateTimeSeriesAggregate(CardValidated $event): void
    {
        $timestamp = $event->occurredAt()->format('Y-m-d H:i:00'); // Round to minute
        
        Redis::connection('timeseries')->pipeline(function ($pipe) use ($event, $timestamp) {
            // Add to RedisTimeSeries for real-time analytics
            $pipe->tsAdd('validations:total', strtotime($timestamp) * 1000, 1);
            
            if ($event->success()) {
                $pipe->tsAdd('validations:success', strtotime($timestamp) * 1000, 1);
            } else {
                $pipe->tsAdd('validations:failed', strtotime($timestamp) * 1000, 1);
            }
            
            // Add to card-specific time series
            $cardKey = 'card:validations:' . $event->cardId()->toString();
            $pipe->tsAdd($cardKey, strtotime($timestamp) * 1000, 1);
            
            // Add to validator-specific time series
            $validatorKey = 'validator:activity:' . $event->validatorMemberId()->toString();
            $pipe->tsAdd($validatorKey, strtotime($timestamp) * 1000, 1);
        });
    }
    
    private function updateRealtimeCounters(CardValidated $event): void
    {
        Redis::connection()->pipeline(function ($pipe) use ($event) {
            // Increment counters
            $pipe->incr('realtime:validations:total');
            
            if ($event->success()) {
                $pipe->incr('realtime:validations:success');
            } else {
                $pipe->incr('realtime:validations:failed');
                $pipe->incr('realtime:validations:failed:' . $event->failureReason());
            }
            
            // Update rolling window (last 5 minutes)
            $currentMinute = (int) (time() / 60);
            $pipe->zadd('realtime:window', $currentMinute, $event->cardId()->toString());
            $pipe->zremrangebyscore('realtime:window', 0, $currentMinute - 5);
            
            // Update geospatial index if location provided
            if (isset($event->context()['location'])) {
                $location = $event->context()['location'];
                $pipe->geoadd(
                    'validations:geo', 
                    $location['lng'], 
                    $location['lat'], 
                    $event->cardId()->toString() . ':' . time()
                );
            }
        });
    }
    
    private function broadcastValidationEvent(CardValidated $event): void
    {
        $payload = json_encode([
            'type' => 'validation',
            'data' => [
                'card_id' => $event->cardId()->toString(),
                'validator_id' => $event->validatorMemberId()->toString(),
                'success' => $event->success(),
                'timestamp' => $event->occurredAt()->format(\DateTimeInterface::ATOM),
                'reason' => $event->failureReason(),
            ]
        ]);
        
        foreach ($this->connectedClients as $client) {
            $client->write($payload);
        }
    }
    
    private function checkForAnomalies(CardValidated $event): void
    {
        // Check for rapid succession validations (possible attack)
        $recentValidations = Redis::get('card:recent:' . $event->cardId()->toString());
        
        if ($recentValidations && $recentValidations > 10) {
            // More than 10 validations in short period
            event(new ValidationAnomalyDetected(
                cardId: $event->cardId()->toString(),
                anomalyType: 'rapid_validations',
                count: $recentValidations,
                detectedAt: new \DateTimeImmutable()
            ));
        }
        
        // Update recent validation counter (expires in 60 seconds)
        Redis::incr('card:recent:' . $event->cardId()->toString());
        Redis::expire('card:recent:' . $event->cardId()->toString(), 60);
    }
    
    private function initializeWebSocketServer(): void
    {
        $this->loop = Factory::create();
        
        $this->websocketServer = new \React\Socket\Server('0.0.0.0:8080', $this->loop);
        
        new \Ratchet\Server\IoServer(
            new \Ratchet\Http\HttpServer(
                new \Ratchet\WebSocket\WsServer(
                    new class($this) implements \Ratchet\WebSocket\WsServerInterface {
                        private $projector;
                        
                        public function __construct($projector)
                        {
                            $this->projector = $projector;
                        }
                        
                        public function onOpen(ConnectionInterface $conn)
                        {
                            $this->projector->addClient($conn);
                            $conn->send(json_encode([
                                'type' => 'connected',
                                'timestamp' => now()->toISOString()
                            ]));
                        }
                        
                        public function onMessage(ConnectionInterface $from, $msg)
                        {
                            // Handle client messages (subscriptions, etc.)
                        }
                        
                        public function onClose(ConnectionInterface $conn)
                        {
                            $this->projector->removeClient($conn);
                        }
                        
                        public function onError(ConnectionInterface $conn, \Exception $e)
                        {
                            $conn->close();
                        }
                    }
                )
            ),
            $this->websocketServer
        );
        
        // Start server in background
        $this->loop->futureTick(function () {
            $this->loop->run();
        });
    }
    
    public function addClient(ConnectionInterface $client): void
    {
        $this->connectedClients[] = $client;
    }
    
    public function removeClient(ConnectionInterface $client): void
    {
        $this->connectedClients = array_filter(
            $this->connectedClients,
            fn($c) => $c !== $client
        );
    }
}
```

---

## **4. COMPLIANCE & AUDIT FRAMEWORK**

```php
<?php
// app/Contexts/DigitalCard/Infrastructure/Compliance/ComplianceAuditor.php

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\Compliance;

use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use App\Contexts\DigitalCard\Domain\ValueObjects\CardId;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;

/**
 * GDPR/CCPA Compliance Framework
 * 
 * Features:
 * 1. Right to access (data export)
 * 2. Right to be forgotten (data erasure)
 * 3. Audit trail for compliance verification
 * 4. Data retention policy enforcement
 * 5. Consent management
 */
final class ComplianceAuditor
{
    private const RETENTION_PERIOD = 'P2Y'; // 2 years
    private const ANONYMIZATION_SALT = 'compliance_salt';
    
    /**
     * Generate data export for a member (GDPR Right to Access)
     */
    public function generateDataExport(MemberId $memberId): DataExport
    {
        $exportId = DataExportId::generate();
        $exportData = [];
        
        // 1. Collect all card data
        $exportData['cards'] = DB::table('digital_cards')
            ->where('member_id', $memberId->toString())
            ->get()
            ->map(fn($card) => $this->sanitizeForExport($card))
            ->toArray();
        
        // 2. Collect validation history
        $exportData['validations'] = DB::table('card_validation_audit')
            ->where('card_id', 'IN', function ($query) use ($memberId) {
                $query->select('id')
                    ->from('digital_cards')
                    ->where('member_id', $memberId->toString());
            })
            ->get()
            ->map(fn($validation) => $this->sanitizeForExport($validation))
            ->toArray();
        
        // 3. Collect guest cards (if any)
        $exportData['guest_cards'] = DB::table('guest_cards')
            ->where('sponsor_member_id', $memberId->toString())
            ->get()
            ->map(fn($guestCard) => $this->sanitizeForExport($guestCard))
            ->toArray();
        
        // 4. Generate audit trail for this export
        $this->auditDataExport($exportId, $memberId);
        
        // 5. Create encrypted export file
        $encryptedExport = $this->encryptExport($exportData, $memberId);
        
        return new DataExport(
            id: $exportId,
            memberId: $memberId,
            generatedAt: new \DateTimeImmutable(),
            expiresAt: (new \DateTimeImmutable())->modify('+30 days'),
            downloadUrl: $this->storeExport($encryptedExport, $exportId),
            format: 'json_encrypted',
            sizeBytes: strlen($encryptedExport),
            checksum: hash('sha256', $encryptedExport)
        );
    }
    
    /**
     * Erase member data (GDPR Right to be Forgotten)
     */
    public function eraseMemberData(MemberId $memberId): ErasureReport
    {
        DB::transaction(function () use ($memberId) {
            // 1. Anonymize cards (soft delete with anonymization)
            DB::table('digital_cards')
                ->where('member_id', $memberId->toString())
                ->update([
                    'member_id' => $this->anonymizeIdentifier($memberId->toString()),
                    'anonymized_at' => now(),
                    'anonymization_reason' => 'gdpr_erasure'
                ]);
            
            // 2. Anonymize audit trails
            $this->anonymizeAuditTrails($memberId);
            
            // 3. Delete guest cards
            DB::table('guest_cards')
                ->where('sponsor_member_id', $memberId->toString())
                ->delete();
            
            // 4. Record erasure in compliance log
            DB::table('compliance_erasures')->insert([
                'member_id' => $memberId->toString(),
                'erased_at' => now(),
                'request_id' => $this->generateRequestId(),
                'anonymized_records' => DB::raw('(SELECT ROW_COUNT())'),
                'retained_for_legal' => $this->identifyLegalHoldRecords($memberId)
            ]);
        });
        
        return new ErasureReport(
            memberId: $memberId,
            erasedAt: new \DateTimeImmutable(),
            recordsAffected: DB::table('compliance_erasures')
                ->where('member_id', $memberId->toString())
                ->value('anonymized_records'),
            legalHoldRecords: DB::table('compliance_erasures')
                ->where('member_id', $memberId->toString())
                ->value('retained_for_legal')
        );
    }
    
    /**
     * Enforce data retention policies
     */
    public function enforceRetentionPolicies(): RetentionEnforcementReport
    {
        $cutoffDate = (new Carbon())->sub(new \DateInterval(self::RETENTION_PERIOD));
        
        $report = new RetentionEnforcementReport(startedAt: new \DateTimeImmutable());
        
        // 1. Archive old validation data
        $archivedValidations = DB::table('card_validation_audit')
            ->where('occurred_at', '<', $cutoffDate)
            ->whereNull('archived_at')
            ->chunkById(1000, function ($chunk) use ($report) {
                $this->archiveChunk($chunk, 'validations');
                $report->addArchived('validations', count($chunk));
            });
        
        // 2. Anonymize old card data
        $anonymizedCards = DB::table('digital_cards')
            ->where('created_at', '<', $cutoffDate)
            ->whereNull('anonymized_at')
            ->where('status', 'expired')
            ->update([
                'qr_code' => 'anonymized',
                'anonymized_at' => now()
            ]);
        
        $report->addAnonymized('cards', $anonymizedCards);
        
        // 3. Purge temporary guest cards
        $purgedGuestCards = DB::table('guest_cards')
            ->where('expires_at', '<', $cutoffDate->subMonths(6))
            ->delete();
        
        $report->addPurged('guest_cards', $purgedGuestCards);
        
        $report->completedAt = new \DateTimeImmutable();
        
        return $report;
    }
    
    /**
     * Generate compliance audit report
     */
    public function generateComplianceReport(
        \DateTimeInterface $from,
        \DateTimeInterface $to
    ): ComplianceReport {
        return new ComplianceReport(
            period: new DatePeriod($from, $to),
            dataExports: DB::table('compliance_exports')
                ->whereBetween('generated_at', [$from, $to])
                ->count(),
            dataErasures: DB::table('compliance_erasures')
                ->whereBetween('erased_at', [$from, $to])
                ->count(),
            retentionActions: DB::table('retention_actions')
                ->whereBetween('performed_at', [$from, $to])
                ->count(),
            accessRequests: DB::table('access_requests')
                ->whereBetween('requested_at', [$from, $to])
                ->count(),
            complianceScore: $this->calculateComplianceScore($from, $to),
            findings: $this->identifyComplianceFindings($from, $to)
        );
    }
    
    private function anonymizeIdentifier(string $identifier): string
    {
        // Deterministic anonymization (same input produces same output)
        // Allows for aggregate analysis while protecting identity
        return 'anon_' . hash('sha256', $identifier . self::ANONYMIZATION_SALT);
    }
    
    private function sanitizeForExport($data): array
    {
        // Remove internal fields and PII
        $sanitized = (array) $data;
        
        unset($sanitized['internal_id']);
        unset($sanitized['audit_key']);
        unset($sanitized['encryption_key']);
        
        // Pseudonymize if needed
        if (isset($sanitized['member_email'])) {
            $sanitized['member_email'] = 'redacted@example.com';
        }
        
        return $sanitized;
    }
    
    private function encryptExport(array $data, MemberId $memberId): string
    {
        $jsonData = json_encode($data);
        $key = $this->generateExportKey($memberId);
        
        return openssl_encrypt(
            $jsonData,
            'aes-256-gcm',
            $key,
            OPENSSL_RAW_DATA,
            $iv = random_bytes(12),
            $tag
        );
    }
    
    private function calculateComplianceScore(
        \DateTimeInterface $from,
        \DateTimeInterface $to
    ): ComplianceScore {
        $totalActions = DB::table('compliance_actions')
            ->whereBetween('performed_at', [$from, $to])
            ->count();
        
        $timelyActions = DB::table('compliance_actions')
            ->whereBetween('performed_at', [$from, $to])
            ->where('completed_within_sla', true)
            ->count();
        
        $score = $totalActions > 0 ? ($timelyActions / $totalActions) * 100 : 100;
        
        return new ComplianceScore(
            score: round($score, 1),
            tier: match(true) {
                $score >= 95 => 'excellent',
                $score >= 85 => 'good',
                $score >= 70 => 'fair',
                default => 'needs_improvement'
            },
            metrics: [
                'total_actions' => $totalActions,
                'timely_actions' => $timelyActions,
                'sla_violations' => $totalActions - $timelyActions
            ]
        );
    }
}
```

---

## **5. MULTI-PLATFORM INTEGRATION**

```php
<?php
// app/Contexts/DigitalCard/Infrastructure/Integrations/DigitalWalletIntegration.php

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\Integrations;

use App\Contexts\DigitalCard\Domain\Entities\DigitalCard;
use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use GuzzleHttp\Client;
use GuzzleHttp\Promise\PromiseInterface;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

/**
 * Apple Wallet & Google Wallet Integration
 * 
 * Features:
 * 1. PKPass generation for Apple Wallet
 * 2. Google Pay pass classes
 * 3. Push notification updates
 * 4. Pass revocation and updates
 */
final class DigitalWalletIntegration
{
    private Client $httpClient;
    private array $config;
    
    public function __construct()
    {
        $this->httpClient = new Client([
            'timeout' => 10,
            'connect_timeout' => 5,
        ]);
        
        $this->config = config('digitalcard.wallet_integration');
    }
    
    /**
     * Generate Apple Wallet PKPass
     */
    public function generateAppleWalletPass(DigitalCard $card): AppleWalletPass
    {
        // 1. Create pass structure
        $pass = [
            'formatVersion' => 1,
            'teamIdentifier' => $this->config['apple']['team_id'],
            'passTypeIdentifier' => $this->config['apple']['pass_type_id'],
            'serialNumber' => $card->id()->toString(),
            'webServiceURL' => $this->config['apple']['web_service_url'],
            'authenticationToken' => $this->generateAuthToken($card),
            'organizationName' => $this->getOrganizationName(),
            'description' => 'Digital Membership Card',
            'logoText' => 'Member Card',
            'foregroundColor' => 'rgb(255, 255, 255)',
            'backgroundColor' => 'rgb(0, 100, 200)',
            'locations' => $this->getCardLocations($card),
            'barcode' => [
                'format' => 'PKBarcodeFormatQR',
                'message' => $card->qrCode()->toString(),
                'messageEncoding' => 'iso-8859-1',
            ],
            'storeCard' => [
                'primaryFields' => [
                    [
                        'key' => 'member_name',
                        'label' => 'MEMBER',
                        'value' => $this->getMemberName($card->memberId())
                    ]
                ],
                'secondaryFields' => [
                    [
                        'key' => 'card_id',
                        'label' => 'CARD ID',
                        'value' => substr($card->id()->toString(), 0, 8)
                    ],
                    [
                        'key' => 'expires',
                        'label' => 'EXPIRES',
                        'value' => $card->expiresAt()->format('M d, Y')
                    ]
                ],
                'auxiliaryFields' => [
                    [
                        'key' => 'status',
                        'label' => 'STATUS',
                        'value' => strtoupper($card->status()->value)
                    ]
                ],
                'backFields' => [
                    [
                        'key' => 'terms',
                        'label' => 'TERMS & CONDITIONS',
                        'value' => $this->getTermsAndConditions()
                    ]
                ]
            ]
        ];
        
        // 2. Sign pass with Apple certificate
        $signedPass = $this->signPass($pass);
        
        // 3. Register pass with Apple Push Notification service
        $this->registerPassWithApple($signedPass, $card);
        
        return new AppleWalletPass(
            passData: $signedPass,
            serialNumber: $card->id()->toString(),
            passTypeIdentifier: $this->config['apple']['pass_type_id'],
            webServiceUrl: $this->config['apple']['web_service_url'],
            authenticationToken: $pass['authenticationToken']
        );
    }
    
    /**
     * Generate Google Pay Pass
     */
    public function generateGooglePayPass(DigitalCard $card): GooglePayPass
    {
        $classId = "{$this->config['google']['issuer_id']}.{$card->id()}";
        
        $pass = [
            'id' => $classId,
            'classId' => $classId,
            'genericClass' => [
                'id' => $classId,
                'issuerName' => $this->getOrganizationName(),
                'reviewStatus' => 'UNDER_REVIEW',
                'hexBackgroundColor' => '#0064C8',
                'logo' => [
                    'sourceUri' => [
                        'uri' => $this->config['google']['logo_uri']
                    ]
                ],
                'cardTitle' => [
                    'defaultValue' => [
                        'language' => 'en',
                        'value' => 'Digital Membership Card'
                    ]
                ],
                'header' => [
                    'defaultValue' => [
                        'language' => 'en',
                        'value' => $this->getMemberName($card->memberId())
                    ]
                ],
                'barcode' => [
                    'type' => 'QR_CODE',
                    'value' => $card->qrCode()->toString(),
                    'alternateText' => 'Scan for validation'
                ],
                'heroImage' => [
                    'sourceUri' => [
                        'uri' => $this->config['google']['hero_image_uri']
                    ]
                ],
                'textModulesData' => [
                    [
                        'header' => 'CARD ID',
                        'body' => substr($card->id()->toString(), 0, 8),
                        'id' => 'card_id'
                    ],
                    [
                        'header' => 'EXPIRES',
                        'body' => $card->expiresAt()->format('M d, Y'),
                        'id' => 'expiry'
                    ],
                    [
                        'header' => 'STATUS',
                        'body' => strtoupper($card->status()->value),
                        'id' => 'status'
                    ]
                ],
                'linksModuleData' => [
                    'uris' => [
                        [
                            'uri' => $this->config['google']['terms_uri'],
                            'description' => 'Terms & Conditions'
                        ]
                    ]
                ]
            ]
        ];
        
        // Save to Google Wallet API
        $response = $this->saveToGoogleWallet($pass);
        
        return new GooglePayPass(
            classId: $classId,
            objectId: $response['id'],
            saveUrl: $response['saveUrl'],
            status: $response['status']
        );
    }
    
    /**
     * Send push notification for pass update
     */
    public function sendPassUpdate(
        DigitalCard $card,
        string $updateType = 'generic'
    ): PromiseInterface {
        $deviceTokens = $this->getRegisteredDeviceTokens($card);
        
        if (empty($deviceTokens)) {
            return \GuzzleHttp\Promise\rejection_for('No registered devices');
        }
        
        $promises = [];
        
        foreach ($deviceTokens as $platform => $tokens) {
            foreach (array_chunk($tokens, 100) as $chunk) {
                $promises[] = match($platform) {
                    'apple' => $this->sendApplePushNotification($chunk, $card, $updateType),
                    'google' => $this->sendGooglePushNotification($chunk, $card, $updateType),
                    default => null
                };
            }
        }
        
        return \GuzzleHttp\Promise\all($promises);
    }
    
    /**
     * Revoke pass from all wallets
     */
    public function revokePass(DigitalCard $card): RevocationReport
    {
        $report = new RevocationReport(cardId: $card->id());
        
        // 1. Notify Apple Wallet
        try {
            $this->notifyAppleOfRevocation($card);
            $report->addSuccess('apple_wallet');
        } catch (\Exception $e) {
            $report->addFailure('apple_wallet', $e->getMessage());
        }
        
        // 2. Notify Google Wallet
        try {
            $this->notifyGoogleOfRevocation($card);
            $report->addSuccess('google_wallet');
        } catch (\Exception $e) {
            $report->addFailure('google_wallet', $e->getMessage());
        }
        
        // 3. Update local registry
        $this->updatePassRegistry($card, 'revoked');
        
        return $report;
    }
    
    /**
     * Handle wallet webhook (push token registration, pass updates)
     */
    public function handleWebhook(string $platform, array $payload): WebhookResponse
    {
        return match($platform) {
            'apple' => $this->handleAppleWebhook($payload),
            'google' => $this->handleGoogleWebhook($payload),
            default => throw new \InvalidArgumentException("Unsupported platform: {$platform}")
        };
    }
    
    /**
     * Get wallet integration metrics
     */
    public function getMetrics(): WalletMetrics
    {
        $applePasses = DB::table('wallet_passes')
            ->where('platform', 'apple')
            ->count();
        
        $googlePasses = DB::table('wallet_passes')
            ->where('platform', 'google')
            ->count();
        
        return new WalletMetrics(
            totalPasses: $applePasses + $googlePasses,
            byPlatform: [
                'apple' => $applePasses,
                'google' => $googlePasses
            ],
            activePasses: DB::table('wallet_passes')
                ->where('status', 'active')
                ->count(),
            lastWeekRegistrations: DB::table('wallet_passes')
                ->where('created_at', '>=', now()->subWeek())
                ->count(),
            pushSuccessRate: $this->calculatePushSuccessRate(),
            averageUpdateLatency: $this->calculateAverageUpdateLatency()
        );
    }
    
    private function signPass(array $passData): string
    {
        // Load Apple WWDR certificate and signing key
        $certPath = storage_path($this->config['apple']['cert_path']);
        $keyPath = storage_path($this->config['apple']['key_path']);
        
        // Create manifest
        $manifest = [];
        foreach ($passData as $key => $value) {
            if (is_string($value)) {
                $manifest[$key] = hash('sha1', $value);
            }
        }
        
        // Sign manifest
        openssl_pkcs7_sign(
            $manifestFile = tempnam(sys_get_temp_dir(), 'manifest'),
            $signedFile = tempnam(sys_get_temp_dir(), 'signed'),
            file_get_contents($certPath),
            [file_get_contents($keyPath), $this->config['apple']['key_password']],
            $manifest,
            PKCS7_BINARY | PKCS7_DETACHED,
            $this->config['apple']['wwdr_cert_path']
        );
        
        return file_get_contents($signedFile);
    }
    
    private function registerPassWithApple(string $signedPass, DigitalCard $card): void
    {
        $response = $this->httpClient->post($this->config['apple']['registration_url'], [
            'json' => [
                'deviceLibraryIdentifier' => $this->generateDeviceLibraryId(),
                'pushToken' => $this->generatePushToken(),
                'passTypeIdentifier' => $this->config['apple']['pass_type_id'],
                'serialNumber' => $card->id()->toString(),
                'authenticationToken' => $signedPass['authenticationToken']
            ],
            'headers' => [
                'Authorization' => 'ApplePass ' . base64_encode($signedPass)
            ]
        ]);
        
        if ($response->getStatusCode() === 201) {
            DB::table('wallet_passes')->insert([
                'card_id' => $card->id()->toString(),
                'platform' => 'apple',
                'serial_number' => $card->id()->toString(),
                'device_library_id' => $this->generateDeviceLibraryId(),
                'push_token' => $this->generatePushToken(),
                'registered_at' => now(),
                'status' => 'active'
            ]);
        }
    }
    
    // ... other private methods
}
```

---

## **üìä PHASE 4 DEPLOYMENT STRATEGY**

### **Rollout Plan**
```yaml
# phase4-rollout.yaml
phases:
  week_1_2:
    - feature: guest_cards
      scope: beta_users
      rollout: 10%
      metrics:
        - guest_card_issuance_rate
        - validation_success_rate
        - sponsor_satisfaction
        
  week_3_4:
    - feature: offline_validation
      scope: low_connectivity_regions
      rollout: 25%
      metrics:
        - offline_bundle_downloads
        - offline_validation_success
        - bandwidth_savings
        
  week_5_6:
    - feature: real_time_projections
      scope: admin_users
      rollout: 100%
      metrics:
        - dashboard_load_time
        - data_freshness
        - user_engagement
        
  week_7_8:
    - feature: wallet_integration
      scope: early_adopters
      rollout: 5%
      metrics:
        - wallet_pass_registrations
        - push_notification_success
        - user_feedback
```

### **Monitoring Dashboard Additions**
```php
// New dashboard metrics for Phase 4
return [
    'guest_cards' => [
        'issued_today' => GuestCard::whereDate('created_at', today())->count(),
        'active_guests' => GuestCard::where('status', 'active')->count(),
        'average_duration_days' => GuestCard::where('status', 'expired')
            ->selectRaw('AVG(DATEDIFF(expires_at, created_at)) as avg_days')
            ->value('avg_days'),
        'top_sponsors' => DB::table('guest_cards')
            ->select('sponsor_member_id', DB::raw('COUNT(*) as count'))
            ->groupBy('sponsor_member_id')
            ->orderByDesc('count')
            ->limit(5)
            ->get()
    ],
    
    'offline_system' => [
        'active_bundles' => ValidationBundle::where('valid_until', '>', now())->count(),
        'offline_validations' => DB::table('offline_validations')->whereDate('created_at', today())->count(),
        'bundle_hit_rate' => $this->calculateBundleHitRate(),
        'bandwidth_saved_mb' => $this->calculateBandwidthSavings(),
    ],
    
    'wallet_integration' => [
        'apple_passes' => WalletPass::where('platform', 'apple')->count(),
        'google_passes' => WalletPass::where('platform', 'google')->count(),
        'push_success_rate' => $this->calculatePushSuccessRate(),
        'pass_update_latency_ms' => $this->calculatePassUpdateLatency(),
    ]
];
```

### **Disaster Recovery for Phase 4 Features**
```bash
#!/bin/bash
# phase4-disaster-recovery.sh

# 1. Backup guest card data
mysqldump -u root -p digitalcard_guest_cards > /backup/guest_cards_$(date +%Y%m%d).sql

# 2. Backup offline bundles
aws s3 sync /var/www/storage/app/offline-bundles s3://backup/offline-bundles/

# 3. Export wallet pass registry
php artisan wallet:export-registry --format=json --output=/backup/wallet_registry.json

# 4. Backup compliance data (encrypted)
openssl enc -aes-256-cbc -salt -in /var/www/storage/app/compliance -out /backup/compliance_encrypted.enc -pass pass:$ENCRYPTION_KEY

# 5. Verify backups
echo "üîç Verifying backups..."
find /backup -name "*.sql" -exec mysqldump --no-data {} \; > /dev/null
aws s3 ls s3://backup/offline-bundles/ | wc -l
```

---

## **üéØ SUCCESS CRITERIA FOR PHASE 4**

| Metric | Target | Business Impact |
|--------|--------|-----------------|
| **Guest Card Adoption** | > 15% of members issue guest cards | New revenue stream, increased engagement |
| **Offline Validation Success** | > 95% success rate | Operational resilience in low-connectivity areas |
| **Dashboard Load Time** | < 2 seconds P95 | Better admin experience, faster decisions |
| **Wallet Pass Registrations** | > 20% of active cards | Increased member convenience, brand visibility |
| **Compliance Audit Pass Rate** | 100% | Regulatory compliance, trust building |
| **System Scalability** | 10x current load | Future-proof architecture |

---

## **üîß TECHNICAL DEBT ADDRESSED IN PHASE 4**

1. **Database Optimization**
   - Partitioned tables for time-series data
   - Read replicas for dashboard queries
   - Connection pooling for high concurrency

2. **Cache Strategy**
   - Multi-level caching (Redis + in-memory)
   - Cache warming for offline bundles
   - Intelligent cache invalidation

3. **Security Hardening**
   - Hardware Security Module (HSM) integration for keys
   - Advanced rate limiting per feature
   - Real-time threat detection

4. **Observability**
   - Distributed tracing across all features
   - Business metrics aggregation
   - Predictive alerting

---

## **üöÄ LAUNCH CHECKLIST**

- [ ] **Guest Cards**: Beta testing with 10% of users
- [ ] **Offline Validation**: Deployed to 2 pilot regions
- [ ] **Real-time Dashboard**: Available to all admins
- [ ] **Wallet Integration**: Early access program launched
- [ ] **Compliance Framework**: Audited and approved
- [ ] **Documentation**: Complete API docs and user guides
- [ ] **Training**: Admin and support team trained
- [ ] **Monitoring**: Dashboards and alerts configured
- [ ] **Rollback Plan**: Tested and documented
- [ ] **Post-Launch Support**: 24/7 coverage for first week

---

**Phase 4 completes the DigitalCardContext evolution** from a simple digital card system to a **comprehensive digital identity platform** with enterprise features, multi-platform support, and production-grade resilience. Each feature justifies the bounded context separation and provides tangible business value while maintaining the architectural integrity established in previous phases.

The system is now ready for **global deployment, enterprise customers, and regulatory compliance** while providing an exceptional experience for both administrators and end-users.