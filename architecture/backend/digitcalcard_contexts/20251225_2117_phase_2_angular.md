# **DIGITALCARD CONTEXT - PHASE 2 IMPLEMENTATION KICKOFF**

## **ðŸš€ IMMEDIATE START: CRITICAL FILES FOR PHASE 2**

I'll generate the most critical files to get Phase 2 started immediately. We'll begin with the **backend foundation** since the mobile API must exist before the Angular app can consume it.

### **1. MOBILE API FOUNDATION - SANCTUM INTEGRATION**

```php
<?php
// app/Contexts/DigitalCard/Infrastructure/Services/MemberResolver.php
// CRITICAL: Tenant-scoped member resolution for mobile API

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\Services;

use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use App\Contexts\Membership\Domain\Repositories\MemberRepositoryInterface;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\App;

/**
 * Mobile Member Resolution with Tenant Isolation
 * 
 * SECURITY PRINCIPLE: Mobile tokens must resolve to tenant-specific MemberId
 * without exposing user_id cross-tenant.
 */
final class MemberResolver
{
    private const CACHE_TTL = 300; // 5 minutes
    private const CACHE_PREFIX = 'mobile_member:';
    
    public function __construct(
        private MemberRepositoryInterface $memberRepository
    ) {}
    
    /**
     * Resolve MemberId from Sanctum token with tenant verification
     * 
     * @throws \RuntimeException When no authenticated user
     * @throws \DomainException When member not found or tenant mismatch
     */
    public function resolveFromAuth(): MemberId
    {
        $sanctumUser = Auth::guard('sanctum')->user();
        
        if (!$sanctumUser) {
            throw new \RuntimeException('No authenticated mobile user');
        }
        
        $cacheKey = self::CACHE_PREFIX . $sanctumUser->id . ':' . $this->getTenantIdentifier();
        
        return Cache::remember($cacheKey, self::CACHE_TTL, function () use ($sanctumUser) {
            // 1. Get the user ID from Sanctum token
            $userId = $sanctumUser->getKey();
            
            // 2. Find member for this user IN CURRENT TENANT CONTEXT
            $member = $this->memberRepository->findByUserId($userId);
            
            if (!$member) {
                Log::warning('Member resolution failed - no member for user', [
                    'user_id' => $userId,
                    'tenant' => $this->getTenantIdentifier()
                ]);
                
                throw new \DomainException(
                    'User is not associated with a member in this tenant'
                );
            }
            
            // 3. VERIFY TENANT MEMBERSHIP (Security Critical)
            $this->verifyTenantMembership($member);
            
            // 4. Return MemberId Value Object
            return $member->getId();
        });
    }
    
    /**
     * SECURITY: Verify member belongs to current tenant
     * Prevents cross-tenant access via token hijacking
     */
    private function verifyTenantMembership($member): void
    {
        $currentTenant = App::make('currentTenant');
        
        if (!$currentTenant) {
            throw new \RuntimeException('No active tenant context');
        }
        
        if ($member->getTenantId() !== $currentTenant->id) {
            Log::critical('TENANT MISMATCH DETECTED', [
                'member_tenant_id' => $member->getTenantId(),
                'current_tenant_id' => $currentTenant->id,
                'member_id' => $member->getId()->toString(),
                'user_id' => Auth::id()
            ]);
            
            throw new \DomainException(
                'Security violation: Member does not belong to current tenant'
            );
        }
    }
    
    /**
     * Clear cached member resolution (logout/token refresh)
     */
    public function clearCache(string $userId): void
    {
        $cacheKey = self::CACHE_PREFIX . $userId . ':' . $this->getTenantIdentifier();
        Cache::forget($cacheKey);
    }
    
    private function getTenantIdentifier(): string
    {
        $tenant = App::make('currentTenant');
        return $tenant ? $tenant->slug : 'no-tenant';
    }
}
```

```php
<?php
// app/Contexts/DigitalCard/Application/Queries/GetMemberCardQuery.php
// Query Object Pattern for mobile card retrieval

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Application\Queries;

use App\Contexts\DigitalCard\Domain\Entities\DigitalCard;
use App\Contexts\DigitalCard\Domain\Repositories\DigitalCardRepository;
use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;

final class GetMemberCardQuery
{
    public function __construct(
        private DigitalCardRepository $repository
    ) {}
    
    /**
     * Get active card for a member
     */
    public function execute(MemberId $memberId): ?DigitalCard
    {
        $cards = $this->repository->byMember($memberId);
        
        // Find active card (business logic: only one active card per member)
        foreach ($cards as $card) {
            if ($card->status()->isValid()) { // Using enum method
                return $card;
            }
        }
        
        return null;
    }
    
    /**
     * Get all cards for member (history)
     */
    public function executeHistory(MemberId $memberId): array
    {
        return $this->repository->byMember($memberId);
    }
}
```

```php
<?php
// app/Contexts/DigitalCard/Infrastructure/Http/Controllers/Mobile/MobileCardController.php
// Mobile API Controller (Case 2: /{tenant}/mapi/v1/*)

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\Http\Controllers\Mobile;

use App\Contexts\DigitalCard\Application\Queries\GetMemberCardQuery;
use App\Contexts\DigitalCard\Domain\ValueObjects\CardId;
use App\Contexts\DigitalCard\Infrastructure\Http\Requests\Mobile\ValidateCardRequest;
use App\Contexts\DigitalCard\Infrastructure\Http\Resources\Mobile\MobileCardResource;
use App\Contexts\DigitalCard\Infrastructure\Services\MemberResolver;
use Illuminate\Http\JsonResponse;
use Illuminate\Routing\Controller;
use Illuminate\Support\Facades\Log;

final class MobileCardController extends Controller
{
    public function __construct(
        private GetMemberCardQuery $getMemberCardQuery,
        private MemberResolver $memberResolver
    ) {
        // Mobile-specific middleware
        $this->middleware('log.mobile.activity');
    }
    
    /**
     * GET /{tenant}/mapi/v1/my-card
     * Mobile API: Get authenticated member's active card
     */
    public function getMyCard(): JsonResponse
    {
        try {
            // SECURITY: Resolve member from token (tenant-scoped)
            $memberId = $this->memberResolver->resolveFromAuth();
            
            Log::info('Mobile card request', [
                'member_id' => $memberId->toString(),
                'tenant' => app('currentTenant')->slug
            ]);
            
            $card = $this->getMemberCardQuery->execute($memberId);
            
            if (!$card) {
                return response()->json([
                    'data' => null,
                    'meta' => [
                        'has_card' => false,
                        'message' => 'No active digital card found',
                        'action' => 'contact_committee'
                    ]
                ]);
            }
            
            return response()->json([
                'data' => new MobileCardResource($card),
                'meta' => [
                    'has_card' => true,
                    'cache_ttl' => 300, // 5 minutes
                    'offline_supported' => true,
                    'qr_expires_at' => now()->addDay()->toISOString()
                ]
            ]);
            
        } catch (\DomainException $e) {
            Log::warning('Member resolution failed in mobile API', [
                'error' => $e->getMessage()
            ]);
            
            return response()->json([
                'error' => 'member_resolution_failed',
                'message' => 'Unable to identify member. Please log in again.'
            ], 401);
            
        } catch (\Exception $e) {
            Log::error('Mobile card API error', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            
            return response()->json([
                'error' => 'server_error',
                'message' => 'Unable to retrieve card. Please try again.'
            ], 503);
        }
    }
    
    /**
     * POST /{tenant}/mapi/v1/cards/{card}/validate
     * Mobile API: Validate a card (for check-in)
     */
    public function validateCard(ValidateCardRequest $request, string $cardId): JsonResponse
    {
        try {
            $memberId = $this->memberResolver->resolveFromAuth();
            
            // Extract context from request
            $context = $request->toValidationContext();
            
            // TODO: Implement validation service
            $validationService = app(\App\Contexts\DigitalCard\Domain\Services\CardValidationService::class);
            
            $result = $validationService->validate(
                CardId::fromString($cardId),
                $memberId,
                $context
            );
            
            // Log validation for audit trail
            Log::info('Card validation via mobile', [
                'card_id' => $cardId,
                'validator_member_id' => $memberId->toString(),
                'valid' => $result->isValid(),
                'reason' => $result->getReason(),
                'location' => $context->getLocation(),
                'device_id' => $context->getDeviceId()
            ]);
            
            return response()->json([
                'valid' => $result->isValid(),
                'card' => $result->isValid() ? new MobileCardResource($result->getCard()) : null,
                'reason' => $result->getReason(),
                'timestamp' => now()->toISOString(),
                'validation_id' => $result->getValidationId()
            ]);
            
        } catch (\InvalidArgumentException $e) {
            return response()->json([
                'valid' => false,
                'reason' => 'invalid_card_id',
                'message' => $e->getMessage()
            ], 400);
        }
    }
    
    /**
     * GET /{tenant}/mapi/v1/my-card/history
     * Mobile API: Get card history
     */
    public function getCardHistory(): JsonResponse
    {
        $memberId = $this->memberResolver->resolveFromAuth();
        
        $cards = $this->getMemberCardQuery->executeHistory($memberId);
        
        return response()->json([
            'data' => MobileCardResource::collection($cards),
            'meta' => [
                'total' => count($cards),
                'active_count' => count(array_filter($cards, fn($c) => $c->status()->isValid()))
            ]
        ]);
    }
}
```

### **2. MOBILE API ROUTES (CASE 2)**

```php
<?php
// routes/tenant/mapi.digitalcard.php
// Case 2: /{tenant}/mapi/v1/* - Mobile-specific routes

declare(strict_types=1);

use App\Contexts\DigitalCard\Infrastructure\Http\Controllers\Mobile\MobileCardController;
use Illuminate\Support\Facades\Route;

Route::prefix('{tenant}/mapi/v1')
    ->middleware([
        'tenant.resolve',      // REQUIRED: Identify tenant from URL
        'auth:sanctum',       // REQUIRED: Mobile token authentication
        'throttle:60,1',      // Security: 60 requests per minute
        'log.api',            // Logging: All mobile API calls
    ])
    ->name('mobile.digitalcard.')
    ->group(function () {
        
        // Member's own card operations
        Route::prefix('my-card')->group(function () {
            // GET /{tenant}/mapi/v1/my-card
            Route::get('/', [MobileCardController::class, 'getMyCard'])
                ->name('my-card');
            
            // GET /{tenant}/mapi/v1/my-card/history
            Route::get('/history', [MobileCardController::class, 'getCardHistory'])
                ->name('history');
        });
        
        // Card validation operations
        Route::prefix('cards')->group(function () {
            // POST /{tenant}/mapi/v1/cards/{card}/validate
            Route::post('/{card}/validate', [MobileCardController::class, 'validateCard'])
                ->name('validate')
                ->where('card', '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}');
        });
        
        // Health check for mobile app
        Route::get('/health', function () {
            return response()->json([
                'status' => 'ok',
                'timestamp' => now()->toISOString(),
                'service' => 'digital-card-mobile-api',
                'tenant' => app('currentTenant')->slug
            ]);
        })->name('health');
        
        // Feature flags for mobile app
        Route::get('/features', function () {
            return response()->json([
                'offline_mode' => config('features.digital_card.offline_mode', false),
                'qr_auto_refresh' => config('features.digital_card.qr_auto_refresh', true),
                'biometric_auth' => config('features.digital_card.biometric_auth', false),
                'push_notifications' => config('features.digital_card.push_notifications', true),
            ]);
        })->name('features');
    });

// IMPORTANT: Register this route file in your RouteServiceProvider
// Add to the loadRoutesForCase2() method
```

### **3. MOBILE-SPECIFIC REQUEST VALIDATION**

```php
<?php
// app/Contexts/DigitalCard/Infrastructure/Http/Requests/Mobile/ValidateCardRequest.php

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\Http\Requests\Mobile;

use App\Contexts\DigitalCard\Domain\ValueObjects\ValidationContext;
use Illuminate\Foundation\Http\FormRequest;

/**
 * Mobile API validation request
 * Includes mobile-specific context (location, device info)
 */
final class ValidateCardRequest extends FormRequest
{
    public function authorize(): bool
    {
        // Already authorized by Sanctum middleware
        return true;
    }
    
    public function rules(): array
    {
        return [
            'location.latitude' => ['nullable', 'numeric', 'between:-90,90'],
            'location.longitude' => ['nullable', 'numeric', 'between:-180,180'],
            'device_id' => ['nullable', 'string', 'max:100'],
            'scan_method' => ['nullable', 'in:qr_scan,manual_entry,nfc'],
            'notes' => ['nullable', 'string', 'max:500'],
        ];
    }
    
    public function messages(): array
    {
        return [
            'location.latitude.between' => 'Latitude must be between -90 and 90',
            'location.longitude.between' => 'Longitude must be between -180 and 180',
            'scan_method.in' => 'Scan method must be qr_scan, manual_entry, or nfc',
        ];
    }
    
    /**
     * Convert to ValidationContext Value Object
     */
    public function toValidationContext(): ValidationContext
    {
        $location = null;
        if ($this->has('location.latitude') && $this->has('location.longitude')) {
            $location = [
                'latitude' => (float) $this->input('location.latitude'),
                'longitude' => (float) $this->input('location.longitude'),
            ];
        }
        
        return new ValidationContext(
            location: $location,
            deviceId: $this->input('device_id'),
            scanMethod: $this->input('scan_method', 'qr_scan'),
            notes: $this->input('notes'),
            timestamp: now()
        );
    }
}
```

### **4. MOBILE-SPECIFIC API RESOURCES**

```php
<?php
// app/Contexts/DigitalCard/Infrastructure/Http/Resources/Mobile/MobileCardResource.php
// Mobile-optimized API response

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Infrastructure\Http\Resources\Mobile;

use App\Contexts\DigitalCard\Domain\Entities\DigitalCard;
use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

/** @mixin DigitalCard */
final class MobileCardResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     * Mobile API gets LIMITED information for security
     */
    public function toArray(Request $request): array
    {
        return [
            // Identification
            'id' => $this->id()->toString(),
            'member_id' => $this->memberId()->toString(),
            
            // Status
            'status' => $this->status()->value,
            'status_display' => $this->getStatusDisplay(),
            
            // QR Code
            'qr_code' => $this->qrCode()->toString(),
            'qr_code_type' => 'uuid', // Phase 3: 'signed'
            
            // Dates
            'issued_at' => $this->issuedAt()->format(\DateTimeInterface::ATOM),
            'expires_at' => $this->expiresAt()->format(\DateTimeInterface::ATOM),
            'activated_at' => $this->activatedAt()?->format(\DateTimeInterface::ATOM),
            
            // Metadata
            'is_valid' => $this->status()->isValid(),
            'days_until_expiry' => $this->getDaysUntilExpiry(),
            'can_refresh_qr' => $this->canRefreshQR(),
            
            // Security notice
            '_security' => [
                'note' => 'QR codes should be refreshed periodically',
                'qr_expiry_hours' => 24
            ]
        ];
    }
    
    /**
     * Add metadata to response
     */
    public function with(Request $request): array
    {
        return [
            'meta' => [
                'api_version' => '1.0',
                'response_format' => 'mobile',
                'cache_control' => 'private, max-age=300',
                'generated_at' => now()->toISOString(),
            ]
        ];
    }
    
    private function getStatusDisplay(): string
    {
        return match($this->status()->value) {
            'active' => 'Active',
            'issued' => 'Issued (Pending Activation)',
            'revoked' => 'Revoked',
            'expired' => 'Expired',
            default => 'Unknown'
        };
    }
    
    private function getDaysUntilExpiry(): int
    {
        $now = new \DateTimeImmutable();
        $expiry = $this->expiresAt();
        
        if ($now >= $expiry) {
            return 0;
        }
        
        $diff = $now->diff($expiry);
        return (int) $diff->format('%a');
    }
    
    private function canRefreshQR(): bool
    {
        // Business rule: Can refresh QR if card is active
        // and QR was issued more than 12 hours ago
        if (!$this->status()->isValid()) {
            return false;
        }
        
        $twelveHoursAgo = (new \DateTimeImmutable())->modify('-12 hours');
        return $this->issuedAt() < $twelveHoursAgo;
    }
}
```

### **5. CRITICAL TEST FOR MOBILE API**

```php
<?php
// tests/Feature/Contexts/DigitalCard/Mobile/MobileCardApiTest.php
// TDD: Write this test FIRST

declare(strict_types=1);

namespace Tests\Feature\Contexts\DigitalCard\Mobile;

use App\Contexts\DigitalCard\Domain\Entities\DigitalCard;
use App\Contexts\DigitalCard\Domain\ValueObjects\CardId;
use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use App\Contexts\Membership\Domain\Entities\Member;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Laravel\Sanctum\Sanctum;
use Tests\TestCase;

/**
 * PHASE 2 CRITICAL TESTS
 * Tests mobile API endpoints with tenant isolation
 */
class MobileCardApiTest extends TestCase
{
    use RefreshDatabase;
    
    private $tenant;
    private $member;
    private $token;
    
    protected function setUp(): void
    {
        parent::setUp();
        
        // Setup tenant context (mocking your tenancy setup)
        $this->tenant = \App\Models\Tenant::factory()->create([
            'slug' => 'test-tenant-mobile'
        ]);
        
        $this->tenant->makeCurrent();
        
        // Create a member in this tenant
        $this->member = Member::factory()->for($this->tenant)->create();
        
        // Create Sanctum token for mobile auth
        $user = $this->member->getUser();
        $this->token = $user->createToken('mobile-test')->plainTextToken;
    }
    
    /** @test */
    public function mobile_api_returns_members_active_card(): void
    {
        // Given: Member has an active digital card
        $card = DigitalCard::issue(
            CardId::generate(),
            $this->member->getId(),
            \App\Contexts\DigitalCard\Domain\ValueObjects\QRCode::fromString('qr:test'),
            new \DateTimeImmutable(),
            new \DateTimeImmutable('+1 year')
        );
        
        $card->activate(new \DateTimeImmutable());
        
        // Save to repository
        $repository = app(\App\Contexts\DigitalCard\Domain\Repositories\DigitalCardRepository::class);
        $repository->save($card);
        
        // When: Calling mobile API with Sanctum token
        $response = $this->withHeaders([
            'Authorization' => 'Bearer ' . $this->token,
            'Accept' => 'application/json',
        ])->get("/{$this->tenant->slug}/mapi/v1/my-card");
        
        // Then: Should return the card
        $response->assertOk();
        $response->assertJsonStructure([
            'data' => [
                'id', 'status', 'qr_code', 'issued_at', 'expires_at'
            ],
            'meta' => [
                'has_card', 'cache_ttl'
            ]
        ]);
        
        $this->assertEquals($card->id()->toString(), $response->json('data.id'));
        $this->assertEquals('active', $response->json('data.status'));
    }
    
    /** @test */
    public function mobile_api_returns_null_when_no_card(): void
    {
        // When: Member has no digital card
        $response = $this->withHeaders([
            'Authorization' => 'Bearer ' . $this->token,
        ])->get("/{$this->tenant->slug}/mapi/v1/my-card");
        
        // Then: Should return null with appropriate meta
        $response->assertOk();
        $response->assertJson([
            'data' => null,
            'meta' => [
                'has_card' => false,
                'message' => 'No active digital card found'
            ]
        ]);
    }
    
    /** @test */
    public function mobile_api_rejects_invalid_tenant(): void
    {
        // Given: Different tenant
        $otherTenant = \App\Models\Tenant::factory()->create(['slug' => 'other-tenant']);
        
        // When: Trying to access other tenant's endpoint
        $response = $this->withHeaders([
            'Authorization' => 'Bearer ' . $this->token,
        ])->get("/{$otherTenant->slug}/mapi/v1/my-card");
        
        // Then: Should be unauthorized (different tenant context)
        $response->assertUnauthorized();
    }
    
    /** @test */
    public function mobile_api_validates_card(): void
    {
        // Given: Active card
        $card = DigitalCard::issue(
            CardId::generate(),
            $this->member->getId(),
            \App\Contexts\DigitalCard\Domain\ValueObjects\QRCode::fromString('qr:test'),
            new \DateTimeImmutable(),
            new \DateTimeImmutable('+1 year')
        );
        $card->activate(new \DateTimeImmutable());
        
        $repository = app(\App\Contexts\DigitalCard\Domain\Repositories\DigitalCardRepository::class);
        $repository->save($card);
        
        // When: Validating the card
        $response = $this->withHeaders([
            'Authorization' => 'Bearer ' . $this->token,
        ])->postJson("/{$this->tenant->slug}/mapi/v1/cards/{$card->id()}/validate", [
            'device_id' => 'test-device-123',
            'scan_method' => 'qr_scan'
        ]);
        
        // Then: Should return validation result
        $response->assertOk();
        $response->assertJsonStructure([
            'valid', 'reason', 'timestamp', 'validation_id'
        ]);
        
        $this->assertTrue($response->json('valid'));
    }
    
    /** @test */
    public function mobile_api_returns_card_history(): void
    {
        // Given: Multiple cards (active and historical)
        $activeCard = DigitalCard::issue(
            CardId::generate(),
            $this->member->getId(),
            \App\Contexts\DigitalCard\Domain\ValueObjects\QRCode::fromString('qr:active'),
            new \DateTimeImmutable('-1 month'),
            new \DateTimeImmutable('+11 months')
        );
        $activeCard->activate(new \DateTimeImmutable());
        
        $expiredCard = DigitalCard::issue(
            CardId::generate(),
            $this->member->getId(),
            \App\Contexts\DigitalCard\Domain\ValueObjects\QRCode::fromString('qr:expired'),
            new \DateTimeImmutable('-1 year'),
            new \DateTimeImmutable('-6 months')
        );
        
        $repository = app(\App\Contexts\DigitalCard\Domain\Repositories\DigitalCardRepository::class);
        $repository->save($activeCard);
        $repository->save($expiredCard);
        
        // When: Getting card history
        $response = $this->withHeaders([
            'Authorization' => 'Bearer ' . $this->token,
        ])->get("/{$this->tenant->slug}/mapi/v1/my-card/history");
        
        // Then: Should return all cards
        $response->assertOk();
        $response->assertJsonCount(2, 'data');
        
        $data = $response->json('data');
        $this->assertCount(2, $data);
        $this->assertEquals('active', $data[0]['status']);
        $this->assertEquals('expired', $data[1]['status']);
    }
}
```

### **6. ANGULAR MOBILE SERVICE - IMMEDIATE START**

```typescript
// src/app/core/services/digital-card.service.ts
// Angular Service for Mobile API Consumption

import { Injectable, Inject, PLATFORM_ID } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { Observable, BehaviorSubject, throwError, from } from 'rxjs';
import { map, tap, catchError, switchMap, shareReplay } from 'rxjs/operators';
import { isPlatformBrowser } from '@angular/common';

export interface MobileCard {
  id: string;
  member_id: string;
  status: 'issued' | 'active' | 'revoked' | 'expired';
  status_display: string;
  qr_code: string;
  issued_at: string;
  expires_at: string;
  activated_at?: string;
  is_valid: boolean;
  days_until_expiry: number;
  can_refresh_qr: boolean;
}

export interface ValidationResult {
  valid: boolean;
  card?: MobileCard;
  reason?: string;
  timestamp: string;
  validation_id: string;
}

@Injectable({
  providedIn: 'root'
})
export class DigitalCardService {
  private currentCard = new BehaviorSubject<MobileCard | null>(null);
  private currentTenant: string | null = null;
  private cacheTime = 5 * 60 * 1000; // 5 minutes
  private lastFetchTime = 0;
  
  constructor(
    private http: HttpClient,
    @Inject(PLATFORM_ID) private platformId: Object
  ) {
    this.loadCachedCard();
  }
  
  /**
   * Set current tenant (called after tenant selection)
   */
  setTenant(tenantSlug: string): void {
    this.currentTenant = tenantSlug;
    this.clearCache(); // Clear cache when tenant changes
  }
  
  /**
   * Get current member's card
   */
  getMyCard(forceRefresh = false): Observable<MobileCard | null> {
    if (!this.currentTenant) {
      return throwError(() => new Error('No tenant selected'));
    }
    
    // Check cache first (unless forced refresh)
    const now = Date.now();
    if (!forceRefresh && 
        this.currentCard.value && 
        (now - this.lastFetchTime) < this.cacheTime) {
      return this.currentCard.asObservable();
    }
    
    const url = `/${this.currentTenant}/mapi/v1/my-card`;
    const headers = this.getAuthHeaders();
    
    return this.http.get<{ data: MobileCard | null; meta: any }>(url, { headers }).pipe(
      map(response => response.data),
      tap(card => {
        this.currentCard.next(card);
        this.lastFetchTime = Date.now();
        if (card && isPlatformBrowser(this.platformId)) {
          this.cacheCard(card);
        }
      }),
      catchError(error => {
        // Fallback to cached card
        const cached = this.getCachedCard();
        if (cached) {
          this.currentCard.next(cached);
          return from([cached]);
        }
        return throwError(() => error);
      }),
      shareReplay(1)
    );
  }
  
  /**
   * Validate a card
   */
  validateCard(cardId: string, context?: any): Observable<ValidationResult> {
    if (!this.currentTenant) {
      return throwError(() => new Error('No tenant selected'));
    }
    
    const url = `/${this.currentTenant}/mapi/v1/cards/${cardId}/validate`;
    const headers = this.getAuthHeaders();
    
    const payload = {
      device_id: this.getDeviceId(),
      scan_method: context?.method || 'qr_scan',
      timestamp: new Date().toISOString(),
      ...context
    };
    
    return this.http.post<ValidationResult>(url, payload, { headers }).pipe(
      tap(result => {
        if (result.valid && result.card) {
          this.currentCard.next(result.card);
        }
      })
    );
  }
  
  /**
   * Get card history
   */
  getCardHistory(): Observable<MobileCard[]> {
    if (!this.currentTenant) {
      return throwError(() => new Error('No tenant selected'));
    }
    
    const url = `/${this.currentTenant}/mapi/v1/my-card/history`;
    const headers = this.getAuthHeaders();
    
    return this.http.get<{ data: MobileCard[] }>(url, { headers }).pipe(
      map(response => response.data)
    );
  }
  
  /**
   * Watch for card updates
   */
  watchCard(): Observable<MobileCard | null> {
    return this.currentCard.asObservable();
  }
  
  /**
   * Clear cache
   */
  clearCache(): void {
    this.currentCard.next(null);
    this.lastFetchTime = 0;
    if (isPlatformBrowser(this.platformId)) {
      localStorage.removeItem('digital_card_cache');
    }
  }
  
  // Private helpers
  private getAuthHeaders(): HttpHeaders {
    const token = this.getAuthToken();
    return new HttpHeaders({
      'Authorization': `Bearer ${token}`,
      'Accept': 'application/json',
      'X-Device-ID': this.getDeviceId()
    });
  }
  
  private getAuthToken(): string {
    // Get from your auth service
    if (isPlatformBrowser(this.platformId)) {
      return localStorage.getItem('auth_token') || '';
    }
    return '';
  }
  
  private getDeviceId(): string {
    if (isPlatformBrowser(this.platformId)) {
      let deviceId = localStorage.getItem('device_id');
      if (!deviceId) {
        deviceId = 'web_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('device_id', deviceId);
      }
      return deviceId;
    }
    return 'server';
  }
  
  private cacheCard(card: MobileCard): void {
    if (isPlatformBrowser(this.platformId)) {
      const cache = {
        card,
        cached_at: Date.now(),
        tenant: this.currentTenant
      };
      localStorage.setItem('digital_card_cache', JSON.stringify(cache));
    }
  }
  
  private getCachedCard(): MobileCard | null {
    if (isPlatformBrowser(this.platformId)) {
      const cached = localStorage.getItem('digital_card_cache');
      if (cached) {
        const { card, cached_at, tenant } = JSON.parse(cached);
        if (tenant === this.currentTenant && 
            (Date.now() - cached_at) < this.cacheTime) {
          return card;
        }
      }
    }
    return null;
  }
  
  private loadCachedCard(): void {
    const cached = this.getCachedCard();
    if (cached) {
      this.currentCard.next(cached);
    }
  }
}
```

### **7. ANGULAR INTERCEPTOR FOR MOBILE API**

```typescript
// src/app/core/interceptors/mobile-api.interceptor.ts

import { Injectable } from '@angular/core';
import {
  HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpErrorResponse
} from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Router } from '@angular/router';
import { AuthService } from '../services/auth.service';

@Injectable()
export class MobileApiInterceptor implements HttpInterceptor {
  
  constructor(
    private authService: AuthService,
    private router: Router
  ) {}
  
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Only intercept /mapi/ calls
    if (!req.url.includes('/mapi/')) {
      return next.handle(req);
    }
    
    // Add mobile-specific headers
    const mobileReq = req.clone({
      setHeaders: {
        'X-Mobile-App': 'true',
        'X-App-Version': '1.0.0'
      }
    });
    
    return next.handle(mobileReq).pipe(
      catchError((error: HttpErrorResponse) => {
        return this.handleMobileError(error, req);
      })
    );
  }
  
  private handleMobileError(error: HttpErrorResponse, req: HttpRequest<any>): Observable<HttpEvent<any>> {
    switch (error.status) {
      case 401: // Unauthorized
        this.authService.logout();
        this.router.navigate(['/login']);
        break;
        
      case 403: // Forbidden (tenant access issue)
        this.router.navigate(['/tenant-select']);
        break;
        
      case 404: // Card not found
        if (req.url.includes('/my-card')) {
          // Card not found is expected - handle in component
          console.log('Card not found for member');
        }
        break;
        
      case 429: // Rate limited
        console.warn('Rate limited, please slow down');
        break;
    }
    
    return throwError(() => error);
  }
}
```

---

## **ðŸš€ IMMEDIATE ACTION PLAN**

### **Step 1: Run the Tests (RED Phase)**
```bash
# Run the mobile API tests (they should fail)
php artisan test --filter=MobileCardApiTest

# You'll see errors about missing:
# 1. MemberResolver service
# 2. MobileCardController
# 3. Mobile API routes
# 4. ValidationContext Value Object
```

### **Step 2: Create Missing Domain Objects**
```bash
# Create ValidationContext Value Object
php artisan make:value-object ValidationContext --context=DigitalCard

# Create CardValidationService
php artisan make:domain-service CardValidationService --context=DigitalCard
```

### **Step 3: Implement Minimum Viable Backend**
1. Copy the `MemberResolver.php` to your `Infrastructure/Services` folder
2. Copy the `MobileCardController.php` to `Infrastructure/Http/Controllers/Mobile/`
3. Create the `mapi.digitalcard.php` route file
4. Register it in your RouteServiceProvider's `loadRoutesForCase2()` method

### **Step 4: Create Angular Service**
1. Create the `DigitalCardService` in your Angular project
2. Add the `MobileApiInterceptor` to your app module
3. Start building the card display component

### **Step 5: Test the Flow**
```bash
# Generate a Sanctum token for testing
php artisan tinker
>>> $user = User::first();
>>> $token = $user->createToken('mobile-test')->plainTextToken;
>>> echo $token;

# Test the API with curl
curl -H "Authorization: Bearer YOUR_TOKEN" \
     -H "Accept: application/json" \
     https://your-app.com/test-tenant/mapi/v1/my-card
```

---

## **ðŸ”§ CONFIGURATION NEEDED**

Add to your Laravel config:

```php
// config/features.php
return [
    'digital_card' => [
        'mobile' => [
            'cache_ttl' => env('MOBILE_CARD_CACHE_TTL', 300),
            'rate_limit' => env('MOBILE_RATE_LIMIT', 60),
            'offline_mode' => env('MOBILE_OFFLINE_MODE', true),
        ],
    ],
];

// config/sanctum.php (ensure mobile settings)
'stateful' => explode(',', env('SANCTUM_STATEFUL_DOMAINS', sprintf(
    '%s%s',
    'localhost,localhost:3000,127.0.0.1,127.0.0.1:8000,::1',
    env('APP_URL') ? ','.parse_url(env('APP_URL'), PHP_URL_HOST) : ''
))),
```

---

## **âœ… PHASE 2 IMMEDIATE CHECKLIST**

- [ ] **Backend**: MemberResolver service created
- [ ] **Backend**: MobileCardController implemented  
- [ ] **Backend**: Mobile API routes registered (Case 2)
- [ ] **Backend**: ValidationContext Value Object created
- [ ] **Tests**: MobileCardApiTest running (RED â†’ GREEN)
- [ ] **Angular**: DigitalCardService created
- [ ] **Angular**: MobileApiInterceptor registered
- [ ] **Security**: Sanctum tokens working with tenant isolation
- [ ] **Routing**: `/mapi/v1/` endpoints accessible with tenant prefix

---

## **ðŸ“± NEXT: ANGULAR COMPONENTS**

Once the backend API is working (tests passing), I'll generate:

1. **Card Display Component** - Shows QR code and card info
2. **QR Scanner Component** - Camera integration for validation
3. **Validation History Component** - List of past validations
4. **Offline Mode Service** - Local storage and sync

**Which part would you like me to generate next?** The Angular components or more backend services (like the CardValidationService)?