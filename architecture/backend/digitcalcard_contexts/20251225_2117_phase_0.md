# **DIGITALCARD CONTEXT DEVELOPMENT KICKOFF**  
**Phase 0: Foundation & "Walking Skeleton"**  
*Architectural Implementation by Senior Backend Developer (15+ years experience)*

## **1. TDD FIRST: The Failing Test (RED Phase)**

```php
<?php
// tests/Contexts/DigitalCard/Feature/DigitalCardWalkingSkeletonTest.php

declare(strict_types=1);

namespace Tests\Contexts\DigitalCard\Feature;

use App\Contexts\DigitalCard\Domain\ValueObjects\CardId;
use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Event;
use Tests\TestCase;

/**
 * PHASE 0 WALKING SKELETON TEST
 * Validates the full stack integration before complex logic.
 * 
 * @group digitalcard
 * @group phase0
 */
final class DigitalCardWalkingSkeletonTest extends TestCase
{
    use RefreshDatabase;

    protected function setUp(): void
    {
        parent::setUp();
        
        // CRITICAL: This test MUST run against tenant database
        // Your tenancy bootstrap should handle this automatically
        $this->markTestSucceededIfTenantConnectionActive();
    }

    /** 
     * THE ULTIMATE WALKING SKELETON TEST
     * This single test validates our entire architectural foundation:
     * 1. Route recognition (Case 4: /{tenant}/api/v1/cards)
     * 2. Controller → Handler → Repository flow
     * 3. Tenant database isolation
     * 4. Domain Event publication
     * 5. Proper HTTP response format
     */
    public function test_creates_digital_card_record_via_desktop_api(): void
    {
        // ARRANGE: Prepare tenant context and admin user
        $tenant = $this->createTestTenant('digitalcard-tenant');
        $admin = $this->createPlatformAdminForTenant($tenant);
        
        $this->actingAs($admin);
        
        // Mock the QR generator to avoid external dependencies in Phase 0
        $this->app->bind('digitalcard.qr', fn() => fn(string $id) => "qr:test:$id");
        
        $payload = [
            'member_id' => '550e8400-e29b-41d4-a716-446655440000',
            'expires_at' => now()->addYear()->toISOString(),
        ];

        // Spy on events to verify domain behavior
        Event::fake();

        // ACT: Make the API call - This is Case 4 routing
        $response = $this->postJson("/{$tenant->slug}/api/v1/cards", $payload);

        // ASSERT: The Walking Skeleton must walk
        $response->assertCreated();
        
        // 1. Verify response structure matches our API contract
        $response->assertJsonStructure([
            'data' => [
                'card_id',
                'member_id', 
                'status',
                'issued_at',
                'expires_at',
                'qrcode',
            ]
        ]);
        
        // 2. Verify database record exists in CORRECT tenant database
        $this->assertTenantDatabaseHas('digital_cards', [
            'member_id' => $payload['member_id'],
            'status' => 'issued',
        ]);
        
        // 3. Verify we did NOT leak to landlord database
        $this->assertLandlordDatabaseMissing('digital_cards');
        
        // 4. Verify domain event was published
        Event::assertDispatched(\App\Contexts\DigitalCard\Domain\Events\CardIssued::class);
        
        // 5. Verify the aggregate root invariants via repository
        $json = $response->json('data');
        $cardId = CardId::fromString($json['card_id']);
        $memberId = MemberId::fromString($json['member_id']);
        
        $repository = app(\App\Contexts\DigitalCard\Domain\Repositories\DigitalCardRepository::class);
        $aggregate = $repository->byId($cardId);
        
        $this->assertNotNull($aggregate, 'Aggregate should be retrievable from repository');
        $this->assertTrue($memberId->toString() === $aggregate->memberId()->toString());
    }
    
    /**
     * INTEGRITY TEST: Ensure tenant isolation is absolute
     * This test is CRITICAL for multi-tenant systems
     */
    public function test_prevents_cross_tenant_card_access(): void
    {
        // Create two isolated tenants
        $tenantA = $this->createTestTenant('tenant-a');
        $tenantB = $this->createTestTenant('tenant-b');
        
        $adminA = $this->createPlatformAdminForTenant($tenantA);
        $adminB = $this->createPlatformAdminForTenant($tenantB);
        
        // Create card in Tenant A
        $this->actingAs($adminA);
        $responseA = $this->postJson("/{$tenantA->slug}/api/v1/cards", [
            'member_id' => 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
            'expires_at' => now()->addYear()->toISOString(),
        ]);
        
        $cardIdA = $responseA->json('data.card_id');
        
        // Attempt to access same card ID from Tenant B
        $this->actingAs($adminB);
        $responseB = $this->getJson("/{$tenantB->slug}/api/v1/cards/{$cardIdA}");
        
        // MUST return 404 - Tenant B should have no knowledge of Tenant A's data
        $responseB->assertNotFound();
        
        // Double-check: Query Tenant B's database directly
        $this->assertTenantDatabaseMissing('digital_cards', ['id' => $cardIdA], $tenantB);
    }
    
    /**
     * VALIDATION TEST: Ensure business invariants are enforced
     * This is where DDD starts to show value
     */
    public function test_rejects_invalid_expiry_date(): void
    {
        $tenant = $this->createTestTenant('test-tenant');
        $admin = $this->createPlatformAdminForTenant($tenant);
        
        $this->actingAs($admin);
        
        $payload = [
            'member_id' => '550e8400-e29b-41d4-a716-446655440000',
            'expires_at' => now()->subDay()->toISOString(), // EXPIRY IN PAST - SHOULD FAIL
        ];
        
        $response = $this->postJson("/{$tenant->slug}/api/v1/cards", $payload);
        
        // Should be 422 Unprocessable Entity - Business rule violation
        $response->assertUnprocessable();
        $response->assertJsonValidationErrors(['expires_at']);
    }
    
    private function createTestTenant(string $slug)
    {
        // Use your existing tenant factory
        // This is a CRITICAL pattern - never use production tenants for tests
        return \App\Models\Tenant::factory()->create(['slug' => $slug]);
    }
    
    private function createPlatformAdminForTenant($tenant)
    {
        // Use your existing admin factory with proper tenant scoping
        return \App\Models\User::factory()->create([
            'tenant_id' => $tenant->id,
            'is_platform_admin' => true,
        ]);
    }
    
    private function markTestSucceededIfTenantConnectionActive()
    {
        // This is a safety check - if tenancy isn't bootstrapped, tests give false positives
        if (!app()->bound('currentTenant')) {
            $this->markTestSkipped('Tenancy not bootstrapped for tests');
        }
    }
}
```

## **2. DOMAIN LAYER: Pure Business Logic (No Dependencies)**

```php
<?php
// app/Contexts/DigitalCard/Domain/Entities/DigitalCard.php

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Domain\Entities;

use App\Contexts\DigitalCard\Domain\Enums\CardStatus;
use App\Contexts\DigitalCard\Domain\Events\CardIssued;
use App\Contexts\DigitalCard\Domain\ValueObjects\CardId;
use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use App\Contexts\DigitalCard\Domain\ValueObjects\QRCode;
use DateTimeImmutable;

/**
 * AGGREGATE ROOT: DigitalCard
 * 
 * Key Design Decisions:
 * 1. Immutable after creation except via defined command methods
 * 2. All business invariants encapsulated here
 * 3. Value Objects used for all properties (no primitives)
 * 4. Events are the only way to observe state changes
 * 
 * @package App\Contexts\DigitalCard\Domain\Entities
 */
final class DigitalCard
{
    /**
     * Domain Events collected during this aggregate's lifecycle
     * @var array<object>
     */
    private array $domainEvents = [];
    
    /**
     * Private constructor - use named constructors
     */
    private function __construct(
        private CardId $cardId,
        private MemberId $memberId,
        private QRCode $qrCode,
        private DateTimeImmutable $issuedAt,
        private DateTimeImmutable $expiresAt,
        private CardStatus $status = CardStatus::ISSUED,
        private ?DateTimeImmutable $activatedAt = null,
        private ?DateTimeImmutable $revokedAt = null,
        private ?string $revocationReason = null,
    ) {
        // Post-construction invariant validation
        $this->assertExpiryAfterIssue();
    }
    
    /**
     * FACTORY METHOD: Issue new card
     * This is the ONLY way to create a valid DigitalCard
     * 
     * @param CardId $cardId
     * @param MemberId $memberId
     * @param QRCode $qrCode
     * @param DateTimeImmutable $issuedAt
     * @param DateTimeImmutable $expiresAt
     * @return self
     * @throws \InvalidArgumentException
     */
    public static function issue(
        CardId $cardId,
        MemberId $memberId,
        QRCode $qrCode,
        DateTimeImmutable $issuedAt,
        DateTimeImmutable $expiresAt
    ): self {
        // Business Rule: Expiry must be after issue date
        if ($expiresAt <= $issuedAt) {
            throw new \InvalidArgumentException(
                'Card expiry date must be after issue date'
            );
        }
        
        $card = new self(
            cardId: $cardId,
            memberId: $memberId,
            qrCode: $qrCode,
            issuedAt: $issuedAt,
            expiresAt: $expiresAt,
            status: CardStatus::ISSUED
        );
        
        // Record domain event
        $card->recordThat(new CardIssued(
            cardId: $cardId->toString(),
            memberId: $memberId->toString(),
            issuedAt: $issuedAt,
            expiresAt: $expiresAt
        ));
        
        return $card;
    }
    
    /**
     * BUSINESS METHOD: Activate an issued card
     * 
     * @param DateTimeImmutable $activatedAt
     * @return void
     * @throws \DomainException
     */
    public function activate(DateTimeImmutable $activatedAt): void
    {
        // Business Rule: Only issued cards can be activated
        if (!$this->status->equals(CardStatus::ISSUED)) {
            throw new \DomainException(
                sprintf('Cannot activate card with status: %s', $this->status->value)
            );
        }
        
        $this->status = CardStatus::ACTIVE;
        $this->activatedAt = $activatedAt;
    }
    
    /**
     * BUSINESS METHOD: Revoke a card
     * 
     * @param string $reason
     * @param DateTimeImmutable $revokedAt
     * @return void
     * @throws \DomainException
     */
    public function revoke(string $reason, DateTimeImmutable $revokedAt): void
    {
        // Business Rule: Only issued or active cards can be revoked
        $allowedStatuses = [CardStatus::ISSUED, CardStatus::ACTIVE];
        if (!in_array($this->status, $allowedStatuses, true)) {
            throw new \DomainException(
                sprintf('Cannot revoke card with status: %s', $this->status->value)
            );
        }
        
        // Business Rule: Reason must be provided
        if (empty(trim($reason))) {
            throw new \InvalidArgumentException('Revocation reason is required');
        }
        
        $this->status = CardStatus::REVOKED;
        $this->revokedAt = $revokedAt;
        $this->revocationReason = $reason;
    }
    
    /**
     * DOMAIN SERVICE METHOD: Check if card is valid at given time
     * This is a pure function with no side effects
     * 
     * @param DateTimeImmutable $atTime
     * @return bool
     */
    public function isValidAt(DateTimeImmutable $atTime): bool
    {
        return $this->status->equals(CardStatus::ACTIVE) 
            && $atTime >= $this->issuedAt
            && $atTime < $this->expiresAt;
    }
    
    /**
     * DOMAIN SERVICE METHOD: Auto-expire if needed
     * This demonstrates how aggregates can handle time-based events
     * 
     * @param DateTimeImmutable $currentTime
     * @return void
     */
    public function checkExpiry(DateTimeImmutable $currentTime): void
    {
        if ($this->status->equals(CardStatus::ACTIVE) 
            && $currentTime >= $this->expiresAt) {
            $this->status = CardStatus::EXPIRED;
        }
    }
    
    /**
     * INVARIANT: Expiry must be after issue
     * @return void
     * @throws \DomainException
     */
    private function assertExpiryAfterIssue(): void
    {
        if ($this->expiresAt <= $this->issuedAt) {
            throw new \DomainException(
                'Card invariant violated: expiry must be after issue date'
            );
        }
    }
    
    /**
     * EVENT SOURCING: Record a domain event
     * 
     * @param object $event
     * @return void
     */
    private function recordThat(object $event): void
    {
        $this->domainEvents[] = $event;
    }
    
    /**
     * EVENT SOURCING: Release and clear recorded events
     * 
     * @return array<object>
     */
    public function releaseEvents(): array
    {
        $events = $this->domainEvents;
        $this->domainEvents = [];
        return $events;
    }
    
    /**
     * PERSISTENCE: Reconstitute from storage (for repositories)
     * NOTE: This should ONLY be used by repositories
     * 
     * @internal
     */
    public static function reconstitute(
        CardId $cardId,
        MemberId $memberId,
        QRCode $qrCode,
        DateTimeImmutable $issuedAt,
        DateTimeImmutable $expiresAt,
        CardStatus $status,
        ?DateTimeImmutable $activatedAt,
        ?DateTimeImmutable $revokedAt,
        ?string $revocationReason
    ): self {
        $card = new self(
            cardId: $cardId,
            memberId: $memberId,
            qrCode: $qrCode,
            issuedAt: $issuedAt,
            expiresAt: $expiresAt,
            status: $status,
            activatedAt: $activatedAt,
            revokedAt: $revokedAt,
            revocationReason: $revocationReason
        );
        
        // Clear any events that might have been recorded during reconstitution
        $card->domainEvents = [];
        
        return $card;
    }
    
    // ==================== GETTERS (DOMAIN INTERFACE ONLY) ====================
    
    public function id(): CardId
    {
        return $this->cardId;
    }
    
    public function memberId(): MemberId
    {
        return $this->memberId;
    }
    
    public function qrCode(): QRCode
    {
        return $this->qrCode;
    }
    
    public function status(): CardStatus
    {
        return $this->status;
    }
    
    public function issuedAt(): DateTimeImmutable
    {
        return $this->issuedAt;
    }
    
    public function expiresAt(): DateTimeImmutable
    {
        return $this->expiresAt;
    }
    
    public function activatedAt(): ?DateTimeImmutable
    {
        return $this->activatedAt;
    }
    
    public function revokedAt(): ?DateTimeImmutable
    {
        return $this->revokedAt;
    }
    
    public function revocationReason(): ?string
    {
        return $this->revocationReason;
    }
}
```

```php
<?php
// app/Contexts/DigitalCard/Domain/Enums/CardStatus.php

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Domain\Enums;

/**
 * VALUE OBJECT: CardStatus
 * 
 * Implements state machine for card lifecycle
 * All transitions are explicit and validated
 */
enum CardStatus: string
{
    case ISSUED = 'issued';
    case ACTIVE = 'active';
    case REVOKED = 'revoked';
    case EXPIRED = 'expired';
    
    /**
     * Check if this status equals another
     */
    public function equals(self $other): bool
    {
        return $this === $other;
    }
    
    /**
     * Get valid transitions from this state
     * 
     * @return array<self>
     */
    public function allowedTransitions(): array
    {
        return match($this) {
            self::ISSUED => [self::ACTIVE, self::REVOKED],
            self::ACTIVE => [self::REVOKED, self::EXPIRED],
            self::REVOKED => [],
            self::EXPIRED => [],
        };
    }
    
    /**
     * Check if transition to target status is allowed
     */
    public function canTransitionTo(self $target): bool
    {
        return in_array($target, $this->allowedTransitions(), true);
    }
    
    /**
     * Check if card is in a valid (usable) state
     */
    public function isValid(): bool
    {
        return $this->equals(self::ACTIVE);
    }
    
    /**
     * Check if card is in a terminal state
     */
    public function isTerminal(): bool
    {
        return $this->equals(self::REVOKED) || $this->equals(self::EXPIRED);
    }
}
```

```php
<?php
// app/Contexts/DigitalCard/Domain/ValueObjects/CardId.php

declare(strict_types=1);

namespace App\Contexts\DigitalCard\Domain\ValueObjects;

use Ramsey\Uuid\Uuid;
use Ramsey\Uuid\UuidInterface;

/**
 * VALUE OBJECT: CardId
 * 
 * Design Principles:
 * 1. Self-validating (invalid UUIDs rejected at creation)
 * 2. Immutable (no setters)
 * 3. Type-safe (prevents primitive obsession)
 * 4. Framework agnostic
 */
final class CardId
{
    private function __construct(
        private string $value
    ) {
        // INVARIANT: Must be valid UUID
        if (!Uuid::isValid($this->value)) {
            throw new \InvalidArgumentException(
                sprintf('Invalid CardId format: %s', $this->value)
            );
        }
    }
    
    /**
     * Factory: Generate new unique ID
     */
    public static function generate(): self
    {
        return new self(Uuid::uuid4()->toString());
    }
    
    /**
     * Factory: From string (for reconstruction)
     */
    public static function fromString(string $value): self
    {
        return new self($value);
    }
    
    /**
     * Convert to string (for persistence/APIs)
     */
    public function toString(): string
    {
        return $this->value;
    }
    
    /**
     * Convert to UUID object (for database if needed)
     */
    public function toUuid(): UuidInterface
    {
        return Uuid::fromString($this->value);
    }
    
    /**
     * Value Object equality
     */
    public function equals(self $other): bool
    {
        return $this->value === $other->value;
    }
    
    /**
     * For collections and arrays
     */
    public function __toString(): string
    {
        return $this->value;
    }
}
```

## **3. PEST CONFIGURATION FOR DDD**

```php
<?php
// tests/Pest.php

declare(strict_types=1);

use App\Contexts\DigitalCard\Domain\ValueObjects\CardId;
use App\Contexts\DigitalCard\Domain\ValueObjects\MemberId;
use Ramsey\Uuid\Uuid;

/*
|--------------------------------------------------------------------------
| PEST CUSTOM HELPERS FOR DDD TESTING
|--------------------------------------------------------------------------
|
| These helpers enforce DDD patterns in tests
|
*/

// VALUE OBJECT HELPERS
function aCardId(): CardId
{
    return CardId::generate();
}

function aCardIdFromString(string $id): CardId
{
    return CardId::fromString($id);
}

function aMemberId(): MemberId
{
    return MemberId::fromString(Uuid::uuid4()->toString());
}

function aMemberIdFromString(string $id): MemberId
{
    return MemberId::fromString($id);
}

// TENANT TESTING HELPERS (CRITICAL FOR MULTI-TENANCY)
function withTenant(string $slug, Closure $callback): void
{
    $originalTenant = app('currentTenant');
    
    try {
        $tenant = \App\Models\Tenant::where('slug', $slug)->firstOrFail();
        app()->instance('currentTenant', $tenant);
        
        // Switch database connection
        config(['database.default' => 'tenant']);
        
        $callback($tenant);
    } finally {
        app()->instance('currentTenant', $originalTenant);
        config(['database.default' => 'landlord']);
    }
}

function assertTenantDatabaseHas(string $table, array $data, $tenant = null): void
{
    $tenant = $tenant ?? app('currentTenant');
    
    if (!$tenant) {
        throw new RuntimeException('No tenant context for database assertion');
    }
    
    // This assumes you have tenant DB connection logic
    \Illuminate\Support\Facades\DB::connection('tenant_' . $tenant->slug)
        ->table($table)
        ->where($data)
        ->first();
        
    expect(true)->toBeTrue(); // Custom assertion would go here
}

// AGGREGATE ASSERTION HELPERS
function assertAggregateValid(DigitalCard $aggregate): void
{
    // Check all invariants
    expect($aggregate->issuedAt())->toBeLessThan($aggregate->expiresAt());
    
    if ($aggregate->status()->isTerminal()) {
        // Terminal states have additional rules
    }
}
```

## **4. PHASE 0 COMPLETION CHECKLIST**

```markdown
# PHASE 0: WALKING SKELETON - COMPLETION CHECKLIST

## TESTS (MUST PASS)
- [ ] `DigitalCardWalkingSkeletonTest::test_creates_digital_card_record_via_desktop_api`
- [ ] `DigitalCardWalkingSkeletonTest::test_prevents_cross_tenant_card_access`
- [ ] `DigitalCardWalkingSkeletonTest::test_rejects_invalid_expiry_date`

## DOMAIN LAYER
- [ ] `DigitalCard` Aggregate Root with `issue()` factory
- [ ] `CardStatus` Enum with state machine logic
- [ ] `CardId`, `MemberId`, `QRCode` Value Objects
- [ ] `CardIssued` Domain Event

## INFRASTRUCTURE SKELETON
- [ ] Tenant database migration (`digital_cards` table)
- [ ] `EloquentDigitalCardRepository` interface implementation
- [ ] `DigitalCardController` with `store()` method
- [ ] Case 4 route: `/{tenant}/api/v1/cards`

## ARCHITECTURAL VALIDATION
- [ ] Database records created ONLY in tenant DB
- [ ] Landlord DB has zero card records
- [ ] Domain Events are properly dispatched
- [ ] Value Objects prevent primitive obsession
- [ ] 6-Case routing respected (Case 4 only in Phase 0)

## NEXT STEPS AFTER GREEN LIGHT
1. Run `php artisan test --filter=DigitalCardWalkingSkeletonTest`
2. All tests should FAIL (RED phase)
3. Implement minimum code to make first test pass
4. Iterate until all Phase 0 tests pass
5. Deploy to development environment for integration testing
```

## **KEY SENIOR ARCHITECT DECISIONS EMBEDDED:**

1. **Aggregate Design**: `DigitalCard` is its own aggregate root, not a child of Member. This allows cards to have their own lifecycle and be referenced by multiple contexts (Membership, Elections, AccessControl).

2. **State Machine**: `CardStatus` enum encapsulates ALL transition logic. Controllers/handlers don't need to know business rules.

3. **Value Object Guards**: Each VO self-validates. Invalid data CANNOT enter the domain.

4. **Multi-Tenancy First**: Tests explicitly validate cross-tenant isolation. This is non-negotiable.

5. **Event-Driven from Day 1**: Even in Phase 0, we publish `CardIssued` event. This sets pattern for eventual event-driven architecture.

6. **Reconstitution Pattern**: The `reconstitute` method is marked `@internal` - only repositories should use it. This protects aggregate invariants.

7. **Pest Helpers**: Domain-specific test helpers make tests more readable and enforce patterns.

**NEXT ACTION**: Run the failing test. Let's see the skeleton try to walk. What's the first error?