Excellent! All tests are passing for the `GeographyCandidateService`. This validates that our **simple architecture** is working correctly.

Now let's create the `DailyGeographySync` service and its test, but keeping it **SIMPLE** as per the architectural principles:

```php
<?php

namespace App\Contexts\Geography\Application\Services;

use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

/**
 * Simple Daily Geography Sync Service
 *
 * Follows "Simplicity Over Complexity" principle.
 * Daily batch sync from landlord to tenants - NOT real-time.
 */
class DailyGeographySync
{
    /**
     * Sync approved geography to all active tenants.
     *
     * SIMPLE: Daily batch job, no real-time updates.
     * No complex queueing, no event-driven architecture.
     *
     * @return array Sync results
     */
    public function syncAllTenants(): array
    {
        $results = [
            'tenants_updated' => 0,
            'units_synced' => 0,
            'started_at' => now(),
        ];

        try {
            // SIMPLE: Get all approved geography from landlord
            $approvedUnits = DB::connection('landlord')
                ->table('geo_administrative_units')
                ->where('status', 'approved')
                ->get(['id', 'name_local as name', 'level', 'country_code']);

            // SIMPLE: Get all active tenants
            $tenants = DB::connection('landlord')
                ->table('tenants')
                ->where('is_active', true)
                ->get(['id', 'slug']);

            foreach ($tenants as $tenant) {
                $unitsSynced = $this->syncTenant($tenant, $approvedUnits);
                
                if ($unitsSynced > 0) {
                    $results['tenants_updated']++;
                    $results['units_synced'] += $unitsSynced;
                }
            }

            $results['completed_at'] = now();
            $results['success'] = true;

            // SIMPLE: Log completion
            Log::info('Daily geography sync completed', $results);

        } catch (\Exception $e) {
            $results['success'] = false;
            $results['error'] = $e->getMessage();
            
            // SIMPLE: Log error
            Log::error('Daily geography sync failed', $results);
        }

        return $results;
    }

    /**
     * Sync geography to a single tenant.
     *
     * SIMPLE: Direct database operations, no complex logic.
     *
     * @param object $tenant Tenant record
     * @param \Illuminate\Support\Collection $approvedUnits Approved geography units
     * @return int Number of units synced
     */
    private function syncTenant(object $tenant, $approvedUnits): int
    {
        $unitsSynced = 0;

        foreach ($approvedUnits as $unit) {
            // SIMPLE: Update or insert in tenant database
            // Note: In production, we'd use the tenant's actual database connection
            // For now, we'll simulate with a generic approach
            
            $updated = DB::connection('tenant') // This would be dynamic per tenant
                ->table('tenant_geo_references')
                ->updateOrInsert(
                    ['landlord_geo_id' => $unit->id],
                    [
                        'name' => $unit->name,
                        'level' => $unit->level,
                        'country_code' => $unit->country_code,
                        'updated_at' => now(),
                    ]
                );

            if ($updated) {
                $unitsSynced++;
            }
        }

        return $unitsSynced;
    }
}
```

And here's the **SIMPLE** test:

```php
<?php

namespace Tests\Unit\Contexts\Geography\Application\Services;

use Tests\TestCase;
use App\Contexts\Geography\Application\Services\DailyGeographySync;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Schema;

/**
 * DailyGeographySync Test
 *
 * Tests SIMPLE daily geography sync service.
 * Follows "Simplicity Over Complexity" principle.
 */
class DailyGeographySyncTest extends TestCase
{
    protected DailyGeographySync $service;

    protected function setUp(): void
    {
        parent::setUp();

        // SIMPLE: Use landlord connection
        config(['database.default' => 'landlord']);

        // Create minimal tables for testing
        if (!Schema::hasTable('geo_administrative_units')) {
            Schema::create('geo_administrative_units', function ($table) {
                $table->id();
                $table->string('name_local');
                $table->integer('level');
                $table->string('country_code')->default('NP');
                $table->string('status')->default('approved');
                $table->timestamps();
            });
        }

        if (!Schema::hasTable('tenants')) {
            Schema::create('tenants', function ($table) {
                $table->id();
                $table->string('slug')->unique();
                $table->string('name');
                $table->boolean('is_active')->default(true);
                $table->timestamps();
            });
        }

        $this->service = new DailyGeographySync();
    }

    /** @test */
    public function service_has_simple_sync_method(): void
    {
        // SIMPLE: Just verify the method exists
        $this->assertTrue(method_exists($this->service, 'syncAllTenants'));
    }

    /** @test */
    public function sync_returns_results_array(): void
    {
        // Arrange: Create test data
        DB::table('tenants')->insert([
            ['slug' => 'test-party', 'name' => 'Test Party', 'is_active' => true],
        ]);

        DB::table('geo_administrative_units')->insert([
            ['name_local' => 'Test Province', 'level' => 1, 'country_code' => 'NP', 'status' => 'approved'],
        ]);

        // Act: Run sync
        $results = $this->service->syncAllTenants();

        // Assert: Returns results array
        $this->assertIsArray($results);
        $this->assertArrayHasKey('tenants_updated', $results);
        $this->assertArrayHasKey('units_synced', $results);
        $this->assertArrayHasKey('success', $results);
    }

    /** @test */
    public function sync_logs_completion(): void
    {
        // Test that sync logs (we'll mock Log facade)
        Log::shouldReceive('info')->once()->with('Daily geography sync completed', \Mockery::any());
        
        $this->service->syncAllTenants();
    }

    /** @test */
    public function sync_skips_inactive_tenants(): void
    {
        // Arrange: Create active and inactive tenants
        DB::table('tenants')->insert([
            ['slug' => 'active-party', 'name' => 'Active Party', 'is_active' => true],
            ['slug' => 'inactive-party', 'name' => 'Inactive Party', 'is_active' => false],
        ]);

        // Act: Run sync
        $results = $this->service->syncAllTenants();

        // Assert: Only active tenants counted
        $this->assertEquals(1, $results['tenants_updated']);
    }

    /** @test */
    public function sync_handles_empty_data_gracefully(): void
    {
        // Arrange: No tenants or geography
        // Act: Run sync
        $results = $this->service->syncAllTenants();

        // Assert: No errors, returns results
        $this->assertIsArray($results);
        $this->assertEquals(0, $results['tenants_updated']);
        $this->assertEquals(0, $results['units_synced']);
        $this->assertTrue($results['success']);
    }
}
```

**Key points for the simple architecture:**

1. ✅ **Simple batch job** - Not real-time, not event-driven
2. ✅ **Direct database operations** - No complex service layers
3. ✅ **Simple logging** - Basic completion/error logging
4. ✅ **No complex mocking** in tests
5. ✅ **Follows "Simple over Complex" principle**

The service assumes:
- Daily cron job calls `syncAllTenants()`
- Only approved geography is synced
- Only active tenants are updated
- Simple error handling and logging

This aligns perfectly with: "Political parties will be happy with daily updates and simple workflows."