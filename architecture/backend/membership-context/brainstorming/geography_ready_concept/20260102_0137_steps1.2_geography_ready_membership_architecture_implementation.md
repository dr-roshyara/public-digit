# üöÄ **STEP 1.2: VALUE OBJECTS IMPLEMENTATION (TDD FIRST)**

## **üìÅ FILE STRUCTURE SETUP**

First, let's create the directory structure:

```bash
# Create Value Objects directories
mkdir -p app/Contexts/Membership/Domain/ValueObjects
mkdir -p tests/Unit/Contexts/Membership/Domain/ValueObjects
```

---

## **1Ô∏è‚É£ MEMBERSHIP NUMBER VALUE OBJECT**

### **Step 1: Write Failing Test (RED Phase)**

```php
<?php

// tests/Unit/Contexts/Membership/Domain/ValueObjects/MembershipNumberTest.php

namespace Tests\Unit\Contexts\Membership\Domain\ValueObjects;

use Tests\TestCase;
use App\Contexts\Membership\Domain\ValueObjects\MembershipNumber;
use App\Contexts\Membership\Domain\Exceptions\InvalidMembershipNumberException;

class MembershipNumberTest extends TestCase
{
    /** @test */
    public function it_creates_valid_membership_number(): void
    {
        $number = new MembershipNumber('UML', '2024', 'F', 123);
        
        $this->assertEquals('UML-2024-F-000123', (string) $number);
        $this->assertEquals('UML', $number->tenantSlug());
        $this->assertEquals(2024, $number->year());
        $this->assertEquals('F', $number->typeCode());
        $this->assertEquals(123, $number->sequence());
    }
    
    /** @test */
    public function it_rejects_invalid_tenant_slug(): void
    {
        $this->expectException(InvalidMembershipNumberException::class);
        $this->expectExceptionMessage('Tenant slug must be 3 uppercase letters');
        
        new MembershipNumber('uml', '2024', 'F', 123);
    }
    
    /** @test */
    public function it_rejects_invalid_year(): void
    {
        $this->expectException(InvalidMembershipNumberException::class);
        $this->expectExceptionMessage('Year must be between 2000 and 2100');
        
        new MembershipNumber('UML', '1999', 'F', 123);
    }
    
    /** @test */
    public function it_rejects_invalid_type_code(): void
    {
        $this->expectException(InvalidMembershipNumberException::class);
        $this->expectExceptionMessage('Type code must be one of: F, Y, S, A');
        
        new MembershipNumber('UML', '2024', 'X', 123);
    }
    
    /** @test */
    public function it_rejects_invalid_sequence(): void
    {
        $this->expectException(InvalidMembershipNumberException::class);
        $this->expectExceptionMessage('Sequence must be between 1 and 999999');
        
        new MembershipNumber('UML', '2024', 'F', 0);
    }
    
    /** @test */
    public function it_can_be_parsed_from_string(): void
    {
        $number = MembershipNumber::fromString('UML-2024-F-000123');
        
        $this->assertEquals('UML', $number->tenantSlug());
        $this->assertEquals(2024, $number->year());
        $this->assertEquals('F', $number->typeCode());
        $this->assertEquals(123, $number->sequence());
    }
    
    /** @test */
    public function it_rejects_invalid_string_format(): void
    {
        $this->expectException(InvalidMembershipNumberException::class);
        $this->expectExceptionMessage('Invalid membership number format');
        
        MembershipNumber::fromString('INVALID-FORMAT');
    }
    
    /** @test */
    public function it_generates_next_sequence(): void
    {
        $number = new MembershipNumber('UML', '2024', 'F', 123);
        $next = $number->nextSequence();
        
        $this->assertEquals('UML-2024-F-000124', (string) $next);
        $this->assertEquals(124, $next->sequence());
    }
    
    /** @test */
    public function it_handles_sequence_overflow(): void
    {
        $this->expectException(InvalidMembershipNumberException::class);
        
        new MembershipNumber('UML', '2024', 'F', 1000000);
    }
    
    /** @test */
    public function it_can_change_tenant_slug(): void
    {
        $number = new MembershipNumber('UML', '2024', 'F', 123);
        $newNumber = $number->withTenantSlug('NCP');
        
        $this->assertEquals('NCP-2024-F-000123', (string) $newNumber);
        $this->assertEquals('NCP', $newNumber->tenantSlug());
    }
    
    /** @test */
    public function it_can_change_membership_type(): void
    {
        $number = new MembershipNumber('UML', '2024', 'F', 123);
        $newNumber = $number->withTypeCode('Y');
        
        $this->assertEquals('UML-2024-Y-000123', (string) $newNumber);
        $this->assertEquals('Y', $newNumber->typeCode());
    }
}
```

**Run test (should fail):**
```bash
php artisan test tests/Unit/Contexts/Membership/Domain/ValueObjects/MembershipNumberTest.php
```

---

### **Step 2: Create Exception**

```php
<?php

// app/Contexts/Membership/Domain/Exceptions/InvalidMembershipNumberException.php

namespace App\Contexts\Membership\Domain\Exceptions;

use Exception;

class InvalidMembershipNumberException extends Exception
{
    public static function invalidFormat(string $number): self
    {
        return new self("Invalid membership number format: {$number}");
    }
    
    public static function invalidTenantSlug(string $slug): self
    {
        return new self("Tenant slug must be 3 uppercase letters, got: {$slug}");
    }
    
    public static function invalidYear(int $year): self
    {
        return new self("Year must be between 2000 and 2100, got: {$year}");
    }
    
    public static function invalidTypeCode(string $code, array $validCodes): self
    {
        return new self(
            sprintf(
                "Type code must be one of: %s, got: %s",
                implode(', ', $validCodes),
                $code
            )
        );
    }
    
    public static function invalidSequence(int $sequence): self
    {
        return new self("Sequence must be between 1 and 999999, got: {$sequence}");
    }
}
```

---

### **Step 3: Implement MembershipNumber (GREEN Phase)**

```php
<?php

// app/Contexts/Membership/Domain/ValueObjects/MembershipNumber.php

namespace App\Contexts\Membership\Domain\ValueObjects;

use App\Contexts\Membership\Domain\Exceptions\InvalidMembershipNumberException;

final class MembershipNumber
{
    private const TYPE_CODES = [
        'F' => 'full',
        'Y' => 'youth', 
        'S' => 'student',
        'A' => 'associate',
    ];
    
    private const FORMAT_REGEX = '/^([A-Z]{3})-(\d{4})-([A-Z])-(\d{6})$/';
    
    private string $tenantSlug;
    private int $year;
    private string $typeCode;
    private int $sequence;
    
    public function __construct(
        string $tenantSlug,
        string $year,
        string $typeCode,
        int $sequence
    ) {
        $this->validateTenantSlug($tenantSlug);
        $this->validateYear($year);
        $this->validateTypeCode($typeCode);
        $this->validateSequence($sequence);
        
        $this->tenantSlug = strtoupper($tenantSlug);
        $this->year = (int) $year;
        $this->typeCode = $typeCode;
        $this->sequence = $sequence;
    }
    
    public static function fromString(string $number): self
    {
        if (!preg_match(self::FORMAT_REGEX, $number, $matches)) {
            throw InvalidMembershipNumberException::invalidFormat($number);
        }
        
        return new self(
            $matches[1], // tenantSlug
            $matches[2], // year
            $matches[3], // typeCode
            (int) $matches[4] // sequence
        );
    }
    
    public function tenantSlug(): string
    {
        return $this->tenantSlug;
    }
    
    public function year(): int
    {
        return $this->year;
    }
    
    public function typeCode(): string
    {
        return $this->typeCode;
    }
    
    public function typeName(): string
    {
        return self::TYPE_CODES[$this->typeCode] ?? 'unknown';
    }
    
    public function sequence(): int
    {
        return $this->sequence;
    }
    
    public function nextSequence(): self
    {
        return new self(
            $this->tenantSlug,
            (string) $this->year,
            $this->typeCode,
            $this->sequence + 1
        );
    }
    
    public function withTenantSlug(string $newSlug): self
    {
        return new self(
            $newSlug,
            (string) $this->year,
            $this->typeCode,
            $this->sequence
        );
    }
    
    public function withTypeCode(string $newTypeCode): self
    {
        return new self(
            $this->tenantSlug,
            (string) $this->year,
            $newTypeCode,
            $this->sequence
        );
    }
    
    public function equals(self $other): bool
    {
        return (string) $this === (string) $other;
    }
    
    public function __toString(): string
    {
        return sprintf(
            '%s-%04d-%s-%06d',
            $this->tenantSlug,
            $this->year,
            $this->typeCode,
            $this->sequence
        );
    }
    
    private function validateTenantSlug(string $slug): void
    {
        if (strlen($slug) !== 3 || !ctype_upper($slug)) {
            throw InvalidMembershipNumberException::invalidTenantSlug($slug);
        }
    }
    
    private function validateYear(string $year): void
    {
        $yearInt = (int) $year;
        if ($yearInt < 2000 || $yearInt > 2100) {
            throw InvalidMembershipNumberException::invalidYear($yearInt);
        }
    }
    
    private function validateTypeCode(string $typeCode): void
    {
        if (!array_key_exists($typeCode, self::TYPE_CODES)) {
            throw InvalidMembershipNumberException::invalidTypeCode(
                $typeCode,
                array_keys(self::TYPE_CODES)
            );
        }
    }
    
    private function validateSequence(int $sequence): void
    {
        if ($sequence < 1 || $sequence > 999999) {
            throw InvalidMembershipNumberException::invalidSequence($sequence);
        }
    }
}
```

**Run test (should pass):**
```bash
php artisan test tests/Unit/Contexts/Membership/Domain/ValueObjects/MembershipNumberTest.php
```

---

## **2Ô∏è‚É£ PERSONAL INFO VALUE OBJECT**

### **Step 1: Write Failing Test**

```php
<?php

// tests/Unit/Contexts/Membership/Domain/ValueObjects/PersonalInfoTest.php

namespace Tests\Unit\Contexts\Membership\Domain\ValueObjects;

use Tests\TestCase;
use App\Contexts\Membership\Domain\ValueObjects\PersonalInfo;
use App\Contexts\Membership\Domain\Exceptions\InvalidPersonalInfoException;

class PersonalInfoTest extends TestCase
{
    /** @test */
    public function it_creates_valid_personal_info(): void
    {
        $info = new PersonalInfo(
            'John Doe',
            'john@example.com',
            '+9779841234567'
        );
        
        $this->assertEquals('John Doe', $info->fullName());
        $this->assertEquals('john@example.com', $info->email());
        $this->assertEquals('+9779841234567', $info->phone());
        $this->assertEquals('John', $info->firstName());
        $this->assertEquals('Doe', $info->lastName());
    }
    
    /** @test */
    public function it_requires_full_name(): void
    {
        $this->expectException(InvalidPersonalInfoException::class);
        $this->expectExceptionMessage('Full name is required');
        
        new PersonalInfo('', 'john@example.com', '+9779841234567');
    }
    
    /** @test */
    public function it_requires_valid_email(): void
    {
        $this->expectException(InvalidPersonalInfoException::class);
        $this->expectExceptionMessage('Invalid email address');
        
        new PersonalInfo('John Doe', 'invalid-email', '+9779841234567');
    }
    
    /** @test */
    public function it_requires_valid_phone(): void
    {
        $this->expectException(InvalidPersonalInfoException::class);
        $this->expectExceptionMessage('Phone number must be in E.164 format');
        
        new PersonalInfo('John Doe', 'john@example.com', '9841234567');
    }
    
    /** @test */
    public function it_can_update_full_name(): void
    {
        $info = new PersonalInfo('John Doe', 'john@example.com', '+9779841234567');
        $updated = $info->withFullName('Jane Smith');
        
        $this->assertEquals('Jane Smith', $updated->fullName());
        $this->assertEquals('john@example.com', $updated->email());
        $this->assertEquals('+9779841234567', $updated->phone());
    }
    
    /** @test */
    public function it_can_update_email(): void
    {
        $info = new PersonalInfo('John Doe', 'john@example.com', '+9779841234567');
        $updated = $info->withEmail('jane@example.com');
        
        $this->assertEquals('John Doe', $updated->fullName());
        $this->assertEquals('jane@example.com', $updated->email());
        $this->assertEquals('+9779841234567', $updated->phone());
    }
    
    /** @test */
    public function it_parses_first_and_last_name(): void
    {
        $info = new PersonalInfo('John Michael Doe', 'john@example.com', '+9779841234567');
        
        $this->assertEquals('John', $info->firstName());
        $this->assertEquals('Doe', $info->lastName());
        $this->assertEquals('John Michael', $info->givenName());
    }
    
    /** @test */
    public function it_handles_single_name(): void
    {
        $info = new PersonalInfo('Madhav', 'madhav@example.com', '+9779841234567');
        
        $this->assertEquals('Madhav', $info->firstName());
        $this->assertEquals('', $info->lastName());
    }
    
    /** @test */
    public function it_normalizes_phone_numbers(): void
    {
        $info = new PersonalInfo('John Doe', 'john@example.com', '+977 984-123-4567');
        
        $this->assertEquals('+9779841234567', $info->phone());
    }
    
    /** @test */
    public function it_can_be_serialized_to_array(): void
    {
        $info = new PersonalInfo('John Doe', 'john@example.com', '+9779841234567');
        
        $expected = [
            'full_name' => 'John Doe',
            'email' => 'john@example.com',
            'phone' => '+9779841234567',
            'first_name' => 'John',
            'last_name' => 'Doe',
        ];
        
        $this->assertEquals($expected, $info->toArray());
    }
}
```

**Run test (should fail):**
```bash
php artisan test tests/Unit/Contexts/Membership/Domain/ValueObjects/PersonalInfoTest.php
```

---

### **Step 2: Create Exception**

```php
<?php

// app/Contexts/Membership/Domain/Exceptions/InvalidPersonalInfoException.php

namespace App\Contexts\Membership\Domain\Exceptions;

use Exception;

class InvalidPersonalInfoException extends Exception
{
    public static function missingFullName(): self
    {
        return new self('Full name is required');
    }
    
    public static function invalidEmail(string $email): self
    {
        return new self("Invalid email address: {$email}");
    }
    
    public static function invalidPhone(string $phone): self
    {
        return new self("Phone number must be in E.164 format: {$phone}");
    }
}
```

---

### **Step 3: Implement PersonalInfo**

```php
<?php

// app/Contexts/Membership/Domain/ValueObjects/PersonalInfo.php

namespace App\Contexts\Membership\Domain\ValueObjects;

use App\Contexts\Membership\Domain\Exceptions\InvalidPersonalInfoException;

final class PersonalInfo
{
    private const E164_REGEX = '/^\+[1-9]\d{1,14}$/';
    
    private string $fullName;
    private string $email;
    private string $phone;
    
    public function __construct(
        string $fullName,
        string $email,
        string $phone
    ) {
        $this->validateFullName($fullName);
        $this->validateEmail($email);
        $this->validatePhone($phone);
        
        $this->fullName = trim($fullName);
        $this->email = strtolower(trim($email));
        $this->phone = $this->normalizePhone($phone);
    }
    
    public function fullName(): string
    {
        return $this->fullName;
    }
    
    public function email(): string
    {
        return $this->email;
    }
    
    public function phone(): string
    {
        return $this->phone;
    }
    
    public function firstName(): string
    {
        $parts = explode(' ', $this->fullName);
        return $parts[0] ?? '';
    }
    
    public function lastName(): string
    {
        $parts = explode(' ', $this->fullName);
        return end($parts) ?? '';
    }
    
    public function givenName(): string
    {
        $parts = explode(' ', $this->fullName);
        array_pop($parts); // Remove last name
        return implode(' ', $parts);
    }
    
    public function withFullName(string $newFullName): self
    {
        return new self(
            $newFullName,
            $this->email,
            $this->phone
        );
    }
    
    public function withEmail(string $newEmail): self
    {
        return new self(
            $this->fullName,
            $newEmail,
            $this->phone
        );
    }
    
    public function withPhone(string $newPhone): self
    {
        return new self(
            $this->fullName,
            $this->email,
            $newPhone
        );
    }
    
    public function toArray(): array
    {
        return [
            'full_name' => $this->fullName,
            'email' => $this->email,
            'phone' => $this->phone,
            'first_name' => $this->firstName(),
            'last_name' => $this->lastName(),
        ];
    }
    
    public function equals(self $other): bool
    {
        return $this->fullName === $other->fullName
            && $this->email === $other->email
            && $this->phone === $other->phone;
    }
    
    public function __toString(): string
    {
        return json_encode($this->toArray());
    }
    
    private function validateFullName(string $fullName): void
    {
        if (empty(trim($fullName))) {
            throw InvalidPersonalInfoException::missingFullName();
        }
    }
    
    private function validateEmail(string $email): void
    {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw InvalidPersonalInfoException::invalidEmail($email);
        }
    }
    
    private function validatePhone(string $phone): void
    {
        $normalized = $this->normalizePhone($phone);
        
        if (!preg_match(self::E164_REGEX, $normalized)) {
            throw InvalidPersonalInfoException::invalidPhone($phone);
        }
    }
    
    private function normalizePhone(string $phone): string
    {
        // Remove all non-digit characters except leading +
        $cleaned = preg_replace('/[^\d\+]/', '', $phone);
        
        // If starts with 0, remove it
        if (str_starts_with($cleaned, '0')) {
            $cleaned = substr($cleaned, 1);
        }
        
        // If starts with 977 (Nepal), add +
        if (str_starts_with($cleaned, '977')) {
            $cleaned = '+' . $cleaned;
        }
        
        // If doesn't start with +, add +977 for Nepal
        if (!str_starts_with($cleaned, '+')) {
            $cleaned = '+977' . $cleaned;
        }
        
        return $cleaned;
    }
}
```

**Run test (should pass):**
```bash
php artisan test tests/Unit/Contexts/Membership/Domain/ValueObjects/PersonalInfoTest.php
```

---

## **3Ô∏è‚É£ SIMPLE GEOGRAPHY VALUE OBJECT (Optional)**

### **Step 1: Write Failing Test**

```php
<?php

// tests/Unit/Contexts/Membership/Domain/ValueObjects/SimpleGeographyTest.php

namespace Tests\Unit\Contexts\Membership\Domain\ValueObjects;

use Tests\TestCase;
use App\Contexts\Membership\Domain\ValueObjects\SimpleGeography;

class SimpleGeographyTest extends TestCase
{
    /** @test */
    public function it_creates_empty_geography(): void
    {
        $geo = SimpleGeography::empty();
        
        $this->assertTrue($geo->isEmpty());
        $this->assertNull($geo->province());
        $this->assertNull($geo->district());
        $this->assertNull($geo->ward());
    }
    
    /** @test */
    public function it_creates_geography_with_text_only(): void
    {
        $geo = new SimpleGeography(
            province: 'Province 3',
            district: 'Kathmandu',
            ward: 'Ward 5'
        );
        
        $this->assertFalse($geo->isEmpty());
        $this->assertEquals('Province 3', $geo->province());
        $this->assertEquals('Kathmandu', $geo->district());
        $this->assertEquals('Ward 5', $geo->ward());
    }
    
    /** @test */
    public function it_creates_partial_geography(): void
    {
        $geo = new SimpleGeography(
            province: 'Province 3',
            district: 'Kathmandu'
            // No ward specified
        );
        
        $this->assertFalse($geo->isEmpty());
        $this->assertEquals('Province 3', $geo->province());
        $this->assertEquals('Kathmandu', $geo->district());
        $this->assertNull($geo->ward());
    }
    
    /** @test */
    public function it_can_upgrade_to_advanced_geography(): void
    {
        $simpleGeo = new SimpleGeography(
            province: 'Province 3',
            district: 'Kathmandu',
            ward: 'Ward 5'
        );
        
        $upgraded = $simpleGeo->withIds(
            provinceId: 3,
            districtId: 25,
            wardId: 125
        );
        
        $this->assertEquals(3, $upgraded->provinceId());
        $this->assertEquals(25, $upgraded->districtId());
        $this->assertEquals(125, $upgraded->wardId());
        $this->assertTrue($upgraded->hasIds());
    }
    
    /** @test */
    public function it_tracks_geography_tier(): void
    {
        $empty = SimpleGeography::empty();
        $this->assertEquals('none', $empty->tier());
        
        $textOnly = new SimpleGeography(province: 'Province 3');
        $this->assertEquals('basic', $textOnly->tier());
        
        $withIds = $textOnly->withIds(provinceId: 3);
        $this->assertEquals('advanced', $withIds->tier());
    }
    
    /** @test */
    public function it_can_be_serialized(): void
    {
        $geo = new SimpleGeography(
            province: 'Province 3',
            district: 'Kathmandu',
            ward: 'Ward 5'
        )->withIds(
            provinceId: 3,
            districtId: 25,
            wardId: 125
        );
        
        $expected = [
            'province' => 'Province 3',
            'district' => 'Kathmandu',
            'ward' => 'Ward 5',
            'province_id' => 3,
            'district_id' => 25,
            'ward_id' => 125,
            'tier' => 'advanced',
        ];
        
        $this->assertEquals($expected, $geo->toArray());
    }
    
    /** @test */
    public function it_can_merge_with_another_geography(): void
    {
        $geo1 = new SimpleGeography(province: 'Province 3');
        $geo2 = new SimpleGeography(district: 'Kathmandu', ward: 'Ward 5');
        
        $merged = $geo1->merge($geo2);
        
        $this->assertEquals('Province 3', $merged->province());
        $this->assertEquals('Kathmandu', $merged->district());
        $this->assertEquals('Ward 5', $merged->ward());
    }
    
    /** @test */
    public function it_prioritizes_non_null_values_during_merge(): void
    {
        $geo1 = new SimpleGeography(province: 'Old Province', district: 'Old District');
        $geo2 = new SimpleGeography(province: 'New Province', ward: 'New Ward');
        
        $merged = $geo1->merge($geo2);
        
        $this->assertEquals('New Province', $merged->province()); // From geo2
        $this->assertEquals('Old District', $merged->district()); // From geo1
        $this->assertEquals('New Ward', $merged->ward()); // From geo2
    }
}
```

**Run test (should fail):**
```bash
php artisan test tests/Unit/Contexts/Membership/Domain/ValueObjects/SimpleGeographyTest.php
```

---

### **Step 2: Implement SimpleGeography**

```php
<?php

// app/Contexts/Membership/Domain/ValueObjects/SimpleGeography.php

namespace App\Contexts\Membership\Domain\ValueObjects;

final class SimpleGeography
{
    private const TIER_NONE = 'none';
    private const TIER_BASIC = 'basic';
    private const TIER_ADVANCED = 'advanced';
    
    private ?string $province;
    private ?string $district;
    private ?string $ward;
    
    private ?int $provinceId;
    private ?int $districtId;
    private ?int $wardId;
    
    private string $tier;
    
    public function __construct(
        ?string $province = null,
        ?string $district = null,
        ?string $ward = null,
        ?int $provinceId = null,
        ?int $districtId = null,
        ?int $wardId = null
    ) {
        $this->province = $province;
        $this->district = $district;
        $this->ward = $ward;
        $this->provinceId = $provinceId;
        $this->districtId = $districtId;
        $this->wardId = $wardId;
        
        $this->determineTier();
    }
    
    public static function empty(): self
    {
        return new self();
    }
    
    public function province(): ?string
    {
        return $this->province;
    }
    
    public function district(): ?string
    {
        return $this->district;
    }
    
    public function ward(): ?string
    {
        return $this->ward;
    }
    
    public function provinceId(): ?int
    {
        return $this->provinceId;
    }
    
    public function districtId(): ?int
    {
        return $this->districtId;
    }
    
    public function wardId(): ?int
    {
        return $this->wardId;
    }
    
    public function tier(): string
    {
        return $this->tier;
    }
    
    public function isEmpty(): bool
    {
        return $this->tier === self::TIER_NONE;
    }
    
    public function hasText(): bool
    {
        return !empty($this->province) || !empty($this->district) || !empty($this->ward);
    }
    
    public function hasIds(): bool
    {
        return $this->provinceId !== null || $this->districtId !== null || $this->wardId !== null;
    }
    
    public function withIds(
        ?int $provinceId = null,
        ?int $districtId = null,
        ?int $wardId = null
    ): self {
        return new self(
            province: $this->province,
            district: $this->district,
            ward: $this->ward,
            provinceId: $provinceId ?? $this->provinceId,
            districtId: $districtId ?? $this->districtId,
            wardId: $wardId ?? $this->wardId
        );
    }
    
    public function withText(
        ?string $province = null,
        ?string $district = null,
        ?string $ward = null
    ): self {
        return new self(
            province: $province ?? $this->province,
            district: $district ?? $this->district,
            ward: $ward ?? $this->ward,
            provinceId: $this->provinceId,
            districtId: $this->districtId,
            wardId: $this->wardId
        );
    }
    
    public function merge(self $other): self
    {
        return new self(
            province: $other->province ?? $this->province,
            district: $other->district ?? $this->district,
            ward: $other->ward ?? $this->ward,
            provinceId: $other->provinceId ?? $this->provinceId,
            districtId: $other->districtId ?? $this->districtId,
            wardId: $other->wardId ?? $this->wardId
        );
    }
    
    public function toArray(): array
    {
        return [
            'province' => $this->province,
            'district' => $this->district,
            'ward' => $this->ward,
            'province_id' => $this->provinceId,
            'district_id' => $this->districtId,
            'ward_id' => $this->wardId,
            'tier' => $this->tier,
        ];
    }
    
    public function equals(self $other): bool
    {
        return $this->toArray() === $other->toArray();
    }
    
    public function __toString(): string
    {
        $parts = [];
        
        if ($this->province) {
            $parts[] = $this->province;
        }
        
        if ($this->district) {
            $parts[] = $this->district;
        }
        
        if ($this->ward) {
            $parts[] = $this->ward;
        }
        
        return $parts ? implode(' ‚Üí ', $parts) : 'No geography';
    }
    
    private function determineTier(): void
    {
        if ($this->hasIds()) {
            $this->tier = self::TIER_ADVANCED;
        } elseif ($this->hasText()) {
            $this->tier = self::TIER_BASIC;
        } else {
            $this->tier = self::TIER_NONE;
        }
    }
}
```

**Run test (should pass):**
```bash
php artisan test tests/Unit/Contexts/Membership/Domain/ValueObjects/SimpleGeographyTest.php
```

---

## **4Ô∏è‚É£ MEMBER STATUS VALUE OBJECT (State Pattern)**

### **Step 1: Write Failing Test**

```php
<?php

// tests/Unit/Contexts/Membership/Domain/ValueObjects/MemberStatusTest.php

namespace Tests\Unit\Contexts\Membership\Domain\ValueObjects;

use Tests\TestCase;
use App\Contexts\Membership\Domain\ValueObjects\MemberStatus;
use App\Contexts\Membership\Domain\Exceptions\InvalidStatusTransitionException;

class MemberStatusTest extends TestCase
{
    /** @test */
    public function it_creates_draft_status(): void
    {
        $status = MemberStatus::draft();
        
        $this->assertEquals('draft', $status->value());
        $this->assertTrue($status->isDraft());
        $this->assertFalse($status->canVote());
        $this->assertFalse($status->canAccessForum());
        $this->assertFalse($status->canHoldOffice());
    }
    
    /** @test */
    public function it_transitions_from_draft_to_pending(): void
    {
        $status = MemberStatus::draft();
        $newStatus = $status->transitionTo('pending');
        
        $this->assertEquals('pending', $newStatus->value());
        $this->assertTrue($newStatus->isPending());
    }
    
    /** @test */
    public function it_rejects_invalid_transition(): void
    {
        $this->expectException(InvalidStatusTransitionException::class);
        
        $status = MemberStatus::draft();
        $status->transitionTo('active'); // Invalid: draft ‚Üí active
    }
    
    /** @test */
    public function active_status_has_full_privileges(): void
    {
        $status = MemberStatus::active();
        
        $this->assertTrue($status->canVote());
        $this->assertTrue($status->canAccessForum());
        $this->assertTrue($status->canHoldOffice());
    }
    
    /** @test */
    public function suspended_status_has_no_privileges(): void
    {
        $status = MemberStatus::suspended();
        
        $this->assertFalse($status->canVote());
        $this->assertFalse($status->canAccessForum());
        $this->assertFalse($status->canHoldOffice());
    }
    
    /** @test */
    public function it_can_check_if_transition_is_allowed(): void
    {
        $status = MemberStatus::draft();
        
        $this->assertTrue($status->canTransitionTo('pending'));
        $this->assertFalse($status->canTransitionTo('active'));
        $this->assertFalse($status->canTransitionTo('suspended'));
    }
    
    /** @test */
    public function it_provides_allowed_transitions(): void
    {
        $status = MemberStatus::draft();
        
        $allowed = $status->allowedTransitions();
        
        $this->assertEquals(['pending'], $allowed);
    }
    
    /** @test */
    public function it_can_be_serialized(): void
    {
        $status = MemberStatus::active();
        
        $data = $status->toArray();
        
        $this->assertEquals('active', $data['value']);
        $this->assertTrue($data['can_vote']);
        $this->assertTrue($data['can_access_forum']);
        $this->assertTrue($data['can_hold_office']);
    }
    
    /** @test */
    public function it_can_be_created_from_string(): void
    {
        $status = MemberStatus::fromString('active');
        
        $this->assertTrue($status->isActive());
    }
    
    /** @test */
    public function it_rejects_invalid_status_string(): void
    {
        $this->expectException(\InvalidArgumentException::class);
        
        MemberStatus::fromString('invalid_status');
    }
    
    /** @test */
    public function it_handles_approval_workflow(): void
    {
        // Draft ‚Üí Pending ‚Üí Approved ‚Üí Active
        $draft = MemberStatus::draft();
        $pending = $draft->transitionTo('pending');
        $approved = $pending->transitionTo('approved');
        $active = $approved->transitionTo('active');
        
        $this->assertEquals('active', $active->value());
    }
    
    /** @test */
    public function it_provides_display_name(): void
    {
        $status = MemberStatus::active();
        
        $this->assertEquals('Active', $status->displayName());
    }
}
```

**Run test (should fail):**
```bash
php artisan test tests/Unit/Contexts/Membership/Domain/ValueObjects/MemberStatusTest.php
```

---

### **Step 2: Create Exception**

```php
<?php

// app/Contexts/Membership/Domain/Exceptions/InvalidStatusTransitionException.php

namespace App\Contexts\Membership\Domain\Exceptions;

use Exception;

class InvalidStatusTransitionException extends Exception
{
    public static function create(string $from, string $to, array $allowed): self
    {
        return new self(
            sprintf(
                "Cannot transition from '%s' to '%s'. Allowed transitions: %s",
                $from,
                $to,
                implode(', ', $allowed)
            )
        );
    }
}
```

---

### **Step 3: Implement MemberStatus**

```php
<?php

// app/Contexts/Membership/Domain/ValueObjects/MemberStatus.php

namespace App\Contexts\Membership\Domain\ValueObjects;

use App\Contexts\Membership\Domain\Exceptions\InvalidStatusTransitionException;

class MemberStatus
{
    const DRAFT = 'draft';
    const PENDING = 'pending';
    const UNDER_REVIEW = 'under_review';
    const APPROVED = 'approved';
    const AWAITING_PAYMENT = 'awaiting_payment';
    const ACTIVE = 'active';
    const SUSPENDED = 'suspended';
    const EXPIRED = 'expired';
    const TERMINATED = 'terminated';
    
    private const VALID_STATUSES = [
        self::DRAFT,
        self::PENDING,
        self::UNDER_REVIEW,
        self::APPROVED,
        self::AWAITING_PAYMENT,
        self::ACTIVE,
        self::SUSPENDED,
        self::EXPIRED,
        self::TERMINATED,
    ];
    
    private const DISPLAY_NAMES = [
        self::DRAFT => 'Draft',
        self::PENDING => 'Pending',
        self::UNDER_REVIEW => 'Under Review',
        self::APPROVED => 'Approved',
        self::AWAITING_PAYMENT => 'Awaiting Payment',
        self::ACTIVE => 'Active',
        self::SUSPENDED => 'Suspended',
        self::EXPIRED => 'Expired',
        self::TERMINATED => 'Terminated',
    ];
    
    private const TRANSITIONS = [
        self::DRAFT => [self::PENDING, self::TERMINATED],
        self::PENDING => [self::UNDER_REVIEW, self::TERMINATED],
        self::UNDER_REVIEW => [self::APPROVED, self::TERMINATED],
        self::APPROVED => [self::AWAITING_PAYMENT],
        self::AWAITING_PAYMENT => [self::ACTIVE, self::SUSPENDED],
        self::ACTIVE => [self::SUSPENDED, self::EXPIRED],
        self::SUSPENDED => [self::ACTIVE, self::TERMINATED],
        self::EXPIRED => [self::ACTIVE, self::TERMINATED],
        self::TERMINATED => [],
    ];
    
    private const PRIVILEGES = [
        self::DRAFT => ['vote' => false, 'forum' => false, 'office' => false],
        self::PENDING => ['vote' => false, 'forum' => false, 'office' => false],
        self::UNDER_REVIEW => ['vote' => false, 'forum' => false, 'office' => false],
        self::APPROVED => ['vote' => false, 'forum' => true, 'office' => false], // Read-only forum
        self::AWAITING_PAYMENT => ['vote' => false, 'forum' => true, 'office' => false],
        self::ACTIVE => ['vote' => true, 'forum' => true, 'office' => true],
        self::SUSPENDED => ['vote' => false, 'forum' => false, 'office' => false],
        self::EXPIRED => ['vote' => false, 'forum' => false, 'office' => false],
        self::TERMINATED => ['vote' => false, 'forum' => false, 'office' => false],
    ];
    
    private string $value;
    
    private function __construct(string $value)
    {
        if (!in_array($value, self::VALID_STATUSES)) {
            throw new \InvalidArgumentException("Invalid member status: {$value}");
        }
        
        $this->value = $value;
    }
    
    public static function draft(): self
    {
        return new self(self::DRAFT);
    }
    
    public static function pending(): self
    {
        return new self(self::PENDING);
    }
    
    public static function underReview(): self
    {
        return new self(self::UNDER_REVIEW);
    }
    
    public static function approved(): self
    {
        return new self(self::APPROVED);
    }
    
    public static function awaitingPayment(): self
    {
        return new self(self::AWAITING_PAYMENT);
    }
    
    public static function active(): self
    {
        return new self(self::ACTIVE);
    }
    
    public static function suspended(): self
    {
        return new self(self::SUSPENDED);
    }
    
    public static function expired(): self
    {
        return new self(self::EXPIRED);
    }
    
    public static function terminated(): self
    {
        return new self(self::TERMINATED);
    }
    
    public static function fromString(string $value): self
    {
        return new self($value);
    }
    
    public function value(): string
    {
        return $this->value;
    }
    
    public function displayName(): string
    {
        return self::DISPLAY_NAMES[$this->value] ?? $this->value;
    }
    
    public function isDraft(): bool
    {
        return $this->value === self::DRAFT;
    }
    
    public function isPending(): bool
    {
        return $this->value === self::PENDING;
    }
    
    public function isUnderReview(): bool
    {
        return $this->value === self::UNDER_REVIEW;
    }
    
    public function isApproved(): bool
    {
        return $this->value === self::APPROVED;
    }
    
    public function isAwaitingPayment(): bool
    {
        return $this->value === self::AWAITING_PAYMENT;
    }
    
    public function isActive(): bool
    {
        return $this->value === self::ACTIVE;
    }
    
    public function isSuspended(): bool
    {
        return $this->value === self::SUSPENDED;
    }
    
    public function isExpired(): bool
    {
        return $this->value === self::EXPIRED;
    }
    
    public function isTerminated(): bool
    {
        return $this->value === self::TERMINATED;
    }
    
    public function canVote(): bool
    {
        return self::PRIVILEGES[$this->value]['vote'] ?? false;
    }
    
    public function canAccessForum(): bool
    {
        return self::PRIVILEGES[$this->value]['forum'] ?? false;
    }
    
    public function canHoldOffice(): bool
    {
        return self::PRIVILEGES[$this->value]['office'] ?? false;
    }
    
    public function canTransitionTo(string $newStatus): bool
    {
        return in_array($newStatus, self::TRANSITIONS[$this->value] ?? []);
    }
    
    public function allowedTransitions(): array
    {
        return self::TRANSITIONS[$this->value] ?? [];
    }
    
    public function transitionTo(string $newStatus): self
    {
        if (!$this->canTransitionTo($newStatus)) {
            throw InvalidStatusTransitionException::create(
                $this->value,
                $newStatus,
                $this->allowedTransitions()
            );
        }
        
        return new self($newStatus);
    }
    
    public function toArray(): array
    {
        return [
            'value' => $this->value,
            'display_name' => $this->displayName(),
            'can_vote' => $this->canVote(),
            'can_access_forum' => $this->canAccessForum(),
            'can_hold_office' => $this->canHoldOffice(),
            'allowed_transitions' => $this->allowedTransitions(),
        ];
    }
    
    public function equals(self $other): bool
    {
        return $this->value === $other->value;
    }
    
    public function __toString(): string
    {
        return $this->value;
    }
}
```

**Run test (should pass):**
```bash
php artisan test tests/Unit/Contexts/Membership/Domain/ValueObjects/MemberStatusTest.php
```

---

## **‚úÖ FINAL CHECK: RUN ALL VALUE OBJECT TESTS**

```bash
php artisan test tests/Unit/Contexts/Membership/Domain/ValueObjects/

# Expected output:
# ‚úì MembershipNumberTest
# ‚úì PersonalInfoTest  
# ‚úì SimpleGeographyTest
# ‚úì MemberStatusTest
# 
# PASSED: 35 assertions, 0 failures
```

---

## **üìù COMMIT MESSAGE**

```bash
git add .
git commit -m "RED: Implemented Value Objects with TDD approach

- MembershipNumber with format validation and parsing
- PersonalInfo with name/email/phone validation  
- SimpleGeography with progressive tier system (none ‚Üí basic ‚Üí advanced)
- MemberStatus with State Pattern and transition rules
- Comprehensive test coverage for all business rules"
```

---

## **üéØ NEXT STEP: MEMBER AGGREGATE ROOT**

Now that we have our Value Objects, we can proceed to **Step 2.1: Member Aggregate Tests**.

**Ready to move to the Member Aggregate implementation?**