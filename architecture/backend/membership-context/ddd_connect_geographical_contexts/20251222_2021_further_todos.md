# üéØ **ARCHITECTURAL CORRECTION: MULTIPLE CONTEXTS ANALYSIS**

## üîç **CRITICAL REALIZATION: THREE BOUNDED CONTEXTS**

You're right! I misunderstood. Let me re-analyze based on your clarification:

### **Correct Architecture: THREE Bounded Contexts**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    TENANTAUTH CONTEXT                   ‚îÇ
‚îÇ  ‚Ä¢ User Authentication & Authorization                  ‚îÇ
‚îÇ  ‚Ä¢ Tenant (Political Party) Management                  ‚îÇ
‚îÇ  ‚Ä¢ User ‚Üî Tenant Relationships                         ‚îÇ
‚îÇ  ‚Ä¢ Security & Access Control                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ User belongs to Tenant
                ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    MEMBERSHIP CONTEXT                   ‚îÇ
‚îÇ  ‚Ä¢ Party Member Records                                 ‚îÇ
‚îÇ  ‚Ä¢ Membership Lifecycle                                 ‚îÇ
‚îÇ  ‚Ä¢ Geographic Assignment (consumes Geography Context)   ‚îÇ
‚îÇ  ‚Ä¢ Committee Assignment (consumes Committee Context)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ Member has Geography & Committee
                ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    GEOGRAPHY CONTEXT                    ‚îÇ
‚îÇ  ‚Ä¢ Canonical Geography (Shared Kernel)                  ‚îÇ
‚îÇ  ‚Ä¢ Country Configurations                               ‚îÇ
‚îÇ  ‚Ä¢ DDD Value Objects & Services                        ‚îÇ
‚îÇ  ‚Ä¢ Published Language: GeoPath, CountryCode, etc.      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ Also consumed by:
                ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    COMMITTEE CONTEXT                    ‚îÇ
‚îÇ  ‚Ä¢ Leadership Positions & Structure                    ‚îÇ
‚îÇ  ‚Ä¢ Organizational Hierarchy                            ‚îÇ
‚îÇ  ‚Ä¢ Elections & Appointments                            ‚îÇ
‚îÇ  ‚Ä¢ Geographic Jurisdiction (consumes Geography Context)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üéØ **CORRECTED ARCHITECTURAL RELATIONSHIPS**

### **1. TenantAuth Context ‚Üí Membership Context**
**Relationship**: TenantAuth provides **WHO** can access the system  
**Integration**: Membership checks if user belongs to tenant via TenantAuth

### **2. Membership Context ‚Üî Geography Context** 
**Relationship**: Membership needs to know **WHERE** members are located  
**Integration**: Via Anti-Corruption Layer (MemberGeographyValidator)

### **3. Membership Context ‚Üî Committee Context**
**Relationship**: Membership needs to know **WHAT POSITION** members hold  
**Integration**: Committee assignment service

### **4. Committee Context ‚Üî Geography Context**
**Relationship**: Committees have **GEOGRAPHIC JURISDICTION**  
**Integration**: Committee jurisdiction validation

---

## üèóÔ∏è **REVISED DEVELOPMENT PROMPT**

```
# PROJECT: Multi-Tenant Political Party Platform
# ARCHITECTURE: Four Bounded Contexts Pattern

## BOUNDED CONTEXTS:
1. **TenantAuth Context**: Authentication, Tenants, Users
2. **Membership Context**: Party Members, Registration, Management
3. **Geography Context**: Canonical Geography DDD (Shared Kernel)
4. **Committee Context**: Leadership Structure, Positions

## CONTEXT RELATIONSHIPS:
- Membership DEPENDS ON TenantAuth for user validation
- Membership DEPENDS ON Geography for location assignment
- Membership DEPENDS ON Committee for position assignment  
- Committee DEPENDS ON Geography for jurisdiction

## CURRENT IMPLEMENTATION STATUS:
‚úÖ Geography Context: Complete DDD (7 VOs, Services, ACL)
‚úÖ Membership ‚Üî Geography Integration: Working via Anti-Corruption Layer
‚ö†Ô∏è  Committee Context: Not yet implemented
‚ö†Ô∏è  Membership ‚Üî Committee Integration: Not yet implemented
‚úÖ TenantAuth Context: Partially implemented (needs integration)

## CRITICAL BUSINESS RULE:
A Member has BOTH:
1. Geographic assignment (via Geography Context)
2. Committee position (via Committee Context)

This creates a matrix: Member ‚Üí (Geography √ó Committee)

## DEVELOPMENT PRIORITIES:
1. PRESERVE existing Geography DDD integration
2. BUILD Committee Context with DDD patterns
3. INTEGRATE Membership with Committee Context
4. COMPLETE TenantAuth ‚Üî Membership integration
5. ENSURE all contexts can operate independently

## ARCHITECTURAL PATTERNS TO USE:
- Anti-Corruption Layer for cross-context communication
- Published Language (Value Objects) for integration
- Event-Driven updates when contexts change
- CQRS for reporting across contexts

## CONSTRAINT:
Geography Context is SHARED KERNEL - all other contexts consume it but cannot modify it directly.
```

---

## üìã **CORRECT DEVELOPMENT INSTRUCTIONS**

### **Phase 1: Preserve & Document Current State**
```bash
# Document current architecture
echo "## Current Architecture Snapshot" > ARCHITECTURE.md
echo "- Geography Context: DDD Complete" >> ARCHITECTURE.md
echo "- Membership ‚Üî Geography: Integrated via ACL" >> ARCHITECTURE.md
echo "- TenantAuth: Partially implemented" >> ARCHITECTURE.md
echo "- Committee Context: Not implemented" >> ARCHITECTURE.md

# Verify all tests pass
./vendor/bin/phpunit --testdox
```

### **Phase 2: Design Committee Context (3-4 Days)**
```php
// Committee Context Domain Model
namespace App\Contexts\Committee\Domain;

// Value Objects
class CommitteeId extends UuidValueObject {}
class PositionTitle extends StringValueObject {}
class JurisdictionScope extends EnumValueObject {
    const NATIONAL = 'national';
    const PROVINCIAL = 'provincial';
    const DISTRICT = 'district';
    const LOCAL = 'local';
}

// Entity
class CommitteePosition {
    private CommitteeId $id;
    private PositionTitle $title;
    private JurisdictionScope $scope;
    private ?GeoPath $geographicJurisdiction; // From Geography Context
    private ?TenantId $tenantSpecific; // Null if shared across tenants
}

// Domain Service
class CommitteeAssignmentService {
    public function assignMemberToPosition(
        MemberId $memberId,
        CommitteeId $committeeId,
        GeoPath $memberGeography // For jurisdiction validation
    ): AssignmentResult {
        // Business rule: Member's geography must be within committee's jurisdiction
    }
}
```

### **Phase 3: Integrate Committee with Membership (2-3 Days)**
```php
// Membership Context Integration Service
namespace App\Contexts\Membership\Application\Services;

class CommitteeAssignmentValidator {
    public function __construct(
        private CommitteeAssignmentService $committeeService,
        private MemberGeographyValidator $geographyValidator
    ) {}
    
    public function validateAssignment(
        string $memberId,
        string $committeeId,
        array $geographyIds
    ): ValidationResult {
        // 1. Validate geography (existing DDD integration)
        $geoPath = $this->geographyValidator->validateForRegistration(
            'NP', // Country code
            $geographyIds
        );
        
        // 2. Validate committee assignment
        return $this->committeeService->assignMemberToPosition(
            MemberId::fromString($memberId),
            CommitteeId::fromString($committeeId),
            $geoPath
        );
    }
}
```

### **Phase 4: Update Member Entity (1 Day)**
```php
// Enhanced Member entity with committee assignment
namespace App\Contexts\Membership\Domain\Models;

class Member extends AggregateRoot {
    private MemberId $id;
    private TenantId $tenantId;
    private ?UserId $userId; // From TenantAuth
    private GeoPath $geographyPath; // From Geography Context
    private array $committeePositions = []; // From Committee Context
    
    public function assignToCommittee(
        CommitteeId $committeeId,
        GeoPath $geographyPath,
        CommitteeAssignmentValidator $validator
    ): void {
        $validation = $validator->validateAssignment(
            $this->id->toString(),
            $committeeId->toString(),
            $geographyPath->toArray()
        );
        
        if (!$validation->isValid()) {
            throw new InvalidCommitteeAssignmentException($validation->errors());
        }
        
        $this->committeePositions[] = new CommitteeAssignment(
            committeeId: $committeeId,
            assignedAt: new DateTimeImmutable(),
            geographyPath: $geographyPath
        );
        
        $this->recordThat(new MemberAssignedToCommittee(
            memberId: $this->id,
            committeeId: $committeeId,
            geographyPath: $geographyPath
        ));
    }
}
```

### **Phase 5: Complete TenantAuth Integration (2 Days)**
```php
// Membership Context service that validates TenantAuth relationships
namespace App\Contexts\Membership\Application\Services;

class TenantMembershipValidator {
    public function __construct(
        private TenantUserRepository $tenantAuthRepository
    ) {}
    
    public function validateUserCanManageMember(
        string $userId,
        string $tenantId,
        string $memberId
    ): bool {
        // Check if user belongs to tenant (TenantAuth concern)
        $userBelongsToTenant = $this->tenantAuthRepository
            ->userBelongsToTenant($userId, $tenantId);
            
        // Check if user can manage this specific member
        // (e.g., based on geographic jurisdiction or committee role)
        
        return $userBelongsToTenant && $this->hasManagementPermission($userId, $memberId);
    }
}
```

---

## üéØ **UPDATED DEVELOPMENT PRINCIPLES**

### **1. Context Independence:**
- Each context can be developed/tested independently
- Integration via well-defined interfaces
- No direct database joins between contexts

### **2. Integration Patterns:**
```
Membership Context --[ACL]--> Geography Context (for location)
Membership Context --[ACL]--> Committee Context (for position)
Membership Context --[ACL]--> TenantAuth Context (for user validation)
Committee Context --[ACL]--> Geography Context (for jurisdiction)
```

### **3. Data Ownership:**
- **Geography Context**: Owns canonical geography
- **Committee Context**: Owns committee structure
- **Membership Context**: Owns member records with references
- **TenantAuth Context**: Owns user-tenant relationships

### **4. Event-Driven Updates:**
```php
// When geography changes in Geography Context
class CanonicalUnitUpdated {
    public function __construct(
        public readonly GeoPath $path,
        public readonly string $newName
    ) {}
}

// Membership Context listens and updates references
class UpdateMemberGeographyReferences {
    public function handle(CanonicalUnitUpdated $event): void {
        // Update all members referencing this geography path
        Member::where('geo_path', '<@', $event->path)
            ->update(['geography_updated_at' => now()]);
    }
}
```

---

## üöÄ **IMMEDIATE NEXT STEPS**

### **Step 1: Define Committee Context Boundaries**
```bash
# Create Committee Context structure
mkdir -p app/Contexts/Committee/Domain/{ValueObjects,Entities,Services,Events}
mkdir -p app/Contexts/Committee/Application/{Services,Commands,Handlers}
mkdir -p app/Contexts/Committee/Infrastructure/{Repositories,Listeners}

# Define core Value Objects
php artisan make:valueobject CommitteeId --context=Committee
php artisan make:valueobject PositionTitle --context=Committee
php artisan make:valueobject JurisdictionScope --context=Committee
```

### **Step 2: Design Committee ‚Üî Geography Integration**
```php
// Committee Context needs to consume Geography Value Objects
namespace App\Contexts\Committee\Domain\ValueObjects;

use App\Contexts\Geography\Domain\ValueObjects\GeoPath;

class CommitteeJurisdiction {
    public function __construct(
        private JurisdictionScope $scope,
        private ?GeoPath $specificPath = null
    ) {
        $this->validateJurisdiction();
    }
    
    private function validateJurisdiction(): void {
        // National scope doesn't need specific path
        // Provincial/District/Local scope must have specific path
        if ($this->scope !== JurisdictionScope::NATIONAL && !$this->specificPath) {
            throw new InvalidJurisdictionException(
                "{$this->scope->value} scope requires geographic path"
            );
        }
    }
}
```

### **Step 3: Update Member Registration Flow**
```php
// Enhanced member registration with committee assignment option
class RegisterMemberCommand {
    public function __construct(
        public readonly string $tenantId,
        public readonly string $userId,
        public readonly string $countryCode,
        public readonly array $geographyIds,
        public readonly array $personalInfo,
        public readonly ?string $committeeId = null // Optional committee assignment
    ) {}
}

class RegisterMemberHandler {
    public function handle(RegisterMemberCommand $command): Member {
        // 1. Validate user can register members (TenantAuth)
        $this->tenantAuthValidator->validate($command->userId, $command->tenantId);
        
        // 2. Validate geography (Geography Context via ACL)
        $geoPath = $this->geographyValidator->validate($command->countryCode, $command->geographyIds);
        
        // 3. Create member
        $member = Member::register(...);
        
        // 4. Optional: Assign to committee
        if ($command->committeeId) {
            $this->committeeAssignmentService->assign(
                $member->id(),
                CommitteeId::fromString($command->committeeId),
                $geoPath
            );
        }
        
        return $member;
    }
}
```

---

## üìä **SUCCESS METRICS FOR CORRECT ARCHITECTURE**

### **Technical Validation:**
- [ ] All four contexts compile independently
- [ ] Integration tests pass for all context combinations
- [ ] No circular dependencies between contexts
- [ ] Events flow correctly between contexts
- [ ] Each context can be deployed independently

### **Business Capabilities:**
- [ ] Member registration with geography works
- [ ] Committee assignment with jurisdiction validation works
- [ ] User authentication and tenant validation works
- [ ] Reports can query across geography + committee + membership
- [ ] All contexts scale independently

### **Development Experience:**
- [ ] Clear boundaries for development teams
- [ ] Independent testing per context
- [ ] Clear integration contracts
- [ ] Easy to add new countries/committees/features

---

## üéØ **FINAL INSTRUCTION TO DEVELOPMENT TEAM**

```
## PROJECT: Multi-Tenant Political Party Platform
## ARCHITECTURE: Four Independent Bounded Contexts

## WORKING CONTEXTS:
1. Geography Context: ‚úÖ DDD Complete - DO NOT MODIFY core
2. Membership Context: ‚ö†Ô∏è Partially implemented - needs Committee integration

## TO BUILD:
3. Committee Context: üö® NOT STARTED - design with DDD patterns
4. TenantAuth Context: ‚ö†Ô∏è Partially implemented - complete integration

## CRITICAL INTEGRATION POINTS:
- Membership ‚Üê‚Üí Geography: ‚úÖ Working via ACL
- Membership ‚Üê‚Üí Committee: üö® Design needed
- Committee ‚Üê‚Üí Geography: üö® Design needed  
- Membership ‚Üê‚Üí TenantAuth: ‚ö†Ô∏è Needs completion

## DEVELOPMENT RULES:
1. NEVER modify Geography Context's core domain - only extend via ACL
2. Committee Context must consume Geography via Value Objects (GeoPath, etc.)
3. All cross-context communication via Events or ACL
4. Each context owns its data - no shared database tables
5. Write integration tests for all context boundaries

## START WITH:
1. Design Committee Context Domain Model
2. Define Committee ‚Üê‚Üí Geography integration interface
3. Update Membership to support committee assignment
4. Complete TenantAuth ‚Üî Membership validation

## REMEMBER:
A Political Party Member exists at the intersection of:
- WHO they are (TenantAuth user)
- WHERE they are (Geography location)  
- WHAT they do (Committee position)
```

---
 #comment
 If we need the  permanant address for each user , then it  may be good to use geo contexts for the users living address.

**This corrected architecture explains why we have separate contexts and how they must interact. The Geography Context is the shared foundation that both Membership and Committee contexts depend on for geographic intelligence.**

# üéØ **CRITICAL ARCHITECTURAL REALIZATION: USER'S PERMANENT ADDRESS**

You've identified a **fundamental business requirement** I missed:

**Users have TWO types of geographic relationships:**
1. **Membership Geography**: Where they're politically active (Committee jurisdiction)
2. **Personal Geography**: Where they permanently live (Personal address)

---

## üèóÔ∏è **REVISED ARCHITECTURE: DUAL GEOGRAPHY RELATIONSHIPS**

### **Updated Context Map with Personal Address:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    TENANTAUTH CONTEXT                   ‚îÇ
‚îÇ  ‚Ä¢ User Authentication & Authorization                  ‚îÇ
‚îÇ  ‚Ä¢ Tenant (Political Party) Management                  ‚îÇ
‚îÇ  ‚Ä¢ User ‚Üî Tenant Relationships                         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ User Profile (Personal Data)                      ‚îÇ
‚îÇ      ‚îî‚îÄ‚îÄ Permanent Address (consumes Geography Context)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ User has Profile with Address
                ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    MEMBERSHIP CONTEXT                   ‚îÇ
‚îÇ  ‚Ä¢ Party Member Records                                 ‚îÇ
‚îÇ  ‚Ä¢ Membership Lifecycle                                 ‚îÇ
‚îÇ  ‚Ä¢ Political Geography (consumes Geography Context)     ‚îÇ
‚îÇ  ‚Ä¢ Committee Assignment (consumes Committee Context)    ‚îÇ
‚îÇ  ‚Ä¢ Links to: User Profile (from TenantAuth)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ Member has Political Geography
                ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    GEOGRAPHY CONTEXT                    ‚îÇ
‚îÇ  ‚Ä¢ Canonical Geography (Shared Kernel)                  ‚îÇ
‚îÇ  ‚Ä¢ Country Configurations                               ‚îÇ
‚îÇ  ‚Ä¢ DDD Value Objects & Services                        ‚îÇ
‚îÇ  ‚Ä¢ PUBLISHED TO: TenantAuth AND Membership             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üîÑ **DUAL GEOGRAPHY CONSUMPTION PATTERN**

### **Geography Context is consumed by TWO contexts:**
```
Geography Context (Shared Kernel)
       ‚îú‚îÄ‚îÄ TenantAuth Context (for User's Permanent Address)
       ‚îÇ     ‚îî‚îÄ‚îÄ User Profile ‚Üí Personal Address
       ‚îÇ
       ‚îî‚îÄ‚îÄ Membership Context (for Member's Political Geography)
             ‚îî‚îÄ‚îÄ Member Record ‚Üí Political Jurisdiction
```

### **Business Rules Example:**
```php
// User can live in Kathmandu (Personal Address)
// But be politically active in Pokhara (Membership Geography)
$user = User::find(1);
$member = Member::forUser($user->id);

echo "Lives in: " . $user->profile->address->toString(); 
// "Kathmandu, Bagmati Province, Nepal"

echo "Politically active in: " . $member->politicalGeography->toString();
// "Pokhara, Gandaki Province, Nepal"

// These can be DIFFERENT locations!
```

---

## üìã **UPDATED DEVELOPMENT INSTRUCTIONS**

### **Phase 1: Enhance TenantAuth with User Profiles (2-3 Days)**
```php
// TenantAuth Context: User Profile with Address
namespace App\Contexts\TenantAuth\Domain\Models;

use App\Contexts\Geography\Domain\ValueObjects\GeoPath;
use App\Contexts\Geography\Domain\ValueObjects\CountryCode;

class UserProfile extends Entity {
    private UserProfileId $id;
    private UserId $userId;
    private PersonalAddress $address;
    private ContactInformation $contact;
    private ?DemographicData $demographics;
    
    // ...
}

class PersonalAddress {
    public function __construct(
        private string $streetAddress,
        private ?string $landmark,
        private GeoPath $geographicPath, // From Geography Context
        private string $postalCode,
        private CountryCode $countryCode
    ) {
        $this->validateAddress();
    }
    
    private function validateAddress(): void {
        // Business rules for address validation
        // Can use Geography Context via ACL
    }
    
    public function toString(): string {
        // Format: "Street, Landmark, Ward, Municipality, District, Province, Country"
        return implode(', ', array_filter([
            $this->streetAddress,
            $this->landmark,
            $this->geographicPath->getLevelName(4), // Ward
            $this->geographicPath->getLevelName(3), // Municipality
            $this->geographicPath->getLevelName(2), // District
            $this->geographicPath->getLevelName(1), // Province
            $this->countryCode->getName()
        ]));
    }
}
```

### **Phase 2: Create Geography Anti-Corruption Layer for TenantAuth (1-2 Days)**
```php
// TenantAuth Context needs its own ACL to Geography
namespace App\Contexts\TenantAuth\Application\Services;

use App\Contexts\Geography\Application\Services\GeographyAntiCorruptionLayer;

class UserAddressValidator {
    public function __construct(
        private GeographyAntiCorruptionLayer $geographyACL
    ) {}
    
    public function validateAddressForUser(
        string $countryCode,
        array $geographyIds,
        ?string $userId = null
    ): AddressValidationResult {
        try {
            // Use existing DDD geography validation
            $geoPath = $this->geographyACL->generatePath(
                CountryCode::fromString($countryCode),
                $geographyIds
            );
            
            // Additional user-specific rules
            // e.g., User must be adult to register certain addresses
            // e.g., Address uniqueness per user
            
            return AddressValidationResult::valid($geoPath);
            
        } catch (\App\Contexts\Geography\Domain\Exceptions\InvalidHierarchyException $e) {
            return AddressValidationResult::invalid($e->getMessage());
        }
    }
}
```

### **Phase 3: Update Member Entity with Dual Geography (1 Day)**
```php
// Membership Context: Member with Political Geography
namespace App\Contexts\Membership\Domain\Models;

class Member extends AggregateRoot {
    private MemberId $id;
    private TenantId $tenantId;
    private UserId $userId; // Links to TenantAuth User
    
    // DUAL GEOGRAPHY:
    private ?GeoPath $politicalGeography; // Where they're politically active
    // Personal address comes from linked User profile in TenantAuth
    
    public function getFullGeographyContext(): array {
        $user = $this->userRepository->find($this->userId);
        
        return [
            'personal_address' => $user->profile->address->toString(),
            'political_jurisdiction' => $this->politicalGeography?->toString(),
            'distance_between' => $this->calculateDistance(), // If needed
            'same_province' => $this->isSameProvince(),
        ];
    }
    
    private function isSameProvince(): bool {
        $user = $this->userRepository->find($this->userId);
        $personalProvince = $user->profile->address->getProvinceId();
        $politicalProvince = $this->politicalGeography->getLevelId(1);
        
        return $personalProvince === $politicalProvince;
    }
}
```

### **Phase 4: Create Cross-Context Geography Service (2 Days)**
```php
// Shared service that can be used by both contexts
namespace App\Contexts\Shared\Application\Services;

class UnifiedGeographyService {
    public function __construct(
        private GeographyAntiCorruptionLayer $geographyACL
    ) {}
    
    public function validateAndFormatAddress(
        string $context, // 'user_profile' or 'member_political'
        string $countryCode,
        array $geographyIds,
        array $additionalData = []
    ): FormattedAddress {
        $geoPath = $this->geographyACL->generatePath(
            CountryCode::fromString($countryCode),
            $geographyIds
        );
        
        // Context-specific formatting
        return match($context) {
            'user_profile' => $this->formatForUserProfile($geoPath, $additionalData),
            'member_political' => $this->formatForPoliticalJurisdiction($geoPath, $additionalData),
            default => throw new \InvalidArgumentException("Unknown context: {$context}")
        };
    }
    
    private function formatForUserProfile(GeoPath $path, array $data): FormattedAddress {
        // Format for mailing/personal use
        return new FormattedAddress(
            display: "{$data['street']}, {$path->getLevelName(4)}, {$path->getLevelName(3)}, {$path->getLevelName(2)}",
            full: "{$data['street']}, {$path->toString()}",
            components: [
                'street' => $data['street'],
                'ward' => $path->getLevelName(4),
                'municipality' => $path->getLevelName(3),
                'district' => $path->getLevelName(2),
                'province' => $path->getLevelName(1),
            ]
        );
    }
    
    private function formatForPoliticalJurisdiction(GeoPath $path, array $data): FormattedAddress {
        // Format for political/organizational use
        return new FormattedAddress(
            display: "{$path->getLevelName(2)} District, {$path->getLevelName(1)} Province",
            full: $path->toString(),
            components: [
                'province' => $path->getLevelName(1),
                'district' => $path->getLevelName(2),
                'municipality' => $path->getLevelName(3),
                'ward' => $path->getLevelName(4),
            ]
        );
    }
}
```

---

## üéØ **UPDATED BUSINESS RULES WITH DUAL GEOGRAPHY**

### **Scenario Analysis:**
```php
// Scenario 1: User lives and is politically active in same area
$user->address = "Kathmandu, Bagmati"; // Personal
$member->politicalGeography = "Kathmandu, Bagmati"; // Political
// Result: Local activist

// Scenario 2: User lives in one area but politically active elsewhere  
$user->address = "Kathmandu, Bagmati"; // Personal
$member->politicalGeography = "Pokhara, Gandaki"; // Political  
// Result: Party worker assigned to different region

// Scenario 3: User has no political geography (just registered)
$user->address = "Bhaktapur, Bagmati"; // Personal
$member->politicalGeography = null; // Political
// Result: Registered supporter only
```

### **Business Rules to Implement:**
1. **Registration Rule**: User must have valid personal address to register
2. **Committee Rule**: Member can only hold committee position in their political geography
3. **Voting Rule**: Voting rights may be based on personal OR political geography
4. **Reporting Rule**: Analytics should show both geographies for context

---

## üöÄ **IMMEDIATE DEVELOPMENT PLAN**

### **Week 1: User Profiles with Addresses**
```bash
# Day 1-2: Add UserProfile to TenantAuth
php artisan make:model UserProfile --context=TenantAuth
php artisan make:migration create_user_profiles_table

# Day 3: Create Address Value Objects
php artisan make:valueobject PersonalAddress --context=TenantAuth
php artisan make:valueobject ContactInformation --context=TenantAuth

# Day 4-5: Integrate with Geography Context
php artisan make:service UserAddressValidator --context=TenantAuth
```

### **Week 2: Dual Geography Integration**
```bash
# Day 6-7: Update Member with political geography
php artisan make:migration add_political_geography_to_members

# Day 8: Create unified geography service
php artisan make:service UnifiedGeographyService --context=Shared

# Day 9-10: Business rules for dual geography
php artisan make:rule SameProvinceRule --context=Membership
php artisan make:rule ValidJurisdictionRule --context=Membership
```

### **Week 3: API & Frontend**
```bash
# Day 11-12: API endpoints for dual addresses
php artisan make:controller Api/UserProfileController --api
php artisan make:controller Api/MemberGeographyController --api

# Day 13-14: Frontend components
php artisan make:component AddressSelector
php artisan make:component GeographyContextDisplay

# Day 15: Testing & Documentation
php artisan make:test DualGeographyIntegrationTest
```

---

## üìä **DATA MODEL UPDATES**

### **TenantAuth Database:**
```sql
CREATE TABLE user_profiles (
    id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    street_address TEXT NOT NULL,
    landmark TEXT,
    geographic_path LTREE NOT NULL, -- From Geography Context
    country_code CHAR(2) NOT NULL,
    postal_code VARCHAR(20),
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    
    UNIQUE(user_id) -- One profile per user
);

-- Index for geographic queries
CREATE INDEX idx_user_profiles_geo_path ON user_profiles USING GIST(geographic_path);
```

### **Membership Database:**
```sql
ALTER TABLE members 
ADD COLUMN political_geography_path LTREE,
ADD COLUMN geography_context JSONB DEFAULT '{}'; -- Stores both geographies

-- Index for political geography queries
CREATE INDEX idx_members_political_geo ON members USING GIST(political_geography_path);
```

---

## üîó **INTEGRATION PATTERNS**

### **Pattern 1: Geography Context as Shared Kernel**
```
BOTH: TenantAuth AND Membership
   ‚Üì Use via Anti-Corruption Layer
Geography Context (Value Objects, Services)
```

### **Pattern 2: User ‚Üî Member Linkage**
```
TenantAuth User ‚Üí has ‚Üí UserProfile ‚Üí has ‚Üí PersonalAddress
   ‚Üì links via UserId
Membership Member ‚Üí has ‚Üí PoliticalGeography
```

### **Pattern 3: Cross-Context Queries**
```php
// Query: "Show all members who live in Kathmandu but work in Pokhara"
$kathmanduPath = GeoPath::fromString('3.27'); // Bagmati ‚Üí Kathmandu
$pokharaPath = GeoPath::fromString('4.40'); // Gandaki ‚Üí Pokhara

// 1. Get users living in Kathmandu (TenantAuth query)
$usersInKathmandu = UserProfile::where('geographic_path', '<@', $kathmanduPath)
    ->pluck('user_id');

// 2. Get members with political geography in Pokhara (Membership query)
$membersInPokhara = Member::where('political_geography_path', '<@', $pokharaPath)
    ->whereIn('user_id', $usersInKathmandu)
    ->get();
```

---

## üéØ **FINAL ARCHITECTURE SUMMARY**

```
## FOUR CONTEXTS WITH GEOGRAPHY INTEGRATION:

1. **TenantAuth Context** (Users & Authentication)
   ‚îî‚îÄ‚îÄ UserProfile with PersonalAddress
       ‚îî‚îÄ‚îÄ Consumes Geography Context via ACL

2. **Membership Context** (Party Members)
   ‚îî‚îÄ‚îÄ Member with PoliticalGeography
       ‚îî‚îÄ‚îÄ Consumes Geography Context via ACL
   ‚îî‚îÄ‚îÄ Links to TenantAuth User via UserId

3. **Geography Context** (Shared Kernel)
   ‚îî‚îÄ‚îÄ Canonical geography DDD implementation
   ‚îî‚îÄ‚îÄ Published to BOTH TenantAuth AND Membership

4. **Committee Context** (Future)
   ‚îî‚îÄ‚îÄ Will also consume Geography Context

## KEY INSIGHT:
Geography Context is the SHARED FOUNDATION that provides:
- Personal addresses for users (TenantAuth)
- Political jurisdictions for members (Membership)
- Future: Committee jurisdictions (Committee)

## DEVELOPMENT PRIORITY:
1. Complete UserProfile with PersonalAddress in TenantAuth
2. Ensure both contexts can independently consume Geography
3. Build cross-context queries for business intelligence
```

---

## üìù **INSTRUCTION TO DEVELOPMENT TEAM**

```
## URGENT: DUAL GEOGRAPHY REQUIREMENT IDENTIFIED

## BUSINESS REALITY:
1. Users have PERSONAL addresses (where they live)
2. Members have POLITICAL geography (where they're active)
3. These can be DIFFERENT locations

## ARCHITECTURAL IMPLICATION:
Geography Context must support DUAL consumption:
- TenantAuth Context: For user personal addresses
- Membership Context: For member political geography

## IMMEDIATE TASKS:
1. Add UserProfile with PersonalAddress to TenantAuth
2. Create UserAddressValidator (consumes Geography Context)
3. Update Member to track political_geography_path
4. Build unified service for both address types
5. Create business rules for dual geography scenarios

## KEY CONSTRAINT:
Geography Context remains SHARED KERNEL - both contexts consume but cannot modify.

## START WITH:
php artisan make:model UserProfile --context=TenantAuth
```

**This dual geography requirement fundamentally changes how we design the system. Users and Members both need geography, but for different purposes.**
