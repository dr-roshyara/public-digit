Perfect! Now I understand the architecture. The `TenantApplication` is in the **landlord database** and managed by the **Platform Context**. The provisioning issues you mentioned need fixing. Let me follow TDD and DDD principles to address this.

## First: Let me examine the current state and write failing tests

### Step 1: Create a comprehensive test suite for Tenant Application approval workflow

```php
<?php

declare(strict_types=1);

namespace Tests\Feature\TenantAuth\TenantProvisioning;

use Tests\TestCase;
use App\Models\TenantApplication;
use App\Models\User;
use App\Models\Tenant;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Mail;
use App\Contexts\TenantAuth\Domain\Events\TenantCreated;
use App\Contexts\TenantAuth\Listeners\CreateTenantAdminUser;

class TenantProvisioningWorkflowTest extends TestCase
{
    /** @test */
    public function it_should_create_tenant_database_when_application_is_approved(): void
    {
        // Arrange
        Queue::fake();
        Event::fake();
        
        $admin = User::factory()->create();
        $admin->givePermissionTo(['manage-tenant-applications', 'approve-tenant-applications']);
        
        $application = TenantApplication::factory()->create([
            'status' => 'pending',
            'requested_slug' => 'test-tenant-' . uniqid(),
            'contact_email' => 'admin@testtenant.com',
        ]);

        // Act: Approve the application
        $response = $this->actingAs($admin)
            ->postJson(route('admin.tenant-applications.approve', $application->id), [
                'review_notes' => 'Test approval',
            ]);

        // Assert
        $response->assertStatus(200);
        $this->assertDatabaseHas('tenant_applications', [
            'id' => $application->id,
            'status' => 'approved',
        ]);

        // Check that tenant was created in landlord DB
        $this->assertDatabaseHas('tenants', [
            'slug' => $application->requested_slug,
        ]);

        // Verify queue job was dispatched
        Queue::assertPushedOn('tenant-provisioning', \App\Jobs\ProvisionTenantDatabaseJob::class);
    }

    /** @test */
    public function it_should_fail_when_slug_is_already_taken(): void
    {
        // Arrange
        $existingTenant = Tenant::factory()->create([
            'slug' => 'existing-tenant',
        ]);
        
        $admin = User::factory()->create();
        $admin->givePermissionTo('approve-tenant-applications');
        
        $application = TenantApplication::factory()->create([
            'status' => 'pending',
            'requested_slug' => 'existing-tenant', // Same as existing tenant
        ]);

        // Act
        $response = $this->actingAs($admin)
            ->postJson(route('admin.tenant-applications.approve', $application->id));

        // Assert
        $response->assertStatus(422);
        $response->assertJsonValidationErrors(['slug']);
        
        $this->assertDatabaseHas('tenant_applications', [
            'id' => $application->id,
            'status' => 'pending', // Should not be approved
        ]);
    }

    /** @test */
    public function it_should_create_admin_user_with_correct_password(): void
    {
        // Arrange
        $tenant = Tenant::factory()->create([
            'slug' => 'test-tenant',
            'email' => 'admin@testtenant.com',
        ]);

        $listener = new CreateTenantAdminUser();
        
        // Act
        $listener->handle(new TenantCreated($tenant));

        // Switch to tenant database context
        tenancy()->initialize($tenant);
        
        // Assert: Admin user exists with initial password
        $adminUser = \App\Models\TenantUser::where('email', 'admin@testtenant.com')->first();
        
        $this->assertNotNull($adminUser);
        $this->assertTrue($adminUser->force_password_change);
        $this->assertTrue(\Hash::check('Start1234!', $adminUser->password));
        $this->assertEquals('admin', $adminUser->type);
    }

    /** @test */
    public function it_should_send_credentials_email_with_password_setup_link(): void
    {
        // Arrange
        Mail::fake();
        
        $tenant = Tenant::factory()->create([
            'slug' => 'test-tenant',
            'email' => 'admin@testtenant.com',
        ]);

        $listener = new CreateTenantAdminUser();
        
        // Act
        $listener->handle(new TenantCreated($tenant));

        // Assert: Email was sent
        Mail::assertSent(\App\Contexts\Platform\Infrastructure\Mail\TenantProvisioningCompletedMail::class, function ($mail) use ($tenant) {
            return $mail->hasTo('admin@testtenant.com') &&
                   str_contains($mail->passwordSetupLink, '/setup/password/');
        });
    }

    /** @test */
    public function it_should_mark_application_as_provisioned_when_database_created(): void
    {
        // This test will fail initially because the provisioning job doesn't update application status
        
        // Arrange
        $application = TenantApplication::factory()->create([
            'status' => 'approved',
            'tenant_id' => null, // Not yet linked
        ]);

        $tenant = Tenant::factory()->create([
            'slug' => $application->requested_slug,
            'email' => $application->contact_email,
        ]);

        // Simulate successful database provisioning
        $provisioningService = app(\App\Contexts\Platform\Application\Services\TenantProvisioningService::class);
        
        // Act: Link tenant to application and mark as provisioned
        // This is what SHOULD happen but currently doesn't
        
        // Assert: These assertions will fail initially
        $this->assertDatabaseHas('tenant_applications', [
            'id' => $application->id,
            'tenant_id' => $tenant->id,
            'status' => 'provisioned',
            'provisioning_completed_at' => now(),
        ]);
    }

    /** @test */
    public function it_should_run_basic_migrations_on_tenant_database(): void
    {
        // Arrange
        $tenant = Tenant::factory()->create([
            'slug' => 'test-migration-tenant',
            'database_name' => 'tenant_test_migration_tenant',
        ]);

        // Act: Run basic migrations
        // This should be called by the provisioning job
        
        // Assert: Check that basic tables exist
        tenancy()->initialize($tenant);
        
        $tables = \DB::select('SHOW TABLES');
        $tableNames = array_column($tables, 'Tables_in_' . $tenant->database_name);
        
        $this->assertContains('tenant_users', $tableNames);
        $this->assertContains('tenant_user_registrations', $tableNames);
        $this->assertContains('committee_users', $tableNames);
        
        // Switch back to landlord
        tenancy()->end();
    }
}
```

### Step 2: Let me check the current provisioning service structure

Based on your code, I need to examine:

1. **TenantProvisioningService** in Platform Context
2. **CreateTenantAdminUser** listener
3. **ProvisionTenantDatabaseJob** (if exists)

Let me look at the `TenantProvisioningService`:

```php
<?php
// Let me check if this file exists and what's in it
// app/Contexts/Platform/Application/Services/TenantProvisioningService.php
```

If it doesn't exist, I need to create it following DDD patterns. But first, let me check what we have.

### Step 3: Analyze the issues you mentioned

From your description, the problems are:

1. **Basic migration not running automatically** - Need to ensure migrations run when tenant is created
2. **Password flow broken** - Initial password `Start1234!` and forced change
3. **Admin user creation** - First user should be tenant admin
4. **Application status updates** - Application should move from `approved` → `provisioned`

### Step 4: Create missing components (following TDD - tests will fail initially)

Let me create the missing provisioning service:

```php
<?php

declare(strict_types=1);

namespace App\Contexts\Platform\Application\Services;

use App\Contexts\Platform\Domain\ValueObjects\TenantSlug;
use App\Contexts\Platform\Domain\ValueObjects\DatabaseName;
use App\Contexts\Platform\Infrastructure\Repositories\TenantRepository;
use App\Models\TenantApplication;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class TenantProvisioningService
{
    public function __construct(
        private TenantRepository $tenantRepository
    ) {}

    public function provisionApprovedApplication(TenantApplication $application): void
    {
        try {
            // 1. Create tenant record in landlord DB
            $tenant = $this->createTenantFromApplication($application);
            
            // 2. Create tenant database
            $this->createTenantDatabase($tenant);
            
            // 3. Run basic migrations
            $this->runBasicMigrations($tenant);
            
            // 4. Update application status
            $application->update([
                'tenant_id' => $tenant->id,
                'status' => 'provisioned',
                'provisioning_completed_at' => now(),
            ]);
            
            // 5. Dispatch event for admin user creation
            event(new \App\Contexts\TenantAuth\Domain\Events\TenantCreated($tenant));
            
        } catch (\Exception $e) {
            Log::error('Tenant provisioning failed', [
                'application_id' => $application->id,
                'error' => $e->getMessage(),
            ]);
            
            $application->update([
                'provisioning_error' => $e->getMessage(),
                'status' => 'provisioning_failed',
            ]);
            
            throw $e;
        }
    }
    
    private function createTenantFromApplication(TenantApplication $application)
    {
        $slug = new TenantSlug($application->requested_slug);
        
        return $this->tenantRepository->create([
            'name' => $application->organization_name,
            'slug' => $slug->value(),
            'email' => $application->contact_email,
            'database_name' => 'tenant_' . $slug->value(),
        ]);
    }
    
    private function createTenantDatabase($tenant): void
    {
        $databaseName = 'tenant_' . $tenant->slug;
        
        // Create database
        DB::statement("CREATE DATABASE IF NOT EXISTS `{$databaseName}` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci");
        
        // Update tenant with database info
        $tenant->update([
            'database_name' => $databaseName,
        ]);
    }
    
    private function runBasicMigrations($tenant): void
    {
        // Switch to tenant database context
        config(['database.connections.tenant.database' => $tenant->database_name]);
        DB::purge('tenant');
        
        // Run migrations
        \Artisan::call('migrate', [
            '--database' => 'tenant',
            '--path' => 'app/Contexts/TenantAuth/Infrastructure/Database/Migrations',
            '--force' => true,
        ]);
        
        // Switch back to landlord
        config(['database.connections.tenant.database' => null]);
        DB::purge('tenant');
    }
    
    public function isSlugAvailable(string $slug): bool
    {
        // Check if slug is in reserved list
        $reservedSlugs = config('reserved-slugs', []);
        if (in_array($slug, $reservedSlugs)) {
            return false;
        }
        
        // Check if tenant already exists with this slug
        return !$this->tenantRepository->findBySlug($slug);
    }
}
```

### Step 5: Now I need to fix the `CreateTenantAdminUser` listener

Let me check what exists and fix it:

```php
<?php

declare(strict_types=1);

namespace App\Contexts\TenantAuth\Listeners;

use App\Contexts\TenantAuth\Domain\Events\TenantCreated;
use App\Contexts\TenantAuth\Domain\Services\UserProvisioningService;
use Illuminate\Support\Facades\Log;

class CreateTenantAdminUser
{
    public function __construct(
        private UserProvisioningService $userProvisioningService
    ) {}

    public function handle(TenantCreated $event): void
    {
        try {
            $tenant = $event->tenant;
            
            // Create admin user in tenant database
            $this->userProvisioningService->createAdminUser(
                $tenant->slug,
                $tenant->email,
                'Start1234!', // Initial password
                true // Force password change
            );
            
            Log::info('Admin user created for tenant', [
                'tenant_id' => $tenant->id,
                'tenant_slug' => $tenant->slug,
                'admin_email' => $tenant->email,
            ]);
            
        } catch (\Exception $e) {
            Log::error('Failed to create admin user for tenant', [
                'tenant_id' => $event->tenant->id,
                'error' => $e->getMessage(),
            ]);
            
            throw $e;
        }
    }
}
```

### Step 6: Create a queue job for async provisioning

```php
<?php

declare(strict_types=1);

namespace App\Jobs;

use App\Models\TenantApplication;
use App\Contexts\Platform\Application\Services\TenantProvisioningService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class ProvisionTenantDatabaseJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $queue = 'tenant-provisioning';
    
    public function __construct(
        private TenantApplication $application
    ) {}

    public function handle(TenantProvisioningService $provisioningService): void
    {
        Log::info('Starting tenant database provisioning', [
            'application_id' => $this->application->id,
            'slug' => $this->application->requested_slug,
        ]);
        
        try {
            $provisioningService->provisionApprovedApplication($this->application);
            
            Log::info('Tenant database provisioned successfully', [
                'application_id' => $this->application->id,
                'slug' => $this->application->requested_slug,
            ]);
            
        } catch (\Exception $e) {
            Log::error('Tenant database provisioning failed', [
                'application_id' => $this->application->id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            
            // Retry logic
            if ($this->attempts() < 3) {
                $this->release(60); // Retry after 60 seconds
            }
        }
    }
}
```

### Step 7: Update the Admin Controller to dispatch the job

In `TenantApplicationAdminController`, update the `approve` method:

```php
public function approve(string $applicationId): JsonResponse
{
    $application = TenantApplication::findOrFail($applicationId);
    
    // Validate slug availability
    if (!$this->provisioningService->isSlugAvailable($application->requested_slug)) {
        return response()->json([
            'message' => 'Slug is already taken',
            'errors' => ['slug' => ['The requested slug is not available']]
        ], 422);
    }
    
    // Update application status
    $application->update([
        'status' => 'approved',
        'reviewed_at' => now(),
        'reviewer_id' => auth()->id(),
        'review_notes' => $request->input('review_notes'),
    ]);
    
    // Dispatch provisioning job
    ProvisionTenantDatabaseJob::dispatch($application);
    
    return response()->json([
        'message' => 'Application approved and provisioning started',
        'application' => $application,
    ]);
}
```

## Questions for Clarification:

1. **Where should I put the `ProvisionTenantDatabaseJob`?** 
   - In `app/Jobs/` or within a DDD context?

2. **Do you have an existing `TenantProvisioningService`** that I should modify instead of creating a new one?

3. **What's the exact error you're seeing** when provisioning fails? 
   - Database connection issues? 
   - Migration errors? 
   - Queue not processing?

4. **Should the basic migrations include election setup tables too?** 
   - Or just auth tables for now?

## Next Steps (Following TDD):

1. **Run the failing tests** to confirm the issues
2. **Implement the missing services** 
3. **Fix the queue worker setup** (`php artisan queue:listen --queue=tenant-provisioning`)
4. **Test the complete workflow** from approval → database creation → admin user → email

**Which specific part should I focus on first?** The provisioning service, the queue job, or the admin user creation?