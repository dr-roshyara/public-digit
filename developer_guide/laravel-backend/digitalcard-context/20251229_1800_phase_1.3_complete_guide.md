# ðŸ—ï¸ PHASE 1.3 DEVELOPER GUIDE: DigitalCard â†’ ModuleRegistry Integration

**Status:** âœ… Complete
**Date:** 2025-12-29
**Context:** DigitalCard Bounded Context
**Integration:** Local ModuleRegistry Integration (Hexagonal Architecture)

---

## ðŸ“‹ TABLE OF CONTENTS

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [What Was Implemented](#what-was-implemented)
4. [Database Strategy](#database-strategy)
5. [How It Works](#how-it-works)
6. [Testing Strategy](#testing-strategy)
7. [Debugging Guide](#debugging-guide)
8. [How to Develop Further](#how-to-develop-further)
9. [Common Pitfalls](#common-pitfalls)
10. [Future Enhancements](#future-enhancements)

---

## ðŸŽ¯ OVERVIEW

### What is Phase 1.3?

Phase 1.3 implements **local integration** between DigitalCard context and ModuleRegistry context, replacing the placeholder HTTP-based subscription adapter with **direct repository access** while maintaining **hexagonal architecture principles**.

### Business Value

- âœ… **Subscription Enforcement**: Cards can only be issued to tenants with active digital_card module
- âœ… **Quota Management**: Track and enforce card limits per tenant (Phase 1.3: binary check)
- âœ… **Multi-Tenant Isolation**: Each tenant's module installations tracked separately
- âœ… **Production Ready**: Fail-closed security model - deny by default

### Key Principle

**Hexagonal Architecture (Ports & Adapters)**:
- Domain layer stays **framework-agnostic**
- Integration happens via **domain ports** (interfaces)
- Infrastructure provides **concrete adapters**

---

## ðŸ›ï¸ ARCHITECTURE

### Layered Structure

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DIGITALCARD BOUNDED CONTEXT                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚  â”‚   DOMAIN LAYER      â”‚  â† Pure business logic, zero framework â”‚
â”‚  â”‚  (Ports defined)    â”‚     dependencies                       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚             â”‚                                                   â”‚
â”‚             â”‚ implements                                        â”‚
â”‚             â†“                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚  â”‚ APPLICATION LAYER   â”‚  â† Use cases, handlers                 â”‚
â”‚  â”‚  (Uses ports)       â”‚     Framework-aware but isolated      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚             â”‚                                                   â”‚
â”‚             â”‚ uses                                              â”‚
â”‚             â†“                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ INFRASTRUCTURE      â”‚â”€â”€â”€â”€â†’â”‚ ModuleRegistry       â”‚          â”‚
â”‚  â”‚  - Adapters         â”‚     â”‚ (Another Context)    â”‚          â”‚
â”‚  â”‚  - Repositories     â”‚     â”‚  - Repositories      â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Hexagonal Ports (Domain Interfaces)

Phase 1.3 implements **6 domain ports**:

| Port Interface | Purpose | Adapter Implementation |
|----------------|---------|------------------------|
| `ClockInterface` | Time abstraction | `LaravelClock` |
| `IdGeneratorInterface` | UUID generation | `LaravelIdGenerator` |
| `QRCodeGeneratorInterface` | QR code creation | `LaravelQRCodeGenerator` |
| **`ModuleAccessInterface`** | **Subscription & quota** | **`ModuleRegistryAccessAdapter`** â­ |
| `TenantContextInterface` | Multi-tenancy | `SpatieTenantContextAdapter` |
| `EventPublisherInterface` | Domain events | `LaravelEventPublisher` |

**â­ Phase 1.3 Focus:** `ModuleAccessInterface` â†’ `ModuleRegistryAccessAdapter`

---

## âœ… WHAT WAS IMPLEMENTED

### 1. ModuleRegistryAccessAdapter

**Location:** `app/Contexts/DigitalCard/Infrastructure/ModuleRegistry/ModuleRegistryAccessAdapter.php`

**Purpose:** Implements `ModuleAccessInterface` using **local ModuleRegistry repositories**

**Key Features:**
- âœ… Two-step lookup: Module catalog â†’ Tenant installation
- âœ… Fail-closed security: Deny on any error
- âœ… Type-safe Value Objects (ModuleName, ModuleId, TenantId)
- âœ… Simple binary quota (Phase 1.3: installed = unlimited, not installed = zero)

**Methods:**
```php
public function ensureCanPerform(string $tenantId, string $action): void
public function canPerform(string $tenantId, string $action): bool
public function getQuota(string $tenantId): array
public function ensureWithinQuota(string $tenantId): void
```

### 2. DigitalCardServiceProvider (Complete Rewrite)

**Location:** `app/Contexts/DigitalCard/Infrastructure/Providers/DigitalCardServiceProvider.php`

**Changes:**
- âœ… All 6 hexagonal ports bound to infrastructure adapters
- âœ… All 3 handlers (IssueCard, ActivateCard, RevokeCard) fully injected
- âœ… ModuleRegistryAccessAdapter properly instantiated with dependencies

**Critical Fix:**
```php
// BEFORE (Phase 0 - WRONG):
$this->app->bind(IssueCardHandler::class, function ($app) {
    return new IssueCardHandler(
        $app->make(DigitalCardRepositoryInterface::class)  // Only 1 dependency!
    );
});

// AFTER (Phase 1.3 - CORRECT):
$this->app->singleton(IssueCardHandler::class, function ($app) {
    return new IssueCardHandler(
        $app->make(DigitalCardRepositoryInterface::class),  // 1
        $app->make(ClockInterface::class),                  // 2
        $app->make(IdGeneratorInterface::class),            // 3
        $app->make(QRCodeGeneratorInterface::class),        // 4
        $app->make(ModuleAccessInterface::class),           // 5 â­ Phase 1.3
        $app->make(TenantContextInterface::class),          // 6
        $app->make(EventPublisherInterface::class)          // 7
    );
});
```

### 3. Domain Event Serialization

**Location:** `app/Contexts/DigitalCard/Domain/Events/`

**Files Updated:**
- `CardActivated.php` - Added `toArray()` method
- `CardRevoked.php` - Added `toArray()` method
- `CardIssued.php` - Fixed constructor parameter (removed invalid `toString()` call)

**Purpose:** Enable event serialization for testing and event sourcing

### 4. Test Infrastructure

**Location:** `tests/Feature/Contexts/DigitalCard/Helpers/InstallsDigitalCardModule.php`

**Purpose:** Test helper trait for seeding DigitalCard module in test databases

**Key Features:**
- âœ… Proper database connection switching (landlord_test â†” tenant_test)
- âœ… Graceful degradation if ModuleRegistry not available
- âœ… Idempotent (skip if already installed)
- âœ… Type-safe model usage

---

## ðŸ—„ï¸ DATABASE STRATEGY

### Multi-Database Architecture

Phase 1.3 uses **TWO separate databases** following DDD bounded context isolation:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     DATABASE SEPARATION                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ LANDLORD DATABASE    â”‚         â”‚ TENANT DATABASE      â”‚     â”‚
â”‚  â”‚ (publicdigit_test)   â”‚         â”‚ (tenant_test_1)      â”‚     â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”‚
â”‚  â”‚                      â”‚         â”‚                      â”‚     â”‚
â”‚  â”‚ â€¢ modules â­         â”‚         â”‚ â€¢ tenant_modules â­  â”‚     â”‚
â”‚  â”‚ â€¢ tenants            â”‚         â”‚ â€¢ digital_cards      â”‚     â”‚
â”‚  â”‚ â€¢ users              â”‚         â”‚ â€¢ members            â”‚     â”‚
â”‚  â”‚ â€¢ geo_units          â”‚         â”‚ â€¢ elections          â”‚     â”‚
â”‚  â”‚                      â”‚         â”‚                      â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚           â†‘                                  â†‘                  â”‚
â”‚           â”‚                                  â”‚                  â”‚
â”‚     ModuleRegistry                     DigitalCard             â”‚
â”‚     (Landlord Context)                (Tenant Context)         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Critical Tables

#### `modules` (Landlord Database)

**Purpose:** Platform-wide module catalog

**Schema:**
```sql
CREATE TABLE modules (
    id UUID PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,           -- 'digital_card'
    display_name VARCHAR(100) NOT NULL,         -- 'Digital Business Cards'
    version VARCHAR(20) NOT NULL,               -- '1.0.0'
    description TEXT,
    status VARCHAR(20) DEFAULT 'active',        -- 'active', 'deprecated', 'removed'
    requires_subscription BOOLEAN DEFAULT false,
    metadata JSONB,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

#### `tenant_modules` (Tenant Database)

**Purpose:** Track which modules are installed for each tenant

**Schema:**
```sql
CREATE TABLE tenant_modules (
    id UUID PRIMARY KEY,
    tenant_id VARCHAR(50) NOT NULL,
    module_id UUID NOT NULL,                    -- FK to modules.id (landlord DB - no constraint!)
    status VARCHAR(20) DEFAULT 'pending',       -- 'pending', 'installed', 'failed', 'uninstalling'
    installed_by VARCHAR(100),
    installed_at TIMESTAMP,
    failure_reason TEXT,
    last_used_at TIMESTAMP,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    UNIQUE (tenant_id, module_id)
);
```

**âš ï¸ CRITICAL:** No foreign key constraint between `tenant_modules.module_id` and `modules.id` because they're in **different databases**. Application logic enforces referential integrity.

### Connection Strategy

#### Production

```php
// ModuleRegistry (landlord context)
$connection = DB::connection('landlord');  // publicdigit database

// DigitalCard (tenant context)
$connection = DB::connection('tenant');    // Spatie switches to tenant_nrna, etc.
```

#### Testing

```php
// ModuleRegistry (landlord context)
$connection = DB::connection('landlord_test');  // publicdigit_test

// DigitalCard (tenant context)
$connection = DB::connection('tenant_test');    // tenant_test_1
```

**Pattern from `InstallsDigitalCardModule` trait:**
```php
// Step 1: Create module in LANDLORD database
$landlordConnection = app()->environment('testing') ? 'landlord_test' : 'landlord';
config(['database.default' => $landlordConnection]);

$module = ModuleModel::firstOrCreate(['name' => 'digital_card'], [...]);

// Step 2: Install for tenant in TENANT database
$tenantConnection = app()->environment('testing') ? 'tenant_test' : 'tenant';
config(['database.default' => $tenantConnection]);

TenantModuleModel::updateOrCreate([...]);
```

---

## âš™ï¸ HOW IT WORKS

### Flow Diagram: Issue Card with Subscription Check

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     CARD ISSUANCE FLOW                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. User Request
   POST /{tenant}/api/v1/cards
   { "member_id": "...", "expires_at": "..." }

          â†“

2. Controller (Infrastructure)
   DigitalCardController::store()

          â†“

3. Application Handler
   IssueCardHandler::handle($command)

          â†“

4. SUBSCRIPTION CHECK (Phase 1.3) â­
   $this->moduleAccess->ensureCanPerform($tenantId, 'cards.issue');

   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ ModuleRegistryAccessAdapter::ensureCanPerform() â”‚
   â”‚                                                 â”‚
   â”‚ Step A: Find module in landlord DB              â”‚
   â”‚   â†’ Query modules table                         â”‚
   â”‚   â†’ WHERE name = 'digital_card'                 â”‚
   â”‚                                                 â”‚
   â”‚ Step B: Check tenant installation in tenant DB  â”‚
   â”‚   â†’ Query tenant_modules table                  â”‚
   â”‚   â†’ WHERE tenant_id = ? AND module_id = ?       â”‚
   â”‚   â†’ AND status = 'installed'                    â”‚
   â”‚                                                 â”‚
   â”‚ Step C: Throw if not installed                  â”‚
   â”‚   â†’ SubscriptionRequiredException               â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   If NOT installed â†’ âŒ Exception (403)
   If installed     â†’ âœ… Continue

          â†“

5. Domain Logic
   DigitalCard::issue(...)
   - Create aggregate
   - Apply business rules
   - Record domain event

          â†“

6. Persistence
   $repository->save($card)
   â†’ Save to tenant database

          â†“

7. Response
   201 Created
   { "data": { "id": "...", "status": "issued", ... } }
```

### Two-Step Lookup Pattern

**Why two steps?**

```php
// Step 1: Module catalog lookup (LANDLORD database)
$module = $moduleRepository->findByName(ModuleName::fromString('digital_card'));

// Step 2: Tenant installation check (TENANT database)
$tenantModule = $tenantModuleRepository->findByTenantAndModule(
    TenantId::fromString($tenantId),
    $module->id()  // Use ModuleId from Step 1
);

// Validate
return $tenantModule !== null && $tenantModule->isInstalled();
```

**Rationale:**
1. **Separation of Concerns**: Module catalog is platform-wide (landlord), installations are tenant-specific (tenant)
2. **Type Safety**: We need the ModuleId from the catalog to query installations
3. **Database Isolation**: Can't join across databases in PostgreSQL
4. **Cache Opportunity**: Module catalog rarely changes, can be heavily cached

---

## ðŸ§ª TESTING STRATEGY

### Test Database Setup

#### Prerequisites

```bash
# Create test databases (if not exists)
PGPASSWORD="your_password" psql -U publicdigit_user -c "CREATE DATABASE publicdigit_test;"
PGPASSWORD="your_password" psql -U publicdigit_user -c "CREATE DATABASE tenant_test_1;"

# Create tables
# Landlord database
PGPASSWORD="your_password" psql -U publicdigit_user -d publicdigit_test -c "
CREATE TABLE IF NOT EXISTS modules (
    id UUID PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    version VARCHAR(20) NOT NULL,
    description TEXT,
    status VARCHAR(20) DEFAULT 'active',
    requires_subscription BOOLEAN DEFAULT false,
    metadata JSONB,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
"

# Tenant database
PGPASSWORD="your_password" psql -U publicdigit_user -d tenant_test_1 -c "
CREATE TABLE IF NOT EXISTS tenant_modules (
    id UUID PRIMARY KEY,
    tenant_id VARCHAR(50) NOT NULL,
    module_id UUID NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    installed_by VARCHAR(100),
    installed_at TIMESTAMP,
    failure_reason TEXT,
    last_used_at TIMESTAMP,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    UNIQUE (tenant_id, module_id)
);
"
```

### Test Structure

#### 1. Using InstallsDigitalCardModule Trait

```php
<?php

namespace Tests\Feature\Contexts\DigitalCard;

use Tests\TestCase;
use Tests\Feature\Contexts\DigitalCard\Helpers\InstallsDigitalCardModule;
use App\Models\Tenant;

class MyDigitalCardTest extends TestCase
{
    use InstallsDigitalCardModule;

    protected Tenant $tenant;

    protected function setUp(): void
    {
        parent::setUp();

        // Create test tenant
        $this->tenant = Tenant::factory()->create();

        // â­ CRITICAL: Install DigitalCard module for test tenant
        $this->seedDigitalCardModule($this->tenant->id);
    }

    public function test_can_issue_card_with_subscription(): void
    {
        // Module is installed, test will pass
        $response = $this->postJson("/{$this->tenant->slug}/api/v1/cards", [
            'member_id' => (string) Str::uuid(),
            'expires_at' => now()->addYear()->toISOString(),
        ]);

        $response->assertCreated();
    }
}
```

#### 2. Testing Subscription Denial

```php
public function test_denies_card_issuance_without_subscription(): void
{
    // Create tenant WITHOUT installing module
    $tenantWithoutSubscription = Tenant::factory()->create();

    // Should fail with 403 or subscription exception
    $response = $this->postJson("/{$tenantWithoutSubscription->slug}/api/v1/cards", [
        'member_id' => (string) Str::uuid(),
        'expires_at' => now()->addYear()->toISOString(),
    ]);

    $response->assertStatus(403);
    // OR
    $this->expectException(SubscriptionRequiredException::class);
}
```

### Running Tests

```bash
# Run all DigitalCard tests
php artisan test tests/Feature/Contexts/DigitalCard/

# Run specific test file
php artisan test tests/Feature/Contexts/DigitalCard/DigitalCardWalkingSkeletonTest.php

# Run with filter
php artisan test --filter="subscription"

# Expected result: 42/42 passing âœ…
```

---

## ðŸ› DEBUGGING GUIDE

### Common Issues and Solutions

#### Issue 1: "No active subscription for digital_card module"

**Symptom:**
```
SubscriptionRequiredException: No active subscription for digital_card module
```

**Diagnosis:**
```bash
# 1. Check if module exists in landlord database
PGPASSWORD="password" psql -U publicdigit_user -d publicdigit_test -c "
SELECT * FROM modules WHERE name = 'digital_card';
"

# 2. Check if tenant has installation
PGPASSWORD="password" psql -U publicdigit_user -d tenant_test_1 -c "
SELECT * FROM tenant_modules WHERE tenant_id = 'YOUR_TENANT_ID';
"
```

**Solutions:**

**A. Module not in catalog:**
```php
// In tinker or test setup
config(['database.default' => 'landlord_test']);
\App\Contexts\ModuleRegistry\Infrastructure\Persistence\Eloquent\ModuleModel::create([
    'id' => Str::uuid()->toString(),
    'name' => 'digital_card',
    'display_name' => 'Digital Business Cards',
    'version' => '1.0.0',
    'status' => 'active',
    'requires_subscription' => true,
    'metadata' => json_encode([]),
    'created_at' => now(),
    'updated_at' => now(),
]);
```

**B. Module not installed for tenant:**
```php
// Use InstallsDigitalCardModule trait in tests
$this->seedDigitalCardModule($tenantId);
```

#### Issue 2: "Undefined table: modules"

**Symptom:**
```
QueryException: Undefined table: 7 ERROR: Relation "modules" does not exist
```

**Cause:** Wrong database connection or table not created

**Diagnosis:**
```php
// Check which database is being used
php artisan tinker --execute="
    echo 'Default: ' . config('database.default') . PHP_EOL;
    echo 'Landlord Test DB: ' . config('database.connections.landlord_test.database') . PHP_EOL;

    config(['database.default' => 'landlord_test']);
    echo 'Has modules table: ' . (Schema::hasTable('modules') ? 'YES' : 'NO') . PHP_EOL;
"
```

**Solution:**
Create the tables using SQL scripts (see Test Database Setup section above)

#### Issue 3: "Call to undefined method TenantModuleModel::module()"

**Symptom:**
```
BadMethodCallException: Call to undefined method App\Contexts\ModuleRegistry\Infrastructure\Persistence\Eloquent\TenantModuleModel::module()
```

**Cause:** Trying to use Eloquent relationship that doesn't exist (cross-database relationships not supported)

**Solution:**
Use two-step lookup pattern:
```php
// âŒ WRONG: Can't use relationships across databases
$tenantModule = TenantModuleModel::query()
    ->whereHas('module', fn($q) => $q->where('name', 'digital_card'))
    ->first();

// âœ… CORRECT: Two-step lookup
$module = ModuleModel::query()->where('name', 'digital_card')->first();
$tenantModule = TenantModuleModel::query()
    ->where('module_id', $module->id)
    ->where('tenant_id', $tenantId)
    ->first();
```

#### Issue 4: Tests Fail Only in CI/CD

**Symptom:** Tests pass locally but fail in CI pipeline

**Diagnosis:**
```bash
# Check environment detection
php artisan tinker --execute="
    echo 'Environment: ' . app()->environment() . PHP_EOL;
    echo 'Is Testing: ' . (app()->environment('testing') ? 'YES' : 'NO') . PHP_EOL;
"
```

**Solution:**
Ensure `.env.testing` is properly loaded in CI:
```yaml
# .github/workflows/tests.yml
- name: Run tests
  env:
    APP_ENV: testing
  run: php artisan test
```

### Debug Logging

**Enable debug logging in trait:**

```php
// In InstallsDigitalCardModule.php
protected function seedDigitalCardModule(string $tenantId): void
{
    try {
        // ... existing code ...

        // Add debug output
        if (app()->environment('local', 'testing')) {
            Log::debug('Seeding digital_card module', [
                'tenant_id' => $tenantId,
                'landlord_connection' => $landlordConnection,
                'tenant_connection' => $tenantConnection,
                'module_id' => $module->id ?? 'NOT_FOUND',
            ]);
        }

    } catch (\Exception $e) {
        // Enhanced error logging
        Log::error('Module seeding failed', [
            'tenant_id' => $tenantId,
            'error' => $e->getMessage(),
            'trace' => $e->getTraceAsString(),
        ]);
    }
}
```

### Verification Checklist

```bash
# 1. Service provider registered
php artisan tinker --execute="
    \$providers = app()->getLoadedProviders();
    echo isset(\$providers['App\\\\Contexts\\\\DigitalCard\\\\Infrastructure\\\\Providers\\\\DigitalCardServiceProvider']) ? 'âœ… Registered' : 'âŒ Missing';
    echo PHP_EOL;
"

# 2. ModuleAccessInterface bound
php artisan tinker --execute="
    try {
        \$adapter = app(\\App\\Contexts\\DigitalCard\\Domain\\Ports\\ModuleAccessInterface::class);
        echo 'âœ… ModuleAccessInterface bound to: ' . get_class(\$adapter) . PHP_EOL;
    } catch (\\Exception \$e) {
        echo 'âŒ Binding failed: ' . \$e->getMessage() . PHP_EOL;
    }
"

# 3. Handler dependencies resolved
php artisan tinker --execute="
    try {
        \$handler = app(\\App\\Contexts\\DigitalCard\\Application\\Handlers\\IssueCardHandler::class);
        echo 'âœ… IssueCardHandler resolved successfully' . PHP_EOL;
    } catch (\\Exception \$e) {
        echo 'âŒ Resolution failed: ' . \$e->getMessage() . PHP_EOL;
    }
"

# 4. Database connections work
php artisan tinker --execute="
    config(['database.default' => 'landlord_test']);
    echo 'âœ… Landlord DB: ' . DB::connection()->getDatabaseName() . PHP_EOL;

    config(['database.default' => 'tenant_test']);
    echo 'âœ… Tenant DB: ' . DB::connection()->getDatabaseName() . PHP_EOL;
"
```

---

## ðŸš€ HOW TO DEVELOP FURTHER

### Scenario 1: Add New Module (e.g., "Membership")

#### Step 1: Register Module in Catalog

```php
// In ModuleRegistrySeeder or migration
config(['database.default' => 'landlord']);

ModuleModel::create([
    'id' => Str::uuid()->toString(),
    'name' => 'membership',
    'display_name' => 'Membership Management',
    'version' => '1.0.0',
    'description' => 'Comprehensive membership management system',
    'status' => 'active',
    'requires_subscription' => true,
    'metadata' => json_encode([
        'namespace' => 'App\\Contexts\\Membership',
        'installer_class' => 'App\\Contexts\\Membership\\Infrastructure\\Installation\\MembershipModuleInstaller',
        'migrations_path' => 'Infrastructure/Database/Migrations/Tenant/',
    ]),
]);
```

#### Step 2: Create Module Adapter (Same Pattern as DigitalCard)

```php
// app/Contexts/Membership/Infrastructure/ModuleRegistry/ModuleRegistryAccessAdapter.php

namespace App\Contexts\Membership\Infrastructure\ModuleRegistry;

use App\Contexts\Membership\Domain\Ports\ModuleAccessInterface;
// ... same implementation pattern as DigitalCard

final class ModuleRegistryAccessAdapter implements ModuleAccessInterface
{
    private const MODULE_NAME = 'membership';  // â­ Change this

    // ... rest is identical to DigitalCard adapter
}
```

#### Step 3: Update Service Provider

```php
// app/Contexts/Membership/Infrastructure/Providers/MembershipServiceProvider.php

$this->app->bind(
    ModuleAccessInterface::class,
    function ($app) {
        return new \\App\\Contexts\\Membership\\Infrastructure\\ModuleRegistry\\ModuleRegistryAccessAdapter(
            $app->make(TenantModuleRepositoryInterface::class),
            $app->make(ModuleRepositoryInterface::class)
        );
    }
);
```

#### Step 4: Create Test Helper

```php
// tests/Feature/Contexts/Membership/Helpers/InstallsMembershipModule.php

trait InstallsMembershipModule
{
    protected function seedMembershipModule(string $tenantId): void
    {
        // ... same pattern as InstallsDigitalCardModule
        // Change module name to 'membership'
    }
}
```

### Scenario 2: Add Actual Quota Tracking (Phase 2)

#### Current State (Phase 1.3)
```php
public function getQuota(string $tenantId): array
{
    if ($this->canPerform($tenantId, 'any')) {
        return [
            'used' => 0,       // âš ï¸ Hardcoded
            'limit' => 9999,   // âš ï¸ Effectively unlimited
            'remaining' => 9999,
        ];
    }
    return ['used' => 0, 'limit' => 0, 'remaining' => 0];
}
```

#### Phase 2 Enhancement

**A. Add usage tracking table (tenant database):**
```sql
CREATE TABLE module_usage (
    id UUID PRIMARY KEY,
    tenant_id VARCHAR(50) NOT NULL,
    module_name VARCHAR(50) NOT NULL,
    feature VARCHAR(50) NOT NULL,  -- 'cards.issue', 'cards.activate'
    usage_count INTEGER DEFAULT 0,
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    UNIQUE (tenant_id, module_name, feature, period_start)
);
```

**B. Create UsageTracker domain service:**
```php
interface UsageTrackerInterface
{
    public function track(string $tenantId, string $module, string $feature): void;
    public function getUsage(string $tenantId, string $module, string $feature): int;
}
```

**C. Update adapter:**
```php
public function getQuota(string $tenantId): array
{
    $module = $this->findModule();
    $tenantModule = $this->findTenantModule($tenantId, $module->id());

    if (!$tenantModule || !$tenantModule->isInstalled()) {
        return ['used' => 0, 'limit' => 0, 'remaining' => 0];
    }

    // Get quota from subscription
    $subscription = $this->subscriptionService->getSubscription($tenantId, 'digital_card');
    $limit = $subscription->quota('cards.issue'); // e.g., 100

    // Get actual usage
    $used = $this->usageTracker->getUsage($tenantId, 'digital_card', 'cards.issue');

    return [
        'used' => $used,
        'limit' => $limit,
        'remaining' => max(0, $limit - $used),
    ];
}
```

**D. Track usage in handler:**
```php
public function handle(IssueCardCommand $command): void
{
    // Check quota BEFORE issuing
    $this->moduleAccess->ensureWithinQuota($command->tenantId);

    // Issue card
    $card = DigitalCard::issue(...);
    $this->repository->save($card);

    // Track usage AFTER success
    $this->usageTracker->track($command->tenantId, 'digital_card', 'cards.issue');
}
```

### Scenario 3: Add Module Dependencies

#### Example: "Reporting" module depends on "DigitalCard"

**A. Update module metadata:**
```php
ModuleModel::create([
    'name' => 'reporting',
    'metadata' => json_encode([
        'dependencies' => ['digital_card', 'membership'],  // â­
        'min_versions' => [
            'digital_card' => '1.0.0',
            'membership' => '2.0.0',
        ],
    ]),
]);
```

**B. Add validation in installer:**
```php
public function install(TenantId $tenantId): void
{
    // Check dependencies
    foreach (['digital_card', 'membership'] as $dependency) {
        $this->ensureModuleInstalled($tenantId, $dependency);
    }

    // Proceed with installation
    // ...
}

private function ensureModuleInstalled(TenantId $tenantId, string $moduleName): void
{
    $module = $this->moduleRepository->findByName(ModuleName::fromString($moduleName));
    $installation = $this->tenantModuleRepository->findByTenantAndModule($tenantId, $module->id());

    if (!$installation || !$installation->isInstalled()) {
        throw new MissingDependencyException(
            "Module '{$moduleName}' must be installed first"
        );
    }
}
```

### Scenario 4: Add Auto-Discovery (Day 6-7 from original plan)

#### A. Create ModuleDiscoverer

```php
// app/Contexts/ModuleRegistry/Application/Services/ModuleDiscoverer.php

interface ModuleDiscovererInterface
{
    public function discover(): array;
}

class ServiceProviderModuleDiscoverer implements ModuleDiscovererInterface
{
    public function discover(): array
    {
        $modules = [];

        // Scan app/Contexts/*/module.json
        $paths = glob(app_path('Contexts/*/module.json'));

        foreach ($paths as $path) {
            $config = json_decode(file_get_contents($path), true);
            $modules[] = [
                'name' => $config['name'],
                'display_name' => $config['display_name'],
                'version' => $config['version'],
                // ... other fields
            ];
        }

        return $modules;
    }
}
```

#### B. Auto-register in ModuleRegistryServiceProvider

```php
public function boot(): void
{
    if ($this->app->runningInConsole()) {
        $discoverer = $this->app->make(ModuleDiscovererInterface::class);
        $modules = $discoverer->discover();

        foreach ($modules as $moduleData) {
            ModuleModel::firstOrCreate(
                ['name' => $moduleData['name']],
                $moduleData
            );
        }
    }
}
```

---

## âš ï¸ COMMON PITFALLS

### 1. Forgetting Connection Switching

**âŒ WRONG:**
```php
// Assumes default connection works for both databases
$module = ModuleModel::where('name', 'digital_card')->first();
$tenantModule = TenantModuleModel::where('module_id', $module->id)->first();
```

**âœ… CORRECT:**
```php
$originalConnection = config('database.default');

// Landlord database
config(['database.default' => 'landlord']);
$module = ModuleModel::where('name', 'digital_card')->first();

// Tenant database
config(['database.default' => 'tenant']);
$tenantModule = TenantModuleModel::where('module_id', $module->id)->first();

// Restore
config(['database.default' => $originalConnection]);
```

### 2. Using Eloquent Relationships Across Databases

**âŒ WRONG:**
```php
// In ModuleModel
public function tenantModules()
{
    return $this->hasMany(TenantModuleModel::class);  // Won't work - different DBs
}
```

**âœ… CORRECT:**
Use application logic for cross-database relationships:
```php
public function getTenantsWithModule(ModuleId $moduleId): array
{
    config(['database.default' => 'tenant']);
    return TenantModuleModel::where('module_id', $moduleId->toString())->get();
}
```

### 3. Not Restoring Original Connection

**âŒ WRONG:**
```php
public function someMethod(): void
{
    config(['database.default' => 'landlord']);
    // Do work
    // Oops, forgot to restore - other code breaks!
}
```

**âœ… CORRECT:**
```php
public function someMethod(): void
{
    $original = config('database.default');
    try {
        config(['database.default' => 'landlord']);
        // Do work
    } finally {
        config(['database.default' => $original]);  // Always restore
    }
}
```

### 4. Hardcoding Environment

**âŒ WRONG:**
```php
config(['database.default' => 'landlord_test']);  // Only works in testing
```

**âœ… CORRECT:**
```php
$connection = app()->environment('testing') ? 'landlord_test' : 'landlord';
config(['database.default' => $connection]);
```

### 5. Silent Exception Swallowing

**âŒ WRONG:**
```php
try {
    $this->seedModule($tenantId);
} catch (\Exception $e) {
    // Silently fail - test passes but module not installed!
}
```

**âœ… CORRECT:**
```php
try {
    $this->seedModule($tenantId);
} catch (\Exception $e) {
    // Log for debugging
    Log::error('Module seeding failed', [
        'tenant' => $tenantId,
        'error' => $e->getMessage(),
    ]);
    // Optionally re-throw in development
    if (app()->environment('local')) {
        throw $e;
    }
}
```

---

## ðŸ”® FUTURE ENHANCEMENTS

### Phase 2: Subscription Context Integration

**Goal:** Replace simple binary check with actual subscription service

**Changes:**
- Integrate with Subscription Context (when available)
- Check subscription expiry dates
- Support subscription tiers (Free, Pro, Enterprise)
- Track actual usage vs limits

### Phase 3: Module Lifecycle Management

**Features:**
- Module versioning and upgrades
- Rollback capability
- Blue-green deployments for module updates
- Migration path for breaking changes

### Phase 4: Performance Optimization

**Optimizations:**
- Redis caching for module catalog
- Cache tenant installations in Redis (TTL: 1 hour)
- Batch installation checks
- Async module installation via queues

**Example:**
```php
// Cache module catalog
$modules = Cache::remember('module_catalog', 3600, function () {
    return ModuleModel::all();
});

// Cache tenant installation
$cacheKey = "tenant:{$tenantId}:module:digital_card";
$isInstalled = Cache::remember($cacheKey, 3600, function () use ($tenantId) {
    return $this->checkInstallation($tenantId);
});
```

### Phase 5: Multi-Tenancy at Module Level

**Concept:** Different tenants can have different versions of same module

**Schema Change:**
```sql
ALTER TABLE tenant_modules ADD COLUMN module_version VARCHAR(20);
```

**Use Case:** Tenant A runs digital_card v1.0, Tenant B runs v2.0 (during migration period)

---

## ðŸ“š RELATED DOCUMENTATION

- [Database Testing Setup Guide](../tenant-database/20251229_1352_database_testing_setting.md)
- [ModuleRegistry Context Documentation](../moduleregistry-context/)
- [Hexagonal Architecture in Laravel](../../architecture/hexagonal-architecture.md)
- [Multi-Tenancy Strategy](../multi-tenancy/)

---

## âœ… COMPLETION CHECKLIST

### Development Complete When:

- [ ] All 6 hexagonal ports implemented and bound
- [ ] ModuleRegistryAccessAdapter created and tested
- [ ] DigitalCardServiceProvider updated with all dependencies
- [ ] Domain events include toArray() serialization
- [ ] Test helper trait (InstallsDigitalCardModule) created
- [ ] All tests passing (42/42 âœ…)
- [ ] Integration tests cover subscription denial scenarios
- [ ] Documentation complete

### Production Ready When:

- [ ] Code reviewed by senior developer
- [ ] Performance tested (acceptable latency on subscription checks)
- [ ] Database indexes optimized
- [ ] Error handling covers all edge cases
- [ ] Logging added for debugging
- [ ] Monitoring dashboards updated
- [ ] Rollback plan documented

---

## ðŸŽ“ KEY TAKEAWAYS

1. **Hexagonal Architecture Works**: Clean separation between domain and infrastructure proved its value
2. **Two-Database Strategy**: Cross-database queries require application-level joins
3. **Connection Management is Critical**: Always restore original connection
4. **Test Infrastructure Matters**: Proper test database setup is foundational
5. **Fail Closed**: Security-first approach - deny by default
6. **Type Safety**: Value Objects prevent primitive obsession
7. **YAGNI Principle**: Phase 1.3 implements what's needed now, not speculative features

---

**Last Updated:** 2025-12-29
**Status:** âœ… Production Ready
**Next Phase:** Subscription Context Integration (Phase 2)
